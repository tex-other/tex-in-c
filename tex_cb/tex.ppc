#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
/* for fabs() */
#include <math.h>
#include "p2c.h"

#include "tex.h"
#include "str.h"
#include "funcs.h"
#include "global.h"
#include "printout.h"
#include "fonts.h"
#include "texfunc.h"
#include "dviout.h"

#define formatextension  S(".fmt")
#define pack_tok(tok,cs,cmd,chr) do { \
	if(cs==0) { \
		tok = dwa_do_8*cmd +chr; \
	} else { \
		tok = cstokenflag + cs; \
	} \
    } while (0)
	

static void (*string_print_proc)(strASCIIcode c)=str_appendchar;

unsigned char nameoffile[filenamesize];
ASCIIcode buffer[bufsize + 1];
short first;
short last;
short maxbufstack;
strnumber formatident;
instaterecord curinput;
jmp_buf _JLfinalend;
ASCIIcode xord[256];
/*13:*/
Static long bad;   
Static scaled
	      texremainder, maxh, maxv, ruleht, ruledp, rulewd;

/*:13*/
/*20:*/
Static Char xchr[256];
/*:20*/
/*26:*/
Static int namelength;
/*:26*/
/*30:*/
/*:30*/
/*32:*/
Static FILE *termin, *termout;
/*:32*/
/*54:*/
Static FILE *logfile;
Static unsigned char selector; /* INT */
Static long tally;
Static char termoffset;
Static char fileoffset;
Static ASCIIcode trickbuf[errorline + 1];
Static long trickcount, firstcount;
/*:54*/
/*73:*/
Static char interaction;
/*:73*/
/*76:*/
Static boolean deletionsallowed, setboxallowed;
Static char history;
Static schar errorcount;
/*:76*/
/*79:*/
Static strnumber helpline[6];
Static unsigned char helpptr;
Static boolean useerrhelp;
/*:79*/
/*96:*/
Static long interrupt;
Static boolean OKtointerrupt;
/*:96*/
/*104:*/
Static boolean aritherror;
/*:104*/
/*115:*/
Static pointer tempptr, lomemmax, himemmin;
/*:115*/
/*116:*/
Static memoryword mem[memmax - memmin + 1];
/*
static struct my_mem my_memtab[memmax - memmin + 1];
*/
/*:116*/
/*117:*/
Static long varused, dynused;
/*:117*/
/*118:*/
Static pointer avail, memend;
/*:118*/
/*124:*/
Static pointer rover, wasmemend, waslomax, washimin, hashused, curcs,
	       warningindex, defref;
/*:124*/
/*165:*/
/*_DEBUG*/
Static uchar free_[(memmax - memmin + 8) / 8];
Static uchar wasfree[(memmax - memmin + 8) / 8];
Static boolean panicking;
/*_ENDDEBUG*/
/*:165*/
/*173:*/
Static long fontinshortdisplay;
/*:173*/
/*181:*/
Static long depththreshold, breadthmax;
/*:181*/
/*213:*/
Static liststaterecord nest[nestsize + 1];
Static unsigned char nestptr; /* INT */
Static char maxneststack;
Static liststaterecord curlist;
Static short shownmode;
/*:213*/
/*246:*/
Static char diag_oldsetting;   /*:246*/
/*253:*/
Static memoryword eqtb[eqtbsize - activebase + 1]; 
/* 
extern memoryword eqtb[];
memoryword * eqtb_foo(void) { return eqtb;}
*/
Static quarterword xeqlevel[eqtbsize - intbase + 1];
/*:253*/
/*256:*/
Static twohalves hash[undefinedcontrolsequence - hashbase];
Static boolean nonewcontrolsequence; 
Static long cscount;   /*:256*/
/*271:*/
Static memoryword savestack[savesize + 1];
Static short saveptr;
Static short maxsavestack;
Static quarterword curlevel;
Static groupcode curgroup;
Static short curboundary;
/*:271*/
/*286:*/
Static long magset;
/*:286*/
/*297:*/
Static eightbits curcmd;
Static halfword curchr, curtok;   /*:297*/
/*301:*/
Static instaterecord inputstack[stacksize + 1];
Static uchar inputptr;
Static uchar maxinstack;
/*:301*/
/*304:*/
Static char inopen;
Static char openparens;
Static FILE *inputfile[maxinopen];
Static long line;
Static long linestack[maxinopen];
/*:304*/
/*305:*/
Static char scannerstatus;
/*:305*/
/*308:*/
Static pointer paramstack[paramsize + 1];
Static /* char */ int paramptr; /* INT */
Static long maxparamstack;
/*:308*/
/*309:*/
Static long alignstate;
/*:309*/
/*310:*/
Static uchar baseptr;
/*:310*/
/*333:*/
Static pointer parloc;
Static halfword partoken;
/*:333*/
/*361:*/
Static boolean forceeof;   /*:361*/
/*382:*/
Static pointer curmark[splitbotmarkcode - topmarkcode + 1];   /*:382*/
/*387:*/
Static char longstate;
/*:387*/
/*388:*/
/*:388*/
/*410:*/
Static long curval;
Static char curvallevel;
/*:410*/
/*438:*/
Static smallnumber radix;
/*:438*/
/*447:*/
Static glueord curorder;
/*:447*/
/*480:*/
Static FILE *readfile[16];
Static char readopen[17];
/*:480*/
/*489:*/
Static pointer condptr;
/* , g; */
Static char iflimit;
Static smallnumber curif;
Static long ifline;
/*:489*/
/*493:*/
Static long skipline;
/*:493*/
/*512:*/
Static strnumber curname, curarea, curext;
/*:512*/
/*513:*/
#if 0
Static poolpointer areadelimiter, extdelimiter;
#else 
Static strnumber extdelimiter;
#endif
/*:513*/
/*520:*/
Static Char TEXformatdefault[formatdefaultlength];   /*:520*/
/*527:*/
Static boolean nameinprogress;
Static strnumber jobname;
Static boolean logopened;   /*:527*/
/*532:*/
#if 0
Static FILE *dvifile;
#else 
FILE *dvifile;
#endif
Static strnumber outputfilename, logname;   /*:532*/
/*539:*/
Static FILE *tfmfile;
/*:539*/
/*555:*/
Static fourquarters nullcharacter;
/*:555*/
/*592:*/
Static long totalpages, maxpush, /* lastbop, */ deadcycles;
Static boolean doingleaders;
Static long lq, lr;
/*:592*/
/*616:*/
Static scaled dvih, dviv, curh, curv, curmu;
Static internalfontnumber dvif;
Static long curs;
/*:616*/
/*646:*/
Static scaled totalstretch[filll - normal + 1],
	      totalshrink[filll - normal + 1];
Static long lastbadness;
/*:646*/
/*647:*/
Static pointer adjusttail;
/*:647*/
/*661:*/
Static long packbeginline;
/*:661*/
/*684:*/
Static twohalves emptyfield;
Static fourquarters nulldelimiter;
/*:684*/
/*719:*/
Static pointer curmlist;
Static smallnumber curstyle, cursize;
Static boolean mlistpenalties;
/*:719*/
/*724:*/
Static internalfontnumber curf;
Static quarterword curc;
Static fourquarters curi;
/*:724*/
/*764:*/
/*:764*/
/*770:*/
Static pointer curalign, curspan, curloop, alignptr, curhead, curtail;
/*:770*/
/*814:*/
Static pointer justbox;
/*:814*/
/*821:*/
Static pointer passive, printednode;
Static halfword passnumber;
/*:821*/
/*823:*/
Static scaled activewidth[6];
Static scaled curactivewidth[6];
Static scaled background[6];
Static scaled breakwidth[6];
/*:823*/
/*825:*/
Static boolean noshrinkerroryet, secondpass, finalpass;
/*:825*/
/*828:*/
Static pointer curp;
Static long threshold;
/*:828*/
/*833:*/
Static long minimaldemerits[tightfit - veryloosefit + 1];
Static long minimumdemerits;
Static pointer bestplace[tightfit - veryloosefit + 1];
Static halfword bestplline[tightfit - veryloosefit + 1];
/*:833*/
/*839:*/
Static scaled discwidth, firstwidth, secondwidth, firstindent, secondindent;
/*:839*/
/*847:*/
Static halfword easyline, lastspecialline;
/*:847*/
/*872:*/
Static pointer bestbet, ha, hb, initlist, curq, ligstack;
Static long fewestdemerits;
Static halfword bestline;
Static long actuallooseness, linediff;
/*:872*/
/*892:*/
Static short hc[66];
Static /* smallnumber */ int hn; /* INT */
Static internalfontnumber hf;
Static short hu[64];
Static long hyfchar;
Static ASCIIcode curlang, initcurlang;
Static long lhyf, rhyf, initlhyf, initrhyf;
Static halfword hyfbchar;
/*:892*/
/*900:*/
Static char hyf[65];
Static boolean initlig, initlft;
/*:900*/
/*905:*/
Static smallnumber hyphenpassed;
/*:905*/
/*907:*/
Static halfword curl, curr;
Static boolean ligaturepresent, lfthit, rthit;
/*:907*/
/*921:*/
Static twohalves trie[triesize + 1];
Static smallnumber hyfdistance[trieopsize];
Static smallnumber hyfnum[trieopsize];
Static quarterword hyfnext[trieopsize];
Static short opstart[256];
/*:921*/
/*926:*/
Static strnumber hyphword[hyphsize + 1];
Static pointer hyphlist[hyphsize + 1];
Static hyphpointer hyphcount;
/*:926*/
/*943:*/
Static short trieophash[trieopsize + trieopsize + 1];
Static quarterword trieused[256];
Static ASCIIcode trieoplang[trieopsize];
Static quarterword trieopval[trieopsize];
Static short trieopptr;
/*:943*/
/*947:*/
Static packedASCIIcode triec[triesize + 1];
Static quarterword trieo[triesize + 1];
Static triepointer triel[triesize + 1];
Static triepointer trier[triesize + 1];
Static triepointer trieptr;
Static triepointer triehash[triesize + 1];
/*:947*/
/*950:*/
Static uchar trietaken[(triesize + 7) / 8];
Static triepointer triemin[256];
Static triepointer triemax;
Static boolean trienotready;
/*:950*/
/*971:*/
Static scaled bestheightplusdepth, pagemaxdepth, bestsize, lastkern;
/*:971*/
/*980:*/
Static pointer pagetail, bestpagebreak, lastglue, mainp;
Static char pagecontents;
Static long leastpagecost;
/*:980*/
/*982:*/
Static scaled pagesofar[8];
Static long lastpenalty, insertpenalties;
/*:982*/
/*989:*/
Static boolean outputactive;
/*:989*/
/*1032:*/
Static internalfontnumber mainf;
Static fourquarters maini, mainj;
Static fontindex maink;
Static long mains;
Static halfword bchar, falsebchar;
Static boolean cancelboundary, insdisc;
/*:1032*/
/*1074:*/
Static pointer curbox;
/*:1074*/
/*1266:*/
Static halfword aftertoken;
/*:1266*/
/*1281:*/
Static boolean longhelpseen;
/*:1281*/
/*1299:*/
/*:1299*/
/*1305:*/
Static FILE *fmtfile;
/*:1305*/
/*1331:*/
Static long readyalready;
/*:1331*/
/*1342:*/
Static FILE *writefile[16];
Static boolean writeopen[18];
/*:1342*/
/*1345:*/
Static pointer writeloc;   /*:1345*/

int get_defaulthyphenchar(void)
{
	return defaulthyphenchar;
}

int get_defaultskewchar(void)
{
	return defaultskewchar;
}

pointer get_lomemmax(void)
{
	return lomemmax;
}

strnumber fontidtext(internalfontnumber x)
{
    return text(fontidbase+x);
}

void set_fontidtext(internalfontnumber x, strnumber t)
{
    text(fontidbase+x)=t;
}

void set_help(int k,...)
{
	va_list ap;
	va_start(ap,k);
	helpptr=k;
	k--;	
	while(k>=0) { 
		helpline[k]=va_arg(ap,int);
		k--;
	}
	va_end(ap);
}

Static int hex_to_i(int c, int cc)
{
	int res=(c<='9')?(c-'0'):(c-'a'+10);
	res*=16;
	res+=(cc<='9')?(cc-'0'):(cc-'a'+10);
	return res;
}


Static void initialize(void)
{   /*:927*/
  /*19:*/
  long i;
  /*:19*/
  /*163:*/
  long k;
  /*:163*/
  /*927:*/
  hyphpointer z;

  /*8:*/
  /*23:*/
  for (i = 0; i <= 255; i++)
    xchr[i] = (Char)i;
  /*:23*/
  /*24:*/
  for (i = firsttextchar; i <= lasttextchar; i++)
    xord[(Char)i] = invalidcode;
  for (i = 128; i <= 255; i++)
    xord[xchr[i]] = i;
  for (i = 0; i <= 126; i++)   /*:24*/
    xord[xchr[i]] = i;
  /*74:*/
  interaction = errorstopmode;   /*:74*/
  /*77:*/
  deletionsallowed = true;
  setboxallowed = true;
  errorcount = 0;   /*:77*/
  /*80:*/
  helpptr = 0;
  useerrhelp = false;   /*:80*/
  /*97:*/
  interrupt = 0;
  OKtointerrupt = true;   /*:97*/
  /*166:*/
  /*_DEBUG*/
  wasmemend = memmin;
  waslomax = memmin;
  washimin = memmax;
  panicking = false;   /*_ENDDEBUG*/
  /*:166*/
  /*215:*/
  nestptr = 0;
  maxneststack = 0;
  mode = vmode;
  head = contribhead;
  tail = contribhead;
  prevdepth = ignoredepth;
  modeline = 0;
  prevgraf = 0;
  shownmode = 0;   /*991:*/
  pagecontents = empty;
  pagetail = pagehead;
  link(pagehead) = 0;
  lastglue = maxhalfword;
  lastpenalty = 0;
  lastkern = 0;
  pagedepth = 0;
  pagemaxdepth = 0;   /*:991*/
  /*:215*/
  /*254:*/
  for (k = intbase; k <= eqtbsize; k++)
    xeqlevel[k - intbase] = levelone;
  /*:254*/
  /*257:*/

  nonewcontrolsequence = true;

  next(hashbase) = 0;
  text(hashbase) = 0;
  for (k = hashbase + 1; k < undefinedcontrolsequence; k++)   /*:257*/
    hash[k - hashbase] = hash[0];
  /*272:*/
  saveptr = 0;
  curlevel = levelone;
  curgroup = bottomlevel;
  curboundary = 0;
  maxsavestack = 0;   /*:272*/
  /*287:*/
  magset = 0;   /*:287*/
  /*383:*/
  topmark = 0;
  firstmark = 0;
  botmark = 0;
  splitfirstmark = 0;
  splitbotmark = 0;   /*:383*/
  /*439:*/
  curval = 0;
  curvallevel = intval;
  radix = 0;
  curorder = 0;   /*:439*/
  /*481:*/
  for (k = 0; k <= 16; k++)   /*:481*/
    readopen[k] = closed;
  /*490:*/
  condptr = 0;
  iflimit = normal;
  curif = 0;
  ifline = 0;   /*:490*/
  /*521:*/
  memcpy(TEXformatdefault, "TeXformats:plain.fmt", formatdefaultlength);
      /*:521*/
#if 0
/* XXXXXXXXXXXX */
  /*551:*/
  for (k = 0 ; k <= fontmax; k++)   /*:551*/
    fontused[k ] = false;
#endif
  /*556:*/
  nullcharacter.b0 = minquarterword;
  nullcharacter.b1 = minquarterword;
  nullcharacter.b2 = minquarterword;
  nullcharacter.b3 = minquarterword;   /*:556*/
  /*593:*/
  totalpages = 0;
  maxv = 0;
  maxh = 0;
  maxpush = 0;
  doingleaders = false;
  deadcycles = 0;
  curs = -1;   /*:593*/
  dviout_init();
  /*648:*/
  adjusttail = 0;
  lastbadness = 0;   /*:648*/
  /*662:*/
  packbeginline = 0;   /*:662*/
  /*685:*/
  emptyfield.rh = empty;
  emptyfield.UU.lh = 0;
  nulldelimiter.b0 = 0;
  nulldelimiter.b1 = minquarterword;
  nulldelimiter.b2 = 0;
  nulldelimiter.b3 = minquarterword;   /*:685*/
  /*771:*/
  alignptr = 0;
  curalign = 0;
  curspan = 0;
  curloop = 0;
  curhead = 0;
  curtail = 0;   /*:771*/
  /*928:*/
  for (z = 0; z <= hyphsize; z++) {
    hyphword[z] = 0;
    hyphlist[z] = 0;
  }
  hyphcount = 0;   /*:928*/
  /*990:*/
  outputactive = false;
  insertpenalties = 0;   /*:990*/
  /*1033:*/
  ligaturepresent = false;
  cancelboundary = false;
  lfthit = false;
  rthit = false;
  insdisc = false;   /*:1033*/
  /*1267:*/
  aftertoken = 0;   /*:1267*/
  /*1282:*/
  longhelpseen = false;   /*:1282*/
  /*1300:*/
  formatident = 0;   /*:1300*/
  /*1343:*/
  for (k = 0; k <= 17; k++)   /*:1343*/
    writeopen[k] = false;
  /*164:*/
  for (k = membot + 1; k <= lomemstatmax; k++)
    mem[k - memmin].sc = 0;
  k = membot;
  while (k <= lomemstatmax) {
    gluerefcount(k) = 1;
    stretchorder(k) = normal;
    shrinkorder(k) = normal;
    k += gluespecsize;
  }
  stretch(filglue) = unity;
  stretchorder(filglue) = fil;
  stretch(fillglue) = unity;
  stretchorder(fillglue) = fill;
  stretch(ssglue) = unity;
  stretchorder(ssglue) = fil;
  shrink(ssglue) = unity;
  shrinkorder(ssglue) = fil;
  stretch(filnegglue) = -unity;
  stretchorder(filnegglue) = fil;
  rover = lomemstatmax + 1;
  link(rover) = emptyflag;
  nodesize(rover) = 1000;
  llink(rover) = rover;
  rlink(rover) = rover;
  lomemmax = rover + 1000;
  link(lomemmax) = 0;
  info(lomemmax) = 0;
  for (k = himemstatmin; k <= memtop; k++)   /*790:*/
    mem[k - memmin] = mem[lomemmax - memmin];
  info(omittemplate) = endtemplatetoken;   /*:790*/
  /*797:*/
  link(endspan) = maxquarterword + 1;
  info(endspan) = 0;   /*:797*/
  /*820:*/
  type(lastactive) = hyphenated;
  linenumber(lastactive) = maxhalfword;
  subtype(lastactive) = 0;
  /*:820*/
  /*981:*/
  subtype(pageinshead) = minquarterword + 255;
  type(pageinshead) = splitup;
  link(pageinshead) = pageinshead;   /*:981*/
  /*988:*/
  type(pagehead) = gluenode;
  subtype(pagehead) = normal;
  /*:988*/
  avail = 0;
  memend = memtop;
  himemmin = himemstatmin;
  varused = lomemstatmax - membot + 1;
  dynused = himemstatusage;   /*:164*/
  /*222:*/
  eqtype(undefinedcontrolsequence) = undefinedcs;
  equiv(undefinedcontrolsequence) = 0;
  eqlevel(undefinedcontrolsequence) = levelzero;
  for (k = activebase; k < undefinedcontrolsequence; k++)   /*:222*/
    eqtb[k - activebase] = eqtb[undefinedcontrolsequence - activebase];
  /*228:*/
  equiv(gluebase) = zeroglue;
  eqlevel(gluebase) = levelone;
  eqtype(gluebase) = glueref;
  for (k = gluebase + 1; k < localbase; k++)
    eqtb[k - activebase] = eqtb[gluebase - activebase];
  gluerefcount(zeroglue) += localbase - gluebase;   /*:228*/
  /*232:*/
  parshapeptr = 0;
  eqtype(parshapeloc) = shaperef;
  eqlevel(parshapeloc) = levelone;
  for (k = outputroutineloc; k <= toksbase + 255; k++)
    eqtb[k - activebase] = eqtb[undefinedcontrolsequence - activebase];
  box(0) = 0;
  eqtype(boxbase) = boxref;
  eqlevel(boxbase) = levelone;
  for (k = boxbase + 1; k <= boxbase + 255; k++)
    eqtb[k - activebase] = eqtb[boxbase - activebase];
  curfont = nullfont;
  eqtype(curfontloc) = data;
  eqlevel(curfontloc) = levelone;
  for (k = mathfontbase; k <= mathfontbase + 47; k++)
    eqtb[k - activebase] = eqtb[curfontloc - activebase];
  equiv(catcodebase) = 0;
  eqtype(catcodebase) = data;
  eqlevel(catcodebase) = levelone;
  for (k = catcodebase + 1; k < intbase; k++)
    eqtb[k - activebase] = eqtb[catcodebase - activebase];
  for (k = 0; k <= 255; k++) {
    catcode(k) = otherchar;
    mathcode(k) = k;
    sfcode(k) = 1000;
  }
  catcode(carriagereturn) = carret;
  catcode(' ') = spacer;
  catcode('\\') = escape;
  catcode('%') = comment;
  catcode(invalidcode) = invalidchar;
  catcode(nullcode) = ignore;
  for (k = '0'; k <= '9'; k++)
    mathcode(k) = k + varcode;
  for (k = 'A'; k <= 'Z'; k++) {   /*:232*/
    catcode(k) = letter;
    catcode(k + 'a' - 'A') = letter;
    mathcode(k) = k + varcode + 256;
    mathcode(k + 'a' - 'A') =
      k + 'a' - 'A' + varcode + 256;
    lccode(k) = k + 'a' - 'A';
    lccode(k + 'a' - 'A') = k + 'a' - 'A';
    uccode(k) = k;
    uccode(k + 'a' - 'A') = k;
    sfcode(k) = 999;
  }
  /*240:*/
  for (k = intbase; k < delcodebase; k++)
    eqtb[k - activebase].int_ = 0;
  mag = 1000;
  tolerance = 10000;
  hangafter = 1;
  maxdeadcycles = 25;
  escapechar = '\\';
  endlinechar = carriagereturn;
  for (k = 0; k <= 255; k++)
    delcode(k) = -1;
  delcode('.') = 0;   /*:240*/
  /*250:*/
  for (k = dimenbase; k <= eqtbsize; k++)   /*:250*/
    eqtb[k - activebase].sc = 0;
  /*258:*/
  hashused = frozencontrolsequence;
  cscount = 0;
  eqtype(frozendontexpand) = dontexpand;
  text(frozendontexpand) = S("notexpanded:");   /*:258*/
  fonts_init();
  /*946:*/
  for (k = -trieopsize; k <= trieopsize; k++)
    trieophash[k + trieopsize] = 0;
  for (k = 0; k <= 255; k++)
    trieused[k] = minquarterword;
  trieopptr = 0;   /*:946*/
  /*951:*/
  trienotready = true;
  trieroot = 0;
  triec[0] = 0;
  trieptr = 0;   /*:951*/
  /*1216:*/
  text(frozenprotection) = S("inaccessible");   /*:1216*/
  /*1301:*/
  formatident = S(" (INITEX)");   /*:1301*/
  /*1369:*/
  text(endwrite) = S("endwrite");
  eqlevel(endwrite) = levelone;
  eqtype(endwrite) = outercall;
  equiv(endwrite) = 0;   /*:1369*/
  /*:8*/
}


/*57:*/
void println(void)
{
  switch (selector) {

  case termandlog:
    putc('\n', termout);
    putc('\n', logfile);
    termoffset = 0;
    fileoffset = 0;
    break;

  case logonly:
    putc('\n', logfile);
    fileoffset = 0;
    break;

  case termonly:
    putc('\n', termout);
    termoffset = 0;
    break;

  case noprint:
  case pseudo:
  case newstring:
    /* blank case */
    break;

  default:
    putc('\n', writefile[selector]);
    break;
  }
}


/*:57*/
/*58:*/
void printchar(ASCIIcode s)
{
  /*244:*/
  if (s == newlinechar) {   /*:244*/
    if (selector < pseudo) {
      println();
      goto _Lexit;
    }
  }
  switch (selector) {

  case termandlog:
    fwrite(&xchr[s], 1, 1, termout);
    fwrite(&xchr[s], 1, 1, logfile);
    termoffset++;
    fileoffset++;
    if (termoffset == maxprintline) {
      putc('\n', termout);
      termoffset = 0;
    }
    if (fileoffset == maxprintline) {
      putc('\n', logfile);
      fileoffset = 0;
    }
    break;

  case logonly:
    fwrite(&xchr[s], 1, 1, logfile);
    fileoffset++;
    if (fileoffset == maxprintline)
      println();
    break;

  case termonly:
    fwrite(&xchr[s], 1, 1, termout);
    termoffset++;
    if (termoffset == maxprintline)
      println();
    break;

  case noprint:
    /* blank case */
    break;

  case pseudo:
    if (tally < trickcount) {
      trickbuf[tally % errorline] = s;
    }
    break;

  case newstring:
#if 0
    if (poolptr < poolsize) {
      appendchar(s);
    }
#else
	string_print_proc(s);
/*
	str_appendchar(s);
*/
#endif
    break;

  default:
    fwrite(&xchr[s], 1, 1, writefile[selector]);
    break;
  }
  tally++;
_Lexit: ;
}


/*:58*/
/*59:*/
void print(strnumber s)
{
  long nl;

   if (s < 256) {
    if (s >= 0) {
      if (selector > pseudo) {
	printchar(s);
	goto _Lexit;
      }
      if (s == newlinechar) {   /*244:*/
	if (selector < pseudo) {
	  println();
	  goto _Lexit;
	}
      }
      /*:244*/
      nl = newlinechar;
      newlinechar = -1;
        str_print(s);
      newlinechar = nl;
      goto _Lexit;
    }
    s = S("???");
  }
	str_print(s);
_Lexit: ;
}
/*:59*/


/*62:*/
void printnl(strnumber s)
{
  if ( (termoffset > 0 && (selector & 1)) ||
      (fileoffset > 0 && selector >= logonly))
    println();
  print(s);
}


/*:62*/
/*63:*/
void printesc(strnumber s)
{  /*243:*/
  long c;

  c = escapechar;   /*:243*/
  if (c >= 0) {
    if (c < 256)
      print(c);
  }
  slowprint(s);
}


/*:63*/
/*64:*/
Static void printthedigs(eightbits k, char * dig)
{
  while (k > 0) {
    k--;
    if (dig[k] < 10)
      printchar('0' + dig[k]);
    else
      printchar('A' + dig[k] - 10);
  }
}


/*:64*/
/*65:*/
void printint(long n)
{
  int k;
  long m;
  char dig[23];

  k = 0;
  if (n < 0) {
    printchar('-');
    if (n > -100000000L)
      n = -n;
    else {
      m = -n - 1;
      n = m / 10;
      m = m % 10 + 1;
      k = 1;
      if (m < 10)
	dig[0] = m;
      else {
	dig[0] = 0;
	n++;
      }
    }
  }
  do {
    dig[k] = n % 10;
    n /= 10;
    k++;
  } while (n != 0);
  printthedigs(k,dig);
}


/*:65*/
/*262:*/
Static void printcs(long p)
{
  if (p < hashbase) {
    if (p >= singlebase) {
      if (p == nullcs) {
	printesc(S("csname"));
	printesc(S("endcsname"));
	return;
      }
      printesc(p - singlebase);
      if (catcode(p - singlebase) == letter)
	printchar(' ');
      return;
    }
    if (p < activebase)
      printesc(S("IMPOSSIBLE."));
    else
      print(p - activebase);
    return;
  }
  if (p >= undefinedcontrolsequence) {
    printesc(S("IMPOSSIBLE."));
    return;
  }
  if ( !str_valid(text(p)))
    printesc(S("NONEXISTENT."));
  else {
    printesc(text(p));
    printchar(' ');
  }
}


/*:262*/
/*263:*/
void sprintcs(halfword p)
{
  if (p >= hashbase) {
    printesc(text(p));
    return;
  }
  if (p < singlebase) {
    print(p - activebase);
    return;
  }
  if (p < nullcs)
    printesc(p - singlebase);
  else {
    printesc(S("csname"));
    printesc(S("endcsname"));
  }
}  /*:263*/


/*518:*/
void printfilename(strnumber n, strnumber a, strnumber e)
{
  slowprint(a);
  slowprint(n);
  slowprint(e);
}


/*:518*/
/*699:*/
void printsize(long s)
{
  if (s == 0) {
    printesc(S("textfont"));
    return;
  }
  if (s == scriptsize)
    printesc(S("scriptfont"));
  else
    printesc(S("scriptscriptfont"));
}  /*:699*/


/*1355:*/
Static void printwritewhatsit(strnumber s, halfword p)
{
  printesc(s);
  if (writestream(p) < 16) {
    printint(writestream(p));
    return;
  }
  if (writestream(p) == 16)
    printchar('*');
  else
    printchar('-');
}


/*:1355*/
/*78:*/
Static void normalizeselector(void);

Static void gettoken(void);

Static void terminput(void);

Static void showcontext(void);

Static void beginfilereading(void);

Static void openlogfile(void);

Static void closefilesandterminate(void);

Static void clearforerrorprompt(void);

Static void giveerrhelp(void);

/*_DEBUG*/
Static void debughelp(void);

Static jmp_buf _JLendofTEX;


/*_ENDDEBUG*/
/*:78*/
/*81:*/
Static void jumpout(void)
{
  longjmp(_JLendofTEX, 1);
}


/*:81*/
/*82:*/
void error(void)
{
  ASCIIcode c;
  long s1, s2, s3, s4;

  if (history < errormessageissued)
    history = errormessageissued;
  printchar('.');
  showcontext();
  if (interaction == errorstopmode) {   /*83:*/
    while (true) {   /*:83*/
_Llabcontinue:
      clearforerrorprompt();
      print(S("? "));
      terminput();
      if (last == first)
	goto _Lexit;
      c = buffer[first];
      if (c >= 'a')   /*84:*/
	c += 'A' - 'a';
      switch (c) {

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':   /*_DEBUG*/
	if (deletionsallowed) {   /*88:*/
	  s1 = curtok;
	  s2 = curcmd;
	  s3 = curchr;
	  s4 = alignstate;
	  alignstate = 1000000L;
	  OKtointerrupt = false;
	  if ((last > first + 1) & (buffer[first + 1] >= '0') &
	      (buffer[first + 1] <= '9'))
	    c = c * 10 + buffer[first + 1] - '0' * 11;
	  else
	    c -= '0';
	  while (c > 0) {
	    gettoken();
	    c--;
	  }
	  curtok = s1;
	  curcmd = s2;
	  curchr = s3;
	  alignstate = s4;
	  OKtointerrupt = true;
	  help2(S("I have just deleted some text, as you asked."),S("You can now delete more, or insert, or whatever."));
	  showcontext();
	  goto _Llabcontinue;
	}
	/*:88*/
	break;

      case 'D':
	debughelp();
	goto _Llabcontinue;
	break;
	/*_ENDDEBUG*/

      case 'E':
	if (baseptr > 0) {
	  printnl(S("You want to edit file "));
	  slowprint(inputstack[baseptr].namefield);
	  print(S(" at line "));
	  printint(line);
	  interaction = scrollmode;
	  jumpout();
	}
	break;

      case 'H':   /*89:*/
	if (useerrhelp) {
	  giveerrhelp();
	  useerrhelp = false;
	} else {
	  if (helpptr == 0) {
	    help2(S("Sorry, I don't know how to help in this situation."),S("Maybe you should try asking a human?"));
	  }
	  do {
	    helpptr--;
	    print(helpline[helpptr]);
	    println();
	  } while (helpptr != 0);
	}
	help4(S("Sorry, I already gave what help I could..."),S("Maybe you should try asking a human?"),S("An error might have occurred before I noticed any problems."),S("``If all else fails, read the instructions.''"));
	goto _Llabcontinue;
	break;
	/*:89*/

      case 'I':   /*87:*/
	beginfilereading();
	if (last > first + 1) {
	  loc = first + 1;
	  buffer[first] = ' ';
	} else {
	  print(S("insert>"));
	  terminput();
	  loc = first;
	}
	first = last;
	curinput.limitfield = last - 1;
	goto _Lexit;
	break;
	/*:87*/

      case 'Q':
      case 'R':
      case 'S':   /*86:*/
	errorcount = 0;
	interaction = batchmode + c - 'Q';
	print(S("OK, entering "));
	switch (c) {

	case 'Q':
	  printesc(S("batchmode"));
	  selector--;
	  break;

	case 'R':
	  printesc(S("nonstopmode"));
	  break;

	case 'S':
	  printesc(S("scrollmode"));
	  break;
	}
	print(S("..."));
	println();
	fflush(termout);
	goto _Lexit;
	break;
	/*:86*/

      case 'X':
	interaction = scrollmode;
	jumpout();
	break;
      }/*85:*/
      print(S("Type <return> to proceed, S to scroll future error messages,"));
      printnl(S("R to run without stopping, Q to run quietly,"));
      printnl(S("I to insert something, "));
      if (baseptr > 0)
	print(S("E to edit your file,"));
      if (deletionsallowed)
	printnl(S("1 or ... or 9 to ignore the next 1 to 9 tokens of input,"));
      printnl(S("H for help, X to quit."));   /*:85*/
      /*:84*/
    }
  }
  errorcount++;
  if (errorcount == 100) {
    printnl(S("(That makes 100 errors; please try again.)"));
    history = fatalerrorstop;
    jumpout();
  }  /*90:*/
  if (interaction > batchmode)
    selector--;
  if (useerrhelp) {
    println();
    giveerrhelp();
  } else {
    while (helpptr > 0) {
      helpptr--;
      printnl(helpline[helpptr]);
    }
  }
  println();
  if (interaction > batchmode)   /*:90*/
    selector++;
  println();
_Lexit: ;
}


/*:82*/
/*93:*/
Static void fatalerror(strnumber s)
{
  normalizeselector();
  printnl(S("! "));
  print(S("Emergency stop"));
  helpptr = 1;
  helpline[0] = s;
  if (interaction == errorstopmode)
    interaction = scrollmode;
  if (logopened)   /*_DEBUG*/
    error();
  if (interaction > batchmode)
    debughelp();
  /*_ENDDEBUG*/
  history = fatalerrorstop;
  jumpout();
}


/*:93*/
/*94:*/
void overflow(strnumber s, long n)
{
  normalizeselector();
  printnl(S("! "));
  print(S("TeX capacity exceeded, sorry ["));
  print(s);
  printchar('=');
  printint(n);
  printchar(']');
  help2(S("If you really absolutely need more capacity,"),S("you can ask a wizard to enlarge me."));
  if (interaction == errorstopmode)
    interaction = scrollmode;
  if (logopened)   /*_DEBUG*/
    error();
  if (interaction > batchmode)
    debughelp();
  /*_ENDDEBUG*/
  history = fatalerrorstop;
  jumpout();
}


/*:94*/
/*95:*/
Static void confusion(strnumber s)
{
  normalizeselector();
  if (history < errormessageissued) {
    printnl(S("! "));
    print(S("This can't happen ("));
    print(s);
    printchar(')');
    help1(S("I'm broken. Please show this to someone who can fix can fix"));
  } else {
    printnl(S("! "));
    print(S("I can't go on meeting you like this"));
    help2(S("One of your faux pas seems to have wounded me deeply..."),S("in fact, I'm barely conscious. Please fix it and try again."));
  }
  if (interaction == errorstopmode)
    interaction = scrollmode;
  if (logopened)   /*_DEBUG*/
    error();
  if (interaction > batchmode)
    debughelp();
  /*_ENDDEBUG*/
  history = fatalerrorstop;
  jumpout();
}


/*:95*/
/*:4*/
/*27:*/

/*:27*/
/*28:*/
Static void aclose(FILE **f)
{
  if (*f != NULL)
    fclose(*f);
  *f = NULL;
}


void bclose(FILE **f)
{
  if (*f != NULL)
    fclose(*f);
  *f = NULL;
}


Static void wclose(FILE **f)
{
  if (*f != NULL)
    fclose(*f);
  *f = NULL;
}




/*:28*/
/*31:*/
/*:31*/
/*37:*/
Static boolean initterminal(void)
{
  topenin();
  if (initinc(1)) {
    loc = first;
    return true;
  }
  while (true) {
    fprintf(termout, "**");
    fflush(termout);
    if (!inputln(&termin, true)) {
      putc('\n', termout);
      fprintf(termout,"! End of file on the terminal... why?");
      return false;
    }
    loc = first;
    while ((loc < last) & (buffer[loc] == ' '))
      loc++;
    if (loc < last) {
      return true;
    }
    fprintf(termout, "Please type the name of your input file.\n");
  }
}


/*:37*/

/*47:*/
/*:47*/
/*66:*/
Static void printtwo(long n)
{
  n = labs(n) % 100;
  printchar('0' + n / 10);
  printchar('0' + n % 10);
}


/*:66*/
/*67:*/
void printhex(long n)
{
  int k;
  char digs[23];

  k = 0;
  printchar('"');
  do {
    digs[k] = n & 15;
    n /= 16;
    k++;
  } while (n != 0);
  printthedigs(k,digs);
}


/*:67*/
/*69:*/
Static void printromanint(long n)
{
  int j, k;
  nonnegativeinteger u, v;
  static char romstr[]="m2d5c2l5x2v5i";

  j = 0 ; 
  v = 1000;
  while (true) {
    while (n >= v) {
      printchar(romstr[j]);
      n -= v;
    }
    if (n <= 0)
      goto _Lexit;
    k = j + 2;
    u = v / (romstr[k - 1] - '0');
    if (romstr[k - 1] == '2') {
      k += 2;
      u /= romstr[k - 1] - '0';
    }
    if (n + u >= v) {
      printchar(romstr[k]);
      n += u;
    } else {
      j += 2;
      v /= romstr[j - 1] - '0';
    }
  }
_Lexit: ;
}
/*:69*/


/*71:*/
Static void terminput(void)
{
  short k;

  fflush(termout);
  if (!inputln(&termin, true))
    fatalerror(S("End of file on the terminal!"));
  termoffset = 0;
  selector--;
  if (last != first) {
    for (k = first; k < last; k++)
      print(buffer[k]);
  }
  println();
  selector++;
}


/*:71*/
/*91:*/
Static void interror(long n)
{
  print(S(" ("));
  printint(n);
  printchar(')');
  error();
}


/*:91*/
/*92:*/
Static void normalizeselector(void)
{
  if (logopened)
    selector = termandlog;
  else
    selector = termonly;
  if (jobname == 0)
    openlogfile();
  if (interaction == batchmode)
    selector--;
}


/*:92*/
/*98:*/
Static void pauseforinstructions(void)
{
  if (!OKtointerrupt)
    return;
  interaction = errorstopmode;
  if (selector == logonly || selector == noprint)
    selector++;
  printnl(S("! "));
  print(S("Interruption"));
  help3(S("You rang?"),S("Try to insert some instructions for me (e.g.,`I\\showlists'),"),S("unless you just want to quit by typing `X'."));
  deletionsallowed = false;
  error();
  deletionsallowed = true;
  interrupt = 0;
}


/*:98*/
/*100:*/
Static long half(long x)
{
  if (x & 1)
    return ((x + 1) / 2);
  else
    return (x / 2);
}


/*:100*/
/*102:*/
Static long rounddecimals(int k, char * digs )
{
  long a;

  a = 0;
  while (k > 0) {
    k--;
    a = (a + digs[k] * two) / 10;
  }
  return ((a + 1) / 2);
}


/*:102*/
/*103:*/
void printscaled(long s)
{
  scaled delta;

  if (s < 0) {
    printchar('-');
    s = -s;
  }
  printint(s / unity);
  printchar('.');
  s = (s & (unity - 1)) * 10 + 5;
  delta = 10;
  do {
    if (delta > unity)
      s -= 17232;
    printchar('0' + s / unity);
    s = (s & (unity - 1)) * 10;
    delta *= 10;
  } while (s > delta);
}


/*:103*/
/*105:*/
Static long multandadd(long n, long x, long y, long maxanswer)
{
  if (n < 0) {
    x = -x;
    n = -n;
  }
  if (n == 0)
    return y;
  else if (x <= (maxanswer - y) / n && -x <= (maxanswer + y) / n)
    return (n * x + y);
  else {
    aritherror = true;
    return 0;
  }
}


/*:105*/
/*106:*/
Static long xovern(long x, long n)
{
  long Result;
  boolean negative;

  negative = false;
  if (n == 0) {
    aritherror = true;
    Result = 0;
    texremainder = x;
  } else {
    if (n < 0) {
      x = -x;
      n = -n;
      negative = true;
    }
    if (x >= 0) {
      Result = x / n;
      texremainder = x % n;
    } else {
      Result = -(-x / n);
      texremainder = -(-x % n);
    }
  }
  if (negative)
    texremainder = -texremainder;
  return Result;
}


/*:106*/
/*107:*/
long xnoverd(long x, long n, long d)
{
  long Result;
  boolean positive;
  nonnegativeinteger t, u, v;

  if (x >= 0)
    positive = true;
  else {
    x = -x;
    positive = false;
  }
  t = x % 32768L * n;
  u = x / 32768L * n + t / 32768L;
  v = u % d * 32768L + t % 32768L;
  if (u / d >= 32768L)
    aritherror = true;
  else
    u = u / d * 32768L + v / d;
  if (positive) {
    Result = u;
    texremainder = v % d;
  } else {
    Result = -u;
    texremainder = -(v % d);
  }
  return Result;
}


/*:107*/
/*108:*/
Static halfword badness(long t, long s)
{
  long r;

  if (t == 0)
    return 0;
  else if (s <= 0)
    return infbad;
  else {
    if (t <= 7230584L)
      r = t * 297 / s;
    else if (s >= 1663497L)
      r = t / (s / 297);
    else
      r = t;
    if (r > 1290)
      return infbad;
    else
      return ((r * r * r + 131072L) / 262144L);
  }
}


/*:108*/
/*114:*/
/*_DEBUG*/
Static void printword(memoryword w)
{
  printint(w.int_);
  printchar(' ');
  printscaled(w.sc);
  printchar(' ');
  printscaled((long)floor(unity * w.gr + 0.5));
  println();
  printint(w.hh.UU.lh);
  printchar('=');
  printint(w.hh.UU.U2.b0);
  printchar(':');
  printint(w.hh.UU.U2.b1);
  printchar(';');
  printint(w.hh.rh);
  printchar(' ');
  printint(w.qqqq.b0);
  printchar(':');
  printint(w.qqqq.b1);
  printchar(':');
  printint(w.qqqq.b2);
  printchar(':');
  printint(w.qqqq.b3);
}


/*_ENDDEBUG*/
/*:114*/
/*119:*/
/*292:*/
Static void showtokenlist(long p, long q, long l)
{
  long m, c;
  ASCIIcode matchchr, n;

  matchchr = '#';
  n = '0';
  tally = 0;
  while (p != 0 && tally < l) {
    if (p == q) {   /*320:*/
      settrickcount();
    }
    /*:320*/
    /*293:*/
    if (p < himemmin || p > memend) {
      printesc(S("CLOBBERED."));
      goto _Lexit;
    }
    if (info(p) >= cstokenflag)
      printcs(info(p) - cstokenflag);
    else {   /*:293*/
      m = info(p) / dwa_do_8;
      c = (info(p)) & (dwa_do_8-1);
      if (info(p) < 0)
	printesc(S("BAD."));
      else {  /*294:*/
	switch (m) {   /*:294*/

	case leftbrace:
	case rightbrace:
	case mathshift:
	case tabmark:
	case supmark:
	case submark:
	case spacer:
	case letter:
	case otherchar:
	  print(c);
	  break;

	case macparam:
	  print(c);
	  print(c);
	  break;

	case outparam:
	  print(matchchr);
	  if (c > 9) {
	    printchar('!');
	    goto _Lexit;
	  }
	  printchar(c + '0');
	  break;

	case match:
	  matchchr = c;
	  print(c);
	  n++;
	  printchar(n);
	  if (n > '9')
	    goto _Lexit;
	  break;

	case endmatch:
	  print(S("->"));
	  break;

	default:
	  printesc(S("BAD."));
	  break;
	}
      }
    }
    p = link(p);
  }
  if (p != 0)
    printesc(S("ETC."));
_Lexit: ;
}


/*:292*/
/*306:*/
Static void runaway(void)
{
  pointer p=0 /* XXXX */;

  if (scannerstatus <= skipping)
    return;
  printnl(S("Runaway "));
  switch (scannerstatus) {

  case defining:
    print(S("definition"));
    p = defref;
    break;

  case matching:
    print(S("argument"));
    p = temphead;
    break;

  case aligning:
    print(S("preamble"));
    p = holdhead;
    break;

  case absorbing:
    print(S("text"));
    p = defref;
    break;
  }
  printchar('?');
  println();
  showtokenlist(link(p), 0, errorline - 10);
}


/*:306*/
/*:119*/
/*120:*/
Static pointer getavail(void)
{
  pointer p;

  p = avail;
  if (p != 0)
    avail = link(avail);
  else if (memend < memmax) {
    memend++;
    p = memend;
  } else {
    himemmin--;
    p = himemmin;
    if (himemmin <= lomemmax) {
      runaway();
      overflow(S("main memory size"), memmax - memmin + 1);
    }
  }
  set_as_char_node(p);
  link(p) = 0;
  /*_STAT*/
  dynused++;
  /*_ENDSTAT*/
  return p;
}


/*:120*/
/*123:*/
Static void flushlist(halfword p)
{
  pointer q, r;

  if (p == 0)
    return;
  r = p;
  do {
    q = r;
    r = link(r);   /*_STAT*/
    dynused--;   /*_ENDSTAT*/
  } while (r != 0);
  link(q) = avail;
  avail = p;
}


/*:123*/
/*125:*/
Static halfword getnode(long s)
{
  halfword Result;
  pointer p, q;
  long r, t;

_Lrestart:
  p = rover;
  do {   /*127:*/
    q = p + nodesize(p);
    while (isempty(q)) {
      t = rlink(q);
      if (q == rover)
	rover = t;
      llink(t) = llink(q);
      rlink(llink(q)) = t;
      q += nodesize(q);
    }
    r = q - s;
    if (r > p + 1) {   /*128:*/
      nodesize(p) = r - p;
      rover = p;
      goto _Lfound;
    }
    /*:128*/
    if (r == p) {
      if (rlink(p) != p) {   /*129:*/
	rover = rlink(p);
	t = llink(p);
	llink(rover) = t;
	rlink(t) = rover;
	goto _Lfound;
      }
      /*:129*/
    }
    nodesize(p) = q - p;   /*:127*/
    p = rlink(p);
  } while (p != rover);
  if (s == 1073741824L) {
    Result = maxhalfword;
    goto _Lexit;
  }
  if (lomemmax + 2 < himemmin) {
    if (lomemmax + 2 <= membot + maxhalfword) {   /*126:*/
      if (himemmin - lomemmax >= 1998)
	t = lomemmax + 1000;
      else
	t = lomemmax + (himemmin - lomemmax) / 2 + 1;
      p = llink(rover);
      q = lomemmax;
      rlink(p) = q;
      llink(rover) = q;
      if (t > membot + maxhalfword)
	t = membot + maxhalfword;
      rlink(q) = rover;
      llink(q) = p;
      link(q) = emptyflag;
      nodesize(q) = t - lomemmax;
      lomemmax = t;
      link(lomemmax) = 0;
      info(lomemmax) = 0;
      rover = q;
      goto _Lrestart;
    }
    /*:126*/
  }
  overflow(S("main memory size"), memmax - memmin + 1);
_Lfound:
  unset_is_char_node(r);
  link(r) = 0;   /*_STAT*/
  varused += s;   /*_ENDSTAT*/
  Result = r;
_Lexit:
  return Result;
}


/*:125*/
/*130:*/
Static void freenode(halfword p, halfword s)
{
  pointer q;

  nodesize(p) = s;
  link(p) = emptyflag;
  q = llink(rover);
  llink(p) = q;
  rlink(p) = rover;
  llink(rover) = p;
  rlink(q) = p;   /*_STAT*/
  varused -= s;   /*_ENDSTAT*/
}


/*:130*/
/*131:*/
Static void sortavail(void)
{
  pointer p, q, r, oldrover;

  p = getnode(1073741824L);
  p = rlink(rover);
  rlink(rover) = maxhalfword;
  oldrover = rover;
  while (p != oldrover) {   /*132:*/
    if (p < rover) {
      q = p;
      p = rlink(q);
      rlink(q) = rover;
      rover = q;
      continue;
    }
    q = rover;
    while (rlink(q) < p)
      q = rlink(q);
    r = rlink(p);
    rlink(p) = rlink(q);
    rlink(q) = p;
    p = r;
  }
  p = rover;
  while (rlink(p) != maxhalfword) {
    llink(rlink(p)) = p;
    p = rlink(p);
  }
  rlink(p) = rover;
  llink(rover) = p;

  /*:132*/
}  /*:131*/


/*136:*/
Static pointer newnullbox(void)
{
  pointer p;

  p = getnode(boxnodesize);
  type(p) = hlistnode;
  subtype(p) = minquarterword;
  width(p) = 0;
  depth(p) = 0;
  height(p) = 0;
  shiftamount(p) = 0;
  listptr(p) = 0;
  gluesign(p) = normal;
  glueorder(p) = normal;
  glueset(p) = 0.0;
  return p;
}


/*:136*/
/*139:*/
Static pointer newrule(void)
{
  pointer p;

  p = getnode(rulenodesize);
  type(p) = rulenode;
  subtype(p) = 0;
  width(p) = nullflag;
  depth(p) = nullflag;
  height(p) = nullflag;
  return p;
}


/*:139*/
/*144:*/
Static pointer newligature(quarterword f, quarterword c, halfword q)
{
  pointer p;

  p = getnode(smallnodesize);
  type(p) = ligaturenode;
  font(ligchar(p)) = f;
  character(ligchar(p)) = c;
  ligptr(p) = q;
  subtype(p) = 0;
  return p;
}


Static pointer newligitem(quarterword c)
{
  pointer p;

  p = getnode(smallnodesize);
  character(p) = c;
  ligptr(p) = 0;
  return p;
}


/*:144*/
/*145:*/
Static pointer newdisc(void)
{
  pointer p;

  p = getnode(smallnodesize);
  type(p) = discnode;
  replacecount(p) = 0;
  prebreak(p) = 0;
  postbreak(p) = 0;
  return p;
}


/*:145*/
/*147:*/
Static pointer newmath(long w, smallnumber s)
{
  pointer p;

  p = getnode(smallnodesize);
  type(p) = mathnode;
  subtype(p) = s;
  width(p) = w;
  return p;
}


/*:147*/
/*151:*/
Static pointer newspec(halfword p)
{
  pointer q;

  q = getnode(gluespecsize);
  mem[q - memmin] = mem[p - memmin];
  gluerefcount(q) = 0;
  width(q) = width(p);
  stretch(q) = stretch(p);
  shrink(q) = shrink(p);
  return q;
}


/*:151*/
/*152:*/
Static pointer newparamglue(smallnumber n)
{
  pointer p, q;

  p = getnode(smallnodesize);
  type(p) = gluenode;
  subtype(p) = n + 1;
  leaderptr(p) = 0;
  q = gluepar(n);   /*224:*/
  /*:224*/
  glueptr(p) = q;
  (gluerefcount(q))++;
  return p;
}


/*:152*/
/*153:*/
Static pointer newglue(halfword q)
{
  pointer p;

  p = getnode(smallnodesize);
  type(p) = gluenode;
  subtype(p) = normal;
  leaderptr(p) = 0;
  glueptr(p) = q;
  (gluerefcount(q))++;
  return p;
}


/*:153*/
/*154:*/
Static pointer newskipparam(smallnumber n)
{
  pointer p;

  tempptr = newspec(gluepar(n));   /*224:*/
  /*:224*/
  p = newglue(tempptr);
  gluerefcount(tempptr) = 0;
  subtype(p) = n + 1;
  return p;
}


/*:154*/
/*156:*/
Static pointer newkern(long w)
{
  pointer p;

  p = getnode(smallnodesize);
  type(p) = kernnode;
  subtype(p) = normal;
  width(p) = w;
  return p;
}


/*:156*/
/*158:*/
Static pointer newpenalty(long m)
{
  pointer p;

  p = getnode(smallnodesize);
  type(p) = penaltynode;
  subtype(p) = 0;
  penalty(p) = m;
  return p;
}


/*:158*/
/*167:*/
/*_DEBUG*/
Static void checkmem(boolean printlocs)
{
  pointer p, q;
  boolean clobbered;
  halfword FORLIM;

  for (p = memmin; p <= lomemmax; p++)
    P_clrbits_B(free_, p - memmin, 0, 3);
  for (p = himemmin; p <= memend; p++)   /*168:*/
    P_clrbits_B(free_, p - memmin, 0, 3);
  p = avail;
  q = 0;
  clobbered = false;
  while (p != 0) {
    if (p > memend || p < himemmin)
      clobbered = true;
    else {
      if (P_getbits_UB(free_, p - memmin, 0, 3))
	clobbered = true;
    }
    if (clobbered) {
      printnl(S("AVAIL list clobbered at "));
      printint(q);
      goto _Ldone1;
    }
    P_putbits_UB(free_, p - memmin, 1, 0, 3);
    q = p;
    p = link(q);
  }
_Ldone1:   /*:168*/
  /*169:*/
  p = rover;
  q = 0;
  clobbered = false;
  do {
    if (p >= lomemmax || p < memmin)
      clobbered = true;
    else if ((rlink(p) >= lomemmax) | (rlink(p) < memmin))
      clobbered = true;
    else if ((!isempty(p)) | (nodesize(p) < 2) | (p + nodesize(p) >
	       lomemmax) | (llink(rlink(p)) != p)) {
      clobbered = true;
    }
    if (clobbered) {
      printnl(S("Double-AVAIL list clobbered at "));
      printint(q);
      goto _Ldone2;
    }
    FORLIM = p + nodesize(p);
    for (q = p; q < FORLIM; q++) {
      if (P_getbits_UB(free_, q - memmin, 0, 3)) {
	printnl(S("Doubly free location at "));
	printint(q);
	goto _Ldone2;
      }
      P_putbits_UB(free_, q - memmin, 1, 0, 3);
    }
    q = p;
    p = rlink(p);
  } while (p != rover);
_Ldone2:   /*:169*/
  /*170:*/
  p = memmin;
  while (p <= lomemmax) {   /*:170*/
    if (isempty(p)) {
      printnl(S("Bad flag at "));
      printint(p);
    }
    while ((p <= lomemmax) & (!P_getbits_UB(free_, p - memmin, 0, 3)))
      p++;
    while ((p <= lomemmax) & P_getbits_UB(free_, p - memmin, 0, 3))
      p++;
  }
  if (printlocs) {   /*171:*/
    printnl(S("New busy locs:"));
    FORLIM = lomemmax;
    for (p = memmin; p <= lomemmax; p++) {
      if ((!P_getbits_UB(free_, p - memmin, 0, 3)) &
	  ((p > waslomax) | P_getbits_UB(wasfree, p - memmin, 0, 3))) {
	printchar(' ');
	printint(p);
      }
    }
    for (p = himemmin; p <= memend ; p++) {
      if ((!P_getbits_UB(free_, p - memmin, 0, 3)) & ((p < washimin ||
	      p > wasmemend) | P_getbits_UB(wasfree, p - memmin, 0, 3))) {
	printchar(' ');
	printint(p);
      }
    }
  }
  /*:171*/
  for (p = memmin; p <= lomemmax; p++) {
    P_clrbits_B(wasfree, p - memmin, 0, 3);
    P_putbits_UB(wasfree, p - memmin, P_getbits_UB(free_, p - memmin, 0, 3),
		 0, 3);
  }
  for (p = himemmin; p <= memend; p++) {
    P_clrbits_B(wasfree, p - memmin, 0, 3);
    P_putbits_UB(wasfree, p - memmin, P_getbits_UB(free_, p - memmin, 0, 3),
		 0, 3);
  }
  wasmemend = memend;
  waslomax = lomemmax;
  washimin = himemmin;
}
/*:167*/

/*172:*/
Static void searchmem(halfword p)
{
  long q;

  for (q = memmin; q <= lomemmax; q++) {
    if (link(q) == p) {
      printnl(S("LINK("));
      printint(q);
      printchar(')');
    }
    if (info(q) == p) {
      printnl(S("INFO("));
      printint(q);
      printchar(')');
    }
  }
  for (q = himemmin; q <= memend; q++) {
    if (link(q) == p) {
      printnl(S("LINK("));
      printint(q);
      printchar(')');
    }
    if (info(q) == p) {
      printnl(S("INFO("));
      printint(q);
      printchar(')');
    }
  }  /*255:*/
  for (q = activebase; q <= boxbase + 255; q++) {   /*:255*/
    if (equiv(q) == p) {
      printnl(S("EQUIV("));
      printint(q);
      printchar(')');
    }
  }
  /*285:*/
  if (saveptr > 0) {   /*933:*/
    for (q = 0; q < saveptr; q++) {   /*:285*/
      if (equivfield(savestack[q]) == p) {
	printnl(S("SAVE("));
	printint(q);
	printchar(')');
      }
    }
  }
  for (q = 0; q <= hyphsize; q++) {   /*:933*/
    if (hyphlist[q] == p) {
      printnl(S("HYPH("));
      printint(q);
      printchar(')');
    }
  }
}
/*_ENDDEBUG*/
/*:172*/

/*174:*/
Static void shortdisplay(long p)
{
  long n;

  while (p > memmin) {
    if (ischarnode(p)) {
      if (p <= memend) {
	if (font(p) != fontinshortdisplay) {
	  if ( /* (font(p) < 0 ) | */ (font(p) > fontmax))
	    printchar('*');
	  else  /*267:*/
		/*:267*/
		  printesc(fontidtext(font(p)));
	  printchar(' ');
	  fontinshortdisplay = font(p);
	}
	print(character(p) - minquarterword);
      }
    } else {  /*175:*/
      switch (type(p)) {   /*:175*/

      case hlistnode:
      case vlistnode:
      case insnode:
      case whatsitnode:
      case marknode:
      case adjustnode:
      case unsetnode:
	print(S("[]"));
	break;

      case rulenode:
	printchar('|');
	break;

      case gluenode:
	if (glueptr(p) != zeroglue)
	  printchar(' ');
	break;

      case mathnode:
	printchar('$');
	break;

      case ligaturenode:
	shortdisplay(ligptr(p));
	break;

      case discnode:
	shortdisplay(prebreak(p));
	shortdisplay(postbreak(p));
	n = replacecount(p);
	while (n > 0) {
	  if (link(p) != 0)
	    p = link(p);
	  n--;
	}
	break;
      }
    }
    p = link(p);
  }
}


/*:174*/
/*176:*/
Static void printfontandchar(long p)
{
  if (p > memend) {
    printesc(S("CLOBBERED."));
    return;
  }
  if ((font(p) > fontmax))
    printchar('*');
  else  /*267:*/
	/*:267*/
	  printesc(fontidtext(font(p)));
  printchar(' ');
  print(character(p) - minquarterword);
}


Static void printmark(long p)
{
  printchar('{');
  if (p < himemmin || p > memend)
    printesc(S("CLOBBERED."));
  else
    showtokenlist(link(p), 0, maxprintline - 10);
  printchar('}');
}


Static void printruledimen(long d)
{
  if (isrunning(d)) {
    printchar('*');
  } else
    printscaled(d);
}


/*:176*/
/*177:*/
Static void printglue(long d, long order, strnumber s)
{
  printscaled(d);
  if ((unsigned long)order > filll) {
    print(S("foul"));
    return;
  }
  if (order <= normal) {
    if (s != 0)
      print(s);
    return;
  }
  print(S("fil"));
  while (order > fil) {
    printchar('l');
    order--;
  }
}


/*:177*/
/*178:*/
Static void printspec(long p, strnumber s)
{
  if ((unsigned long)p >= lomemmax) {
    printchar('*');
    return;
  }
  printscaled(width(p));
  if (s != 0)
    print(s);
  if (stretch(p) != 0) {
    print(S(" plus "));
    printglue(stretch(p), stretchorder(p), s);
  }
  if (shrink(p) != 0) {
    print(S(" minus "));
    printglue(shrink(p), shrinkorder(p), s);
  }
}


/*:178*/
/*179:*/
/*691:*/
Static void printfamandchar(halfword p)
{
  printesc(S("fam"));
  printint(fam(p));
  printchar(' ');
  print(character(p) - minquarterword);
}


Static void printdelimiter(halfword p)
{
  long a;

  a = smallfam(p) * 256 + smallchar(p) - minquarterword;
  a = a * 4096 + largefam(p) * 256 + largechar(p) - minquarterword;
  if (a < 0)
    printint(a);
  else
    printhex(a);
}


/*:691*/
/*692:*/
Static void showinfo(void);


Static void printsubsidiarydata(halfword p, ASCIIcode c)
{
  if (get_cur_length() >= depththreshold) {
    if (mathtype(p) != empty)
      print(S(" []"));
    return;
  }
  appendchar(c);
  tempptr = p;
  switch (mathtype(p)) {

  case mathchar:
    println();
    printcurrentstring();
    printfamandchar(p);
    break;

  case subbox:
    showinfo();
    break;

  case submlist:
    if (info(p) == 0) {
      println();
      printcurrentstring();
      print(S("{}"));
    } else
      showinfo();
    break;
  }
  flushchar();
}


/*:692*/
/*694:*/
void printstyle(long c)
{
  switch (c / 2) {

  case 0:
    printesc(S("displaystyle"));
    break;

  case 1:
    printesc(S("textstyle"));
    break;

  case 2:
    printesc(S("scriptstyle"));
    break;

  case 3:
    printesc(S("scriptscriptstyle"));
    break;

  default:
    print(S("Unknown style!"));
    break;
  }
}


/*:694*/
/*225:*/
void printskipparam(long n)
{
  switch (n) {

  case lineskipcode:
    printesc(S("lineskip"));
    break;

  case baselineskipcode:
    printesc(S("baselineskip"));
    break;

  case parskipcode:
    printesc(S("parskip"));
    break;

  case abovedisplayskipcode:
    printesc(S("abovedisplayskip"));
    break;

  case belowdisplayskipcode:
    printesc(S("belowdisplayskip"));
    break;

  case abovedisplayshortskipcode:
    printesc(S("abovedisplayshortskip"));
    break;

  case belowdisplayshortskipcode:
    printesc(S("belowdisplayshortskip"));
    break;

  case leftskipcode:
    printesc(S("leftskip"));
    break;

  case rightskipcode:
    printesc(S("rightskip"));
    break;

  case topskipcode:
    printesc(S("topskip"));
    break;

  case splittopskipcode:
    printesc(S("splittopskip"));
    break;

  case tabskipcode:
    printesc(S("tabskip"));
    break;

  case spaceskipcode:
    printesc(S("spaceskip"));
    break;

  case xspaceskipcode:
    printesc(S("xspaceskip"));
    break;

  case parfillskipcode:
    printesc(S("parfillskip"));
    break;

  case thinmuskipcode:
    printesc(S("thinmuskip"));
    break;

  case medmuskipcode:
    printesc(S("medmuskip"));
    break;

  case thickmuskipcode:
    printesc(S("thickmuskip"));
    break;

  default:
    print(S("[unknown glue parameter!]"));
    break;
  }
}


/*:225*/
/*:179*/
/*182:*/
Static void shownodelist(long p)
{
  long n;
  double g;

  if (get_cur_length() > depththreshold) {
    if (p > 0)
      print(S(" []"));
    goto _Lexit;
  }
  n = 0;
  while (p > memmin) {
    println();
    printcurrentstring();
    if (p > memend) {
      print(S("Bad link, display aborted."));
      goto _Lexit;
    }
    n++;
    if (n > breadthmax) {
      print(S("etc."));
      goto _Lexit;
    }  /*183:*/
    if (ischarnode(p))
      printfontandchar(p);
    else {
      switch (type(p)) {   /*:183*/

      case hlistnode:
      case vlistnode:
      case unsetnode:   /*184:*/
	if (type(p) == hlistnode)
	  printesc('h');
	else if (type(p) == vlistnode)
	  printesc('v');
	else
	  printesc(S("unset"));
	print(S("box("));
	printscaled(height(p));
	printchar('+');
	printscaled(depth(p));
	print(S(")x"));
	printscaled(width(p));
	if (type(p) == unsetnode) {   /*185:*/
	  if (spancount(p) != minquarterword) {
	    print(S(" ("));
	    printint(spancount(p) - minquarterword + 1);
	    print(S(" columns)"));
	  }
	  if (gluestretch(p) != 0) {
	    print(S(", stretch "));
	    printglue(gluestretch(p), glueorder(p), 0);
	  }
	  if (glueshrink(p) != 0) {
	    print(S(", shrink "));
	    printglue(glueshrink(p), gluesign(p), 0);
	  }
	}  /*:185*/
	else {   /*186:*/
	  g = glueset(p);
	  if ((g != 0.0) & (gluesign(p) != normal)) {   /*:186*/
	    print(S(", glue set "));
	    if (gluesign(p) == shrinking)
	      print(S("- "));
	    if (0 /*labs(mem[p + glueoffset - memmin].int_) < 1048576L */)
	      print(S("?.?"));
	    else {
	      if (fabs(g) > 20000.0) {
		if (g > 0.0)
		  printchar('>');
		else
		  print(S("< -"));
		printglue(unity * 20000, glueorder(p), 0);
	      } else
		printglue((long)floor(unity * g + 0.5), glueorder(p), 0);
	    }
	  }
	  if (shiftamount(p) != 0) {
	    print(S(", shifted "));
	    printscaled(shiftamount(p));
	  }
	}
	nodelistdisplay(listptr(p));
	break;
	/*:184*/

      case rulenode:   /*187:*/
	printesc(S("rule("));
	printruledimen(height(p));
	printchar('+');
	printruledimen(depth(p));
	print(S(")x"));
	printruledimen(width(p));
	break;
	/*:187*/

      case insnode:   /*188:*/
	printesc(S("insert"));
	printint(subtype(p) - minquarterword);
	print(S(", natural size "));
	printscaled(height(p));
	print(S("; split("));
	printspec(splittopptr(p), 0);
	printchar(',');
	printscaled(depth(p));
	print(S("); float cost "));
	printint(floatcost(p));
	nodelistdisplay(insptr(p));
	break;
	/*:188*/

      case whatsitnode:   /*1356:*/
	switch (subtype(p)) {   /*:1356*/

	case opennode:
	  printwritewhatsit(S("openout"), p);
	  printchar('=');
	  printfilename(openname(p), openarea(p), openext(p));
	  break;

	case writenode:
	  printwritewhatsit(S("write"), p);
	  printmark(writetokens(p));
	  break;

	case closenode:
	  printwritewhatsit(S("closeout"), p);
	  break;

	case specialnode:
	  printesc(S("special"));
	  printmark(writetokens(p));
	  break;

	case languagenode:
	  printesc(S("setlanguage"));
	  printint(whatlang(p));
	  print(S(" (hyphenmin "));
	  printint(whatlhm(p));
	  printchar(',');
	  printint(whatrhm(p));
	  printchar(')');
	  break;

	default:
	  print(S("whatsit?"));
	  break;
	}
	break;

      case gluenode:   /*189:*/
	if (subtype(p) >= aleaders) {   /*190:*/
	  printesc(S(""));
	  if (subtype(p) == cleaders)
	    printchar('c');
	  else if (subtype(p) == xleaders)
	    printchar('x');
	  print(S("leaders "));
	  printspec(glueptr(p), 0);
	  nodelistdisplay(leaderptr(p));
	}  /*:190*/
	else {   /*:189*/
	  printesc(S("glue"));
	  if (subtype(p) != normal) {
	    printchar('(');
	    if (subtype(p) < condmathglue)
	      printskipparam(subtype(p) - 1);
	    else {
	      if (subtype(p) == condmathglue)
		printesc(S("nonscript"));
	      else
		printesc(S("mskip"));
	    }
	    printchar(')');
	  }
	  if (subtype(p) != condmathglue) {
	    printchar(' ');
	    if (subtype(p) < condmathglue)
	      printspec(glueptr(p), 0);
	    else
	      printspec(glueptr(p), S("mu"));
	  }
	}
	break;

      case kernnode:   /*191:*/
	if (subtype(p) != muglue) {
	  printesc(S("kern"));
	  if (subtype(p) != normal)
	    printchar(' ');
	  printscaled(width(p));
	  if (subtype(p) == acckern)
	    print(S(" (for accent)"));
	} else {   /*:191*/
	  printesc(S("mkern"));
	  printscaled(width(p));
	  print(S("mu"));
	}
	break;

      case mathnode:   /*192:*/
	printesc(S("math"));
	if (subtype(p) == before)
	  print(S("on"));
	else
	  print(S("off"));
	if (width(p) != 0) {
	  print(S(", surrounded "));
	  printscaled(width(p));
	}
	break;
	/*:192*/

      case ligaturenode:   /*193:*/
	printfontandchar(ligchar(p));
	print(S(" (ligature "));
	if (subtype(p) > 1)
	  printchar('|');
	fontinshortdisplay = font(ligchar(p));
	shortdisplay(ligptr(p));
	if ((subtype(p)) & 1)
	  printchar('|');
	printchar(')');
	break;
	/*:193*/

      case penaltynode:   /*194:*/
	printesc(S("penalty "));
	printint(penalty(p));
	break;
	/*:194*/

      case discnode:   /*195:*/
	printesc(S("discretionary"));
	if (replacecount(p) > 0) {
	  print(S(" replacing "));
	  printint(replacecount(p));
	}
	nodelistdisplay(prebreak(p));
	appendchar('|');
	shownodelist(postbreak(p));
	flushchar();
	break;
	/*:195*/

      case marknode:   /*196:*/
	printesc(S("mark"));
	printmark(markptr(p));
	break;
	/*:196*/

      case adjustnode:   /*197:*/
	printesc(S("vadjust"));
	nodelistdisplay(adjustptr(p));
	break;
	/*:197*/
	/*690:*/

      case stylenode:
	printstyle(subtype(p));
	break;

      case choicenode:   /*695:*/
	printesc(S("mathchoice"));
	appendchar('D');
	shownodelist(displaymlist(p));
	flushchar();
	appendchar('T');
	shownodelist(textmlist(p));
	flushchar();
	appendchar('S');
	shownodelist(scriptmlist(p));
	flushchar();
	appendchar('s');
	shownodelist(scriptscriptmlist(p));
	flushchar();
	break;
	/*:695*/

      case ordnoad:
      case opnoad:
      case binnoad:
      case relnoad:
      case opennoad:
      case closenoad:
      case punctnoad:
      case innernoad:
      case radicalnoad:
      case overnoad:
      case undernoad:
      case vcenternoad:
      case accentnoad:
      case leftnoad:
      case rightnoad:   /*696:*/
	switch (type(p)) {

	case ordnoad:
	  printesc(S("mathord"));
	  break;

	case opnoad:
	  printesc(S("mathop"));
	  break;

	case binnoad:
	  printesc(S("mathbin"));
	  break;

	case relnoad:
	  printesc(S("mathrel"));
	  break;

	case opennoad:
	  printesc(S("mathopen"));
	  break;

	case closenoad:
	  printesc(S("mathclose"));
	  break;

	case punctnoad:
	  printesc(S("mathpunct"));
	  break;

	case innernoad:
	  printesc(S("mathinner"));
	  break;

	case overnoad:
	  printesc(S("overline"));
	  break;

	case undernoad:
	  printesc(S("underline"));
	  break;

	case vcenternoad:
	  printesc(S("vcenter"));
	  break;

	case radicalnoad:
	  printesc(S("radical"));
	  printdelimiter(leftdelimiter(p));
	  break;

	case accentnoad:
	  printesc(S("accent"));
	  printfamandchar(accentchr(p));
	  break;

	case leftnoad:
	  printesc(S("left"));
	  printdelimiter(nucleus(p));
	  break;

	case rightnoad:
	  printesc(S("right"));
	  printdelimiter(nucleus(p));
	  break;
	}
	if (subtype(p) != normal) {
	  if (subtype(p) == limits)
	    printesc(S("limits"));
	  else
	    printesc(S("nolimits"));
	}
	if (type(p) < leftnoad)
	  printsubsidiarydata(nucleus(p), '.');
	printsubsidiarydata(supscr(p), '^');
	printsubsidiarydata(subscr(p), '_');
	break;
	/*:696*/

      case fractionnoad:   /*697:*/
	printesc(S("fraction, thickness "));
	if (thickness(p) == defaultcode)
	  print(S("= default"));
	else
	  printscaled(thickness(p));
	if ((smallfam(leftdelimiter(p)) != 0) |
	    (smallchar(leftdelimiter(p)) != minquarterword) |
	    (largefam(leftdelimiter(p)) != 0) |
	    (largechar(leftdelimiter(p)) != minquarterword)) {
	  print(S(", left-delimiter "));
	  printdelimiter(leftdelimiter(p));
	}
	if ((smallfam(rightdelimiter(p)) != 0) |
	    (smallchar(rightdelimiter(p)) != minquarterword) |
	    (largefam(rightdelimiter(p)) != 0) |
	    (largechar(rightdelimiter(p)) != minquarterword)) {
	  print(S(", right-delimiter "));
	  printdelimiter(rightdelimiter(p));
	}
	printsubsidiarydata(numerator(p), '\\');
	printsubsidiarydata(denominator(p), '/');
	break;
	/*:697*/
	/*:690*/

      default:
	print(S("Unknown node type!"));
	break;
      }
    }
    p = link(p);
  }
_Lexit: ;
}


/*:182*/
/*198:*/
Static void showbox(halfword p)
{  /*236:*/
  depththreshold = showboxdepth;
  breadthmax = showboxbreadth;   /*:236*/
  if (breadthmax <= 0)
    breadthmax = 5;
#if 0
  if (poolptr + depththreshold >= poolsize)
    depththreshold = poolsize - poolptr - 1;
#else
	depththreshold = str_adjust_to_room(depththreshold);
#endif
  shownodelist(p);
  println();
}


/*:198*/
/*200:*/
Static void deletetokenref(halfword p)
{
  if (tokenrefcount(p) == 0)
    flushlist(p);
  else
    (tokenrefcount(p))--;
}


/*:200*/
/*201:*/
Static void deleteglueref(halfword p)
{
  karmafastdeleteglueref(p);
}


/*:201*/
/*202:*/
Static void flushnodelist(halfword p)
{
  pointer q;

  while (p != 0) {
    q = link(p);
    if (ischarnode(p)) {
      freeavail(p);
    } else {
      switch (type(p)) {

      case hlistnode:
      case vlistnode:
      case unsetnode:
	flushnodelist(listptr(p));
	freenode(p, boxnodesize);
	goto _Ldone;
	break;

      case rulenode:
	freenode(p, rulenodesize);
	goto _Ldone;
	break;

      case insnode:
	flushnodelist(insptr(p));
	deleteglueref(splittopptr(p));
	freenode(p, insnodesize);
	goto _Ldone;
	break;

      case whatsitnode:   /*1358:*/
	switch (subtype(p)) {

	case opennode:
	  freenode(p, opennodesize);
	  break;

	case writenode:
	case specialnode:
	  deletetokenref(writetokens(p));
	  freenode(p, writenodesize);
	  goto _Ldone;
	  break;

	case closenode:
	case languagenode:
	  freenode(p, smallnodesize);
	  break;

	default:
	  confusion(S("ext3"));
	  break;
	}
	goto _Ldone;
	break;
	/*:1358*/

      case gluenode:
	karmafastdeleteglueref(glueptr(p));
	if (leaderptr(p) != 0)
	  flushnodelist(leaderptr(p));
	break;

      case kernnode:
      case mathnode:
      case penaltynode:
	/* blank case */
	break;

      case ligaturenode:
	flushnodelist(ligptr(p));
	break;

      case marknode:
	deletetokenref(markptr(p));
	break;

      case discnode:
	flushnodelist(prebreak(p));
	flushnodelist(postbreak(p));
	break;

      case adjustnode:   /*698:*/
	flushnodelist(adjustptr(p));
	break;

      case stylenode:
	freenode(p, stylenodesize);
	goto _Ldone;
	break;

      case choicenode:
	flushnodelist(displaymlist(p));
	flushnodelist(textmlist(p));
	flushnodelist(scriptmlist(p));
	flushnodelist(scriptscriptmlist(p));
	freenode(p, stylenodesize);
	goto _Ldone;
	break;

      case ordnoad:
      case opnoad:
      case binnoad:
      case relnoad:
      case opennoad:
      case closenoad:
      case punctnoad:
      case innernoad:
      case radicalnoad:
      case overnoad:
      case undernoad:
      case vcenternoad:
      case accentnoad:
	if (mathtype(nucleus(p)) >= subbox)
	  flushnodelist(info(nucleus(p)));
	if (mathtype(supscr(p)) >= subbox)
	  flushnodelist(info(supscr(p)));
	if (mathtype(subscr(p)) >= subbox)
	  flushnodelist(info(subscr(p)));
	if (type(p) == radicalnoad)
	  freenode(p, radicalnoadsize);
	else if (type(p) == accentnoad)
	  freenode(p, accentnoadsize);
	else
	  freenode(p, noadsize);
	goto _Ldone;
	break;

      case leftnoad:
      case rightnoad:
	freenode(p, noadsize);
	goto _Ldone;
	break;

      case fractionnoad:
	flushnodelist(info(numerator(p)));
	flushnodelist(info(denominator(p)));
	freenode(p, fractionnoadsize);
	goto _Ldone;
	break;
	/*:698*/

      default:
	confusion(S("flushing"));
	break;
      }
      freenode(p, smallnodesize);
_Ldone: ;
    }
    p = q;
  }
}


/*:202*/
/*204:*/
Static halfword copynodelist(halfword p)
{
  pointer h, q, r=0 /* XXXX */;
  char words;

  h = getavail();
  q = h;
  while (p != 0) {  /*205:*/
    words = 1;
    if (ischarnode(p))
      r = getavail();
    else {  /*206:*/
      switch (type(p)) {   /*:206*/

      case hlistnode:
      case vlistnode:
      case unsetnode:
	r = getnode(boxnodesize);
	mem[r - memmin + 6] = mem[p - memmin + 6];
	mem[r - memmin + 5] = mem[p - memmin + 5];
	listptr(r) = copynodelist(listptr(p));
	words = 5;
	break;

      case rulenode:
	r = getnode(rulenodesize);
	words = rulenodesize;
	break;

      case insnode:
	r = getnode(insnodesize);
	mem[r - memmin + 4] = mem[p - memmin + 4];
	addglueref(splittopptr(p));
	insptr(r) = copynodelist(insptr(p));
	words = insnodesize - 1;
	break;

      case whatsitnode:   /*1357:*/
	switch (subtype(p)) {   /*:1357*/

	case opennode:
	  r = getnode(opennodesize);
	  words = opennodesize;
	  break;

	case writenode:
	case specialnode:
	  r = getnode(writenodesize);
	  addtokenref(writetokens(p));
	  words = writenodesize;
	  break;

	case closenode:
	case languagenode:
	  r = getnode(smallnodesize);
	  words = smallnodesize;
	  break;

	default:
	  confusion(S("ext2"));
	  break;
	}
	break;

      case gluenode:
	r = getnode(smallnodesize);
	addglueref(glueptr(p));
	glueptr(r) = glueptr(p);
	leaderptr(r) = copynodelist(leaderptr(p));
	break;

      case kernnode:
      case mathnode:
      case penaltynode:
	r = getnode(smallnodesize);
	words = smallnodesize;
	break;

      case ligaturenode:
	r = getnode(smallnodesize);
	mem[ligchar(r) - memmin] = mem[ligchar(p) - memmin];
	ligptr(r) = copynodelist(ligptr(p));
	break;

      case discnode:
	r = getnode(smallnodesize);
	prebreak(r) = copynodelist(prebreak(p));
	postbreak(r) = copynodelist(postbreak(p));
	break;

      case marknode:
	r = getnode(smallnodesize);
	addtokenref(markptr(p));
	words = smallnodesize;
	break;

      case adjustnode:
	r = getnode(smallnodesize);
	adjustptr(r) = copynodelist(adjustptr(p));
	break;

      default:
	confusion(S("copying"));
	break;
      }
    }
    while (words > 0) {   /*:205*/
      words--;
      mem[r + words - memmin] = mem[p + words - memmin];
    }
    link(q) = r;
    q = r;
    p = link(p);
  }
  link(q) = 0;
  q = link(h);
  freeavail(h);
  return q;
}


/*:204*/
/*211:*/
Static void printmode(long m)
{
  if (m > 0) {
    switch (m / (maxcommand + 1)) {

    case 0:
      print(S("vertical"));
      break;

    case 1:
      print(S("horizontal"));
      break;

    case 2:
      print(S("display math"));
      break;
    }
  } else if (m == 0)
    print(S("no"));
  else {
    switch (-m / (maxcommand + 1)) {

    case 0:
      print(S("internal vertical"));
      break;

    case 1:
      print(S("restricted horizontal"));
      break;

    case 2:
      print(S("math"));
      break;
    }
  }
  print(S(" mode"));
}


/*:211*/
/*216:*/
Static void pushnest(void)
{
  if (nestptr > maxneststack) {
    maxneststack = nestptr;
    if (nestptr == nestsize)
      overflow(S("semantic nest size"), nestsize);
  }
  nest[nestptr] = curlist;
  nestptr++;
  head = getavail();
  tail = head;
  prevgraf = 0;
  modeline = line;
}


/*:216*/
/*217:*/
Static void popnest(void)
{
  freeavail(head);
  nestptr--;
  curlist = nest[nestptr];
}


/*:217*/
/*218:*/
Static void printtotals(void);


Static void showactivities(void)
{
  pointer q, r;
  long t;
  short TEMP;

  nest[nestptr] = curlist;
  printnl(S(""));
  println();
  for (TEMP = nestptr; TEMP >= 0; TEMP--) {
    int p = TEMP;
    short m = nest[p].modefield;
    memoryword a = nest[p].auxfield;
    printnl(S("### "));
    printmode(m);
    print(S(" entered at line "));
    printint(labs(nest[p].mlfield));
    if (m == hmode) {
      if (nest[p].pgfield != 8585216L) {
	print(S(" (language"));
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
	printint(nest[p].pgfield % 65536L);
	print(S(":hyphenmin"));
	printint(nest[p].pgfield / 4194304L);
	printchar(',');
	printint((nest[p].pgfield / 65536L) & 63);
	printchar(')');
      }
    }
    if (nest[p].mlfield < 0)
      print(S(" (\\output routine)"));
    if (p == 0) {  /*986:*/
      if (pagehead != pagetail) {   /*:986*/
	printnl(S("### current page:"));
	if (outputactive)
	  print(S(" (held over for next output)"));
	showbox(link(pagehead));
	if (pagecontents > empty) {
	  printnl(S("total height "));
	  printtotals();
	  printnl(S(" goal height "));
	  printscaled(pagegoal);
	  r = link(pageinshead);
	  while (r != pageinshead) {
	    println();
	    printesc(S("insert"));
	    t = subtype(r) - minquarterword;
	    printint(t);
	    print(S(" adds "));
	    t = xovern(height(r), 1000) * count(t);
	    printscaled(t);
	    if (type(r) == splitup) {
	      q = pagehead;
	      t = 0;
	      do {
		q = link(q);
		if ((type(q) == insnode) & (subtype(q) == subtype(r)))
		  t++;
	      } while (q != brokenins(r));
	      print(S(", #"));
	      printint(t);
	      print(S(" might split"));
	    }
	    r = link(r);
	  }
	}
      }
      if (link(contribhead) != 0)
	printnl(S("### recent contributions:"));
    }
    showbox(link(nest[p].headfield));   /*219:*/
    switch (abs(m) / (maxcommand + 1)) {   /*:219*/

    case 0:
      printnl(S("prevdepth "));
      if (a.sc <= ignoredepth)
	print(S("ignored"));
      else
	printscaled(a.sc);
      if (nest[p].pgfield != 0) {
	print(S(", prevgraf "));
	printint(nest[p].pgfield);
	print(S(" line"));
	if (nest[p].pgfield != 1)
	  printchar('s');
      }
      break;

    case 1:
      printnl(S("spacefactor "));
      printint(a.hh.UU.lh);
      if (m > 0) {
	if (a.hh.rh > 0) {
	  print(S(", current language "));
	  printint(a.hh.rh);
	}
      }
      break;

    case 2:
      if (a.int_ != 0) {
	print(S("this will be denominator of:"));
	showbox(a.int_);
      }
      break;
    }
  }
}


/*:218*/

/*241:*/
Static void fixdateandtime(void)
{
  time = 720;
  day = 4;
  month = 7;
  year = 1776;
}


/*:241*/
/*245:*/
Static void begindiagnostic(void)
{
  diag_oldsetting = selector;
  if (tracingonline > 0 || selector != termandlog)
    return;
  selector--;
  if (history == spotless)
    history = warningissued;
}


Static void enddiagnostic(boolean blankline)
{
  printnl(S(""));
  if (blankline)
    println();
  selector = diag_oldsetting;
}


/*:245*/
/*252:*/

/*_STAT*/
Static void showeqtb(halfword n)
{
  if (n < activebase) {
    printchar('?');
    return;
  }
  if (n < gluebase) {
    /*
223:*/
    sprintcs(n);
    printchar('=');
    printcmdchr(eqtype(n), equiv(n));
    if (eqtype(n) >= call) {
      printchar(':');
      showtokenlist(link(equiv(n)), 0, 32);
    }
    return;
  }  /*:223*/
  if (n < localbase) {   /*229:*/
    if (n < skipbase) {
      printskipparam(n - gluebase);
      printchar('=');
      if (n < gluebase + thinmuskipcode)
	printspec(equiv(n), S("pt"));
      else
	printspec(equiv(n), S("mu"));
      return;
    }
    if (n < muskipbase) {
      printesc(S("skip"));
      printint(n - skipbase);
      printchar('=');
      printspec(equiv(n), S("pt"));
      return;
    }
    printesc(S("muskip"));
    printint(n - muskipbase);
    printchar('=');
    printspec(equiv(n), S("mu"));
    return;
  }
  if (n < intbase) {   /*233:*/
    if (n == parshapeloc) {
      printesc(S("parshape"));
      printchar('=');
      if (parshapeptr == 0)
	printchar('0');
      else
	printint(info(parshapeptr));
      return;
    }
    if (n < toksbase) {
      printcmdchr(assigntoks, n);
      printchar('=');
      if (equiv(n) != 0)
	showtokenlist(link(equiv(n)), 0, 32);
      return;
    }
    if (n < boxbase) {
      printesc(S("toks"));
      printint(n - toksbase);
      printchar('=');
      if (equiv(n) != 0)
	showtokenlist(link(equiv(n)), 0, 32);
      return;
    }
    if (n < curfontloc) {
      printesc(S("box"));
      printint(n - boxbase);
      printchar('=');
      if (equiv(n) == 0) {
	print(S("void"));
	return;
      }
      depththreshold = 0;
      breadthmax = 1;
      shownodelist(equiv(n));
      return;
    }
    if (n < catcodebase) {   /*234:*/
      if (n == curfontloc)
	print(S("current font"));
      else if (n < mathfontbase + 16) {
	printesc(S("textfont"));
	printint(n - mathfontbase);
      } else if (n < mathfontbase + 32) {
	printesc(S("scriptfont"));
	printint(n - mathfontbase - 16);
      } else {
	printesc(S("scriptscriptfont"));
	printint(n - mathfontbase - 32);
      }
      printchar('=');
      printesc(hash[fontidbase + equiv(n) - hashbase].rh);
      return;
    }
    /*:234*/
    if (n < mathcodebase) {
      if (n < lccodebase) {
	printesc(S("catcode"));
	printint(n - catcodebase);
      } else if (n < uccodebase) {
	printesc(S("lccode"));
	printint(n - lccodebase);
      } else if (n < sfcodebase) {
	printesc(S("uccode"));
	printint(n - uccodebase);
      } else {
	printesc(S("sfcode"));
	printint(n - sfcodebase);
      }
      printchar('=');
      printint(equiv(n));
      return;
    }
    printesc(S("mathcode"));
    printint(n - mathcodebase);
    printchar('=');
    printint(equiv(n));
    return;
  }
  if (n < dimenbase) {   /*242:*/
    if (n < countbase)
      printparam(n - intbase);
    else if (n < delcodebase) {
      printesc(S("count"));
      printint(n - countbase);
    } else {
      printesc(S("delcode"));
      printint(n - delcodebase);
    }
    printchar('=');
    printint(eqtb[n - activebase].int_);
    return;
  }  /*:242*/
  if (n > eqtbsize) {   /*251:*/
    printchar('?');
    return;
  }
  /*:251*/
  if (n < scaledbase)
    printlengthparam(n - dimenbase);
  else {
    printesc(S("dimen"));
    printint(n - scaledbase);
  }
  printchar('=');
  printscaled(eqtb[n - activebase].sc);
  print(S("pt"));

  /*:229*/
  /*235:*/
  /*:235*/
  /*:233*/
}


/*_ENDSTAT*/
/*:252*/

/*
Static halfword idlookup(long j, long l)
{
	return idlookup_p(buffer+j,l);
}
*/
#if 1
/*259:*/
halfword idlookup_p(unsigned char * buffp, long l, int no_new)
{   /*261:*/
  long h;
  pointer p, k;

  h = buffp[0];
  for (k = 1; k < l; k++) { 
	h += h + buffp[k];
	while (h >= hashprime)
		h -= hashprime;
  }
  p = h + hashbase;
  while (true) {
    if (text(p) > 0) {
	if (str_bcmp(buffp,l,text(p))) goto _Lfound;
    }
    if (next(p) == 0) {
      if (no_new)
	p = undefinedcontrolsequence;
      else  /*260:*/
      {   /*:260*/
	if (text(p) > 0) {
	  do {
	    if (hashisfull) {
	      overflow(S("hash size"), hashsize);
	    }
	    hashused--;
	  } while (text(hashused) != 0);
	  next(p) = hashused;
	  p = hashused;
	}
	text(p) = str_insert(buffp,l);
	/*_STAT*/
	cscount++;   /*_ENDSTAT*/
      }
      goto _Lfound;
    }
    p = next(p);
  }
_Lfound:
  return p;
}
/*:259*/
#endif

/*264:*/
Static void primitive(strnumber s, quarterword c, halfword o)
{
  if (s < 256)
    curval = s + singlebase;
  else {
	curval = idlookup_s(s,false);
    flushstring();
    text(curval) = s;
  }
  eqlevel(curval) = levelone;
  eqtype(curval) = c;
  equiv(curval) = o;
}


/*:264*/
/*274:*/
Static void newsavelevel(groupcode c)
{
  if (saveptr > maxsavestack) {
    maxsavestack = saveptr;
    if (maxsavestack > savesize - 6)
      overflow(S("save size"), savesize);
  }
  savetype(saveptr) = levelboundary;
  savelevel(saveptr) = curgroup;
  saveindex(saveptr) = curboundary;
  if (curlevel == maxquarterword)
    overflow(S("grouping levels"), maxquarterword - minquarterword);
  curboundary = saveptr;
  curlevel++;
  saveptr++;
  curgroup = c;
}


/*:274*/
/*275:*/
Static void eqdestroy(memoryword w)
{
  pointer q;

  switch (eqtypefield(w)) {

  case call:
  case longcall:
  case outercall:
  case longoutercall:
    deletetokenref(equivfield(w));
    break;

  case glueref:
    deleteglueref(equivfield(w));
    break;

  case shaperef:
    q = equivfield(w);
    if (q != 0)
      freenode(q, info(q) + info(q) + 1);
    break;

  case boxref:
    flushnodelist(equivfield(w));
    break;
  }
}


/*:275*/
/*276:*/
Static void eqsave(halfword p, quarterword l)
{
  if (saveptr > maxsavestack) {
    maxsavestack = saveptr;
    if (maxsavestack > savesize - 6)
      overflow(S("save size"), savesize);
  }
  if (l == levelzero)
    savetype(saveptr) = restorezero;
  else {
    savestack[saveptr] = eqtb[p - activebase];
    saveptr++;
    savetype(saveptr) = restoreoldvalue;
  }
  savelevel(saveptr) = l;
  saveindex(saveptr) = p;
  saveptr++;
}


/*:276*/
/*277:*/
Static void eqdefine(halfword p, quarterword t, halfword e)
{
  if (eqlevel(p) == curlevel)
    eqdestroy(eqtb[p - activebase]);
  else if (curlevel > levelone)
    eqsave(p, eqlevel(p));
  eqlevel(p) = curlevel;
  eqtype(p) = t;
  equiv(p) = e;
}


/*:277*/
/*278:*/
Static void eqworddefine(halfword p, long w)
{
  if (xeqlevel[p - intbase] != curlevel) {
    eqsave(p, xeqlevel[p - intbase]);
    xeqlevel[p - intbase] = curlevel;
  }
  eqtb[p - activebase].int_ = w;
}


/*:278*/
/*279:*/
Static void geqdefine(halfword p, quarterword t, halfword e)
{
  eqdestroy(eqtb[p - activebase]);
  eqlevel(p) = levelone;
  eqtype(p) = t;
  equiv(p) = e;
}


Static void geqworddefine(halfword p, long w)
{
  eqtb[p - activebase].int_ = w;
  xeqlevel[p - intbase] = levelone;
}


/*:279*/
/*280:*/
Static void saveforafter(halfword t)
{
  if (curlevel <= levelone)
    return;
  if (saveptr > maxsavestack) {
    maxsavestack = saveptr;
    if (maxsavestack > savesize - 6)
      overflow(S("save size"), savesize);
  }
  savetype(saveptr) = inserttoken;
  savelevel(saveptr) = levelzero;
  saveindex(saveptr) = t;
  saveptr++;
}


/*:280*/
/*281:*/
/*284:*/
/*_STAT*/
Static void restoretrace(halfword p, strnumber s)
{
  begindiagnostic();
  printchar('{');
  print(s);
  printchar(' ');
  showeqtb(p);
  printchar('}');
  enddiagnostic(false);
}


/*_ENDSTAT*/
/*:284*/
Static void backinput(void);


Static void unsave(void)
{
  pointer p;
  quarterword l=0 /* XXXX */;
  halfword t;

  if (curlevel <= levelone) {
    confusion(S("curlevel"));
    return;
  }
  curlevel--;   /*282:*/
  while (true) {
    saveptr--;
    if (savetype(saveptr) == levelboundary)
      goto _Ldone;
    p = saveindex(saveptr);
    if (savetype(saveptr) == inserttoken) {   /*326:*/
      t = curtok;
      curtok = p;
      backinput();
      curtok = t;
      continue;
    }  /*:326*/
    if (savetype(saveptr) == restoreoldvalue) {   /*283:*/
      l = savelevel(saveptr);
      saveptr--;
    } else
      savestack[saveptr] = eqtb[undefinedcontrolsequence - activebase];
    if (p < intbase) {
      if (eqlevel(p) == levelone) {
	eqdestroy(savestack[saveptr]);   /*_STAT*/
	if (tracingrestores > 0)   /*_ENDSTAT*/
	  restoretrace(p, S("retaining"));
      } else {
	eqdestroy(eqtb[p - activebase]);
	eqtb[p - activebase] = savestack[saveptr];   /*_STAT*/
	if (tracingrestores > 0)   /*_ENDSTAT*/
	  restoretrace(p, S("restoring"));
      }
      continue;
    }
    if (xeqlevel[p - intbase] != levelone) {
      eqtb[p - activebase] = savestack[saveptr];
      xeqlevel[p - intbase] = l;   /*_STAT*/
      if (tracingrestores > 0)   /*_ENDSTAT*/
	restoretrace(p, S("restoring"));
    } else   /*:283*/
    {  /*_STAT*/
      if (tracingrestores > 0)   /*_ENDSTAT*/
	restoretrace(p, S("retaining"));
    }
  }
_Ldone:
  curgroup = savelevel(saveptr);
  curboundary = saveindex(saveptr);   /*:282*/
}


/*:281*/
/*288:*/
Static void preparemag(void)
{
  if (magset > 0 && mag != magset) {
    printnl(S("! "));
    print(S("Incompatible magnification ("));
    printint(mag);
    print(S(");"));
    printnl(S(" the previous value will be retained"));
    help2(S("I can handle only one magnification ratio per job. So I've"),S("reverted to the magnification you used earlier on this run."));
    interror(magset);
    geqworddefine(intbase + magcode, magset);
  }
  if (mag <= 0 || mag > 32768L) {
    printnl(S("! "));
    print(S("Illegal magnification has been changed to 1000"));
    help1(S("The magnification ratio must be between 1 and 32768."));
    interror(mag);
    geqworddefine(intbase + magcode, 1000);
  }
  magset = mag;
}


/*:288*/
/*295:*/
Static void tokenshow(halfword p)
{
  if (p != 0)
    showtokenlist(link(p), 0, 10000000L);
}  /*:295*/


/*296:*/
Static void printmeaning(void)
{
  printcmdchr(curcmd, curchr);
  if (curcmd >= call) {
    printchar(':');
    println();
    tokenshow(curchr);
    return;
  }
  if (curcmd != topbotmark)
    return;
  printchar(':');
  println();
  tokenshow(curmark[curchr - topmarkcode]);
}


/*:296*/
/*299:*/
Static void showcurcmdchr(void)
{
  begindiagnostic();
  printnl('{');
  if (mode != shownmode) {
    printmode(mode);
    print(S(": "));
    shownmode = mode;
  }
  printcmdchr(curcmd, curchr);
  printchar('}');
  enddiagnostic(false);
}


/*:299*/
/*311:*/
Static void showcontext(void)
{   /*:315*/
  char oldsetting;
  long nn;
  boolean bottomline;   /*315:*/
  short i;
  short j;
  char l;
  long m;
  char n;
  long p, q;

  baseptr = inputptr;
  inputstack[baseptr] = curinput;
  nn = -1;
  bottomline = false;
  while (true) {
    curinput = inputstack[baseptr];
    if (state != tokenlist) {
      if (name > 17 || baseptr == 0)
	bottomline = true;
    }
    if (baseptr == inputptr || bottomline || nn < errorcontextlines) {
	  /*312:*/
	    if (baseptr == inputptr || state != tokenlist ||
		tokentype != backedup || loc != 0) {
	tally = 0;
	oldsetting = selector;
	if (state != tokenlist) {  /*313:*/
	  if (name <= 17) {   /*:313*/
	    if (terminalinput) {
	      if (baseptr == 0)
		printnl(S("<*>"));
	      else
		printnl(S("<insert> "));
	    } else {
	      printnl(S("<read "));
	      if (name == 17)
		printchar('*');
	      else
		printint(name - 1);
	      printchar('>');
	    }
	  } else {
	    printnl(S("l."));
	    printint(line);
	  }
	  printchar(' ');   /*318:*/
	  beginpseudoprint();
	  if (buffer[limit] == endlinechar)
	    j = limit;
	  else
	    j = limit + 1;
	  if (j > 0) {
	    for (i = start; i < j; i++) {   /*:318*/
	      if (i == loc) {
		settrickcount();
	      }
	      print(buffer[i]);
	    }
	  }
	} else {  /*314:*/
	  switch (tokentype) {   /*:314*/

	  case parameter:
	    printnl(S("<argument> "));
	    break;

	  case utemplate:
	  case vtemplate:
	    printnl(S("<template> "));
	    break;

	  case backedup:
	    if (loc == 0)
	      printnl(S("<recently read> "));
	    else
	      printnl(S("<to be read again> "));
	    break;

	  case inserted:
	    printnl(S("<inserted text> "));
	    break;

	  case macro:
	    println();
	    printcs(name);
	    break;

	  case outputtext:
	    printnl(S("<output> "));
	    break;

	  case everypartext:
	    printnl(S("<everypar> "));
	    break;

	  case everymathtext:
	    printnl(S("<everymath> "));
	    break;

	  case everydisplaytext:
	    printnl(S("<everydisplay> "));
	    break;

	  case everyhboxtext:
	    printnl(S("<everyhbox> "));
	    break;

	  case everyvboxtext:
	    printnl(S("<everyvbox> "));
	    break;

	  case everyjobtext:
	    printnl(S("<everyjob> "));
	    break;

	  case everycrtext:
	    printnl(S("<everycr> "));
	    break;

	  case marktext:
	    printnl(S("<mark> "));
	    break;

	  case writetext:
	    printnl(S("<write> "));
	    break;

	  default:
	    printnl('?');
	    break;
	  }
	  /*319:*/
	  beginpseudoprint();
	  if (tokentype < macro)
	    showtokenlist(start, loc, 100000L);
	  else   /*:319*/
	    showtokenlist(link(start), loc, 100000L);
	}
	selector = oldsetting;   /*317:*/
	if (trickcount == 1000000L) {
	  settrickcount();
	}
	if (tally < trickcount)
	  m = tally - firstcount;
	else
	  m = trickcount - firstcount;
	if (l + firstcount <= halferrorline) {
	  p = 0;
	  n = l + firstcount;
	} else {
	  print(S("..."));
	  p = l + firstcount - halferrorline + 3;
	  n = halferrorline;
	}
	for (q = p; q < firstcount; q++) {
	  printchar(trickbuf[q % errorline]);
	}
	println();
	for (q = 1; q <= n; q++)
	  printchar(' ');
	if (m + n <= errorline)
	  p = firstcount + m;
	else
	  p = firstcount + errorline - n - 3;
	for (q = firstcount; q < p; q++) {
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
	  printchar(trickbuf[q % errorline]);
	}
	if (m + n > errorline)   /*:317*/
	  print(S("..."));
	nn++;
      }
    }  /*:312*/
    else if (nn == errorcontextlines) {
      printnl(S("..."));
      nn++;
    }
    if (bottomline)
      goto _Ldone;
    baseptr--;
  }
_Ldone:
  curinput = inputstack[inputptr];
}


/*:311*/
/*323:*/
Static void begintokenlist(halfword p, quarterword t)
{
  if (inputptr > maxinstack) {
    maxinstack = inputptr;
    if (inputptr == stacksize)
      overflow(S("input stack size"), stacksize);
  }
  inputstack[inputptr] = curinput;
  inputptr++;
  state = tokenlist;
  start = p;
  tokentype = t;
  if (t < macro) {
    loc = p;
    return;
  }
  addtokenref(p);
  if (t == macro) {
    paramstart = paramptr;
    return;
  }
  loc = link(p);
  if (tracingmacros <= 1)
    return;
  begindiagnostic();
  printnl(S(""));
  switch (t) {

  case marktext:
    printesc(S("mark"));
    break;

  case writetext:
    printesc(S("write"));
    break;

  default:
    printcmdchr(assigntoks, t - outputtext + outputroutineloc);
    break;
  }
  print(S("->"));
  tokenshow(p);
  enddiagnostic(false);
}


/*:323*/
/*324:*/
Static void endtokenlist(void)
{
  if (tokentype >= backedup) {
    if (tokentype <= inserted)
      flushlist(start);
    else {
      deletetokenref(start);
      if (tokentype == macro) {
	while (paramptr > paramstart) {
	  paramptr--;
	  flushlist(paramstack[paramptr]);
	}
      }
    }
  } else if (tokentype == utemplate) {
    if (alignstate > 500000L)
      alignstate = 0;
    else
      fatalerror(S("(interwoven alignment preambles are not allowed)"));
  }
  popinput();
  checkinterrupt();
}


/*:324*/
/*325:*/
Static void backinput(void)
{
  pointer p;

  while (state == tokenlist && loc == 0)
    endtokenlist();
  p = getavail();
  info(p) = curtok;
  if (curtok < rightbracelimit) {
    if (curtok < leftbracelimit)
      alignstate--;
    else
      alignstate++;
  }
  if (inputptr > maxinstack) {
    maxinstack = inputptr;
    if (inputptr == stacksize)
      overflow(S("input stack size"), stacksize);
  }
  inputstack[inputptr] = curinput;
  inputptr++;
  state = tokenlist;
  start = p;
  tokentype = backedup;
  loc = p;
}


/*:325*/
/*327:*/
Static void backerror(void)
{
  OKtointerrupt = false;
  backinput();
  OKtointerrupt = true;
  error();
}


Static void inserror(void)
{
  OKtointerrupt = false;
  backinput();
  tokentype = inserted;
  OKtointerrupt = true;
  error();
}


/*:327*/
/*328:*/
Static void beginfilereading(void)
{
  if (inopen == maxinopen)
    overflow(S("text input levels"), maxinopen);
  if (first == bufsize)
    overflow(S("buffer size"), bufsize);
  inopen++;
  if (inputptr > maxinstack) {
    maxinstack = inputptr;
    if (inputptr == stacksize)
      overflow(S("input stack size"), stacksize);
  }
  inputstack[inputptr] = curinput;
  inputptr++;
  iindex = inopen;
  linestack[iindex - 1] = line;
  start = first;
  state = midline;
  name = 0;
}  /*:328*/


/*329:*/
Static void endfilereading(void)
{
  first = start;
  line = linestack[iindex - 1];
  if (name > 17)
    aclose(&curfile);
  popinput();
  inopen--;
}


/*:329*/
/*330:*/
Static void clearforerrorprompt(void)
{
  while (state != tokenlist && terminalinput && inputptr > 0 && loc > limit) {
    endfilereading();
  }
  println();
}


/*:330*/
/*336:*/
Static void checkoutervalidity(int local_curcs)
{
  pointer p, q;
  curcs = local_curcs;
  if (scannerstatus == normal)
    return;
  deletionsallowed = false;   /*337:*/
  if (curcs != 0) {   /*:337*/
    if (state == tokenlist || name < 1 || name > 17) {
      p = getavail();
      info(p) = cstokenflag + curcs;
      backlist(p);
    }
    curcmd = spacer;
    curchr = ' ';
  }
  if (scannerstatus > skipping) {   /*338:*/
    runaway();
    if (curcs == 0) {
      printnl(S("! "));
      print(S("File ended"));
    } else {
      curcs = 0;
      printnl(S("! "));
      print(S("Forbidden control sequence found"));
    }
    print(S(" while scanning "));   /*339:*/
    p = getavail();
    switch (scannerstatus) {

    case defining:
      print(S("definition"));
      info(p) = rightbracetoken + '}';
      break;

    case matching:
      print(S("use"));
      info(p) = partoken;
      longstate = outercall;
      break;

    case aligning:
      print(S("preamble"));
      info(p) = rightbracetoken + '}';
      q = p;
      p = getavail();
      link(p) = q;
      info(p) = cstokenflag + frozencr;
      alignstate = -1000000L;
      break;

    case absorbing:
      print(S("text"));
      info(p) = rightbracetoken + '}';
      break;
    }
    inslist(p);   /*:339*/
    print(S(" of "));
    sprintcs(warningindex);
    help4(S("I suspect you have forgotten a `}', causing me"),S("to read past where you wanted me to stop."),S("I'll try to recover; but if the error is serious,"),S("you'd better type `E' or `X' now and fix your file."));
    error();
  } else {
    printnl(S("! "));
    print(S("Incomplete "));
    printcmdchr(iftest, curif);
    print(S("; all text was ignored after line "));
    printint(skipline);
    help3(S("A forbidden control sequence occurred in skipped text."),S("This kind of error happens when you say `\\if...' and forget"),S("the matching `\\fi'. I've inserted a `\\fi'; this might work."));
    if (curcs != 0)
      curcs = 0;
    else
      helpline[2] = S("The file ended while I was skipping conditional text.");
    curtok = cstokenflag + frozenfi;
    inserror();
  }
  /*:338*/
  deletionsallowed = true;
}


/*:336*/
/*340:*/
Static void firmuptheline(void);


/*:340*/
/*341:*/
Static void getnext(void)
{
  short k;
  halfword t;
  char cat;
  ASCIIcode c, cc=0 /* XXXX */;
  char d;
  int cur_cs;
/*
  int cur_chr, cur_cmd, cur_cs, cur_tok;
*/

_Lrestart:
  cur_cs = 0;
  if (state != tokenlist) {   /*343:*/
_Lswitch__:
    if (loc > limit) {
      state = newline;   /*360:*/
      if (name > 17) {   /*362:*/
	line++;
	first = start;
	if (!forceeof) {
	  if (inputln(&curfile, true))
	    firmuptheline();
	  else
	    forceeof = true;
	}
	if (forceeof) {
	  printchar(')');
	  openparens--;
	  fflush(termout);
	  forceeof = false;
	  endfilereading();
	  checkoutervalidity(cur_cs);
	  cur_cs=curcs;
	  goto _Lrestart;
	}
	if (endlinecharinactive) {
	  limit--;
	} else
	  buffer[limit] = endlinechar;
	first = limit + 1;
	loc = start;
      }  /*:362*/
      else {   /*:360*/
	if (!terminalinput) {
	  curcmd = 0;
	  curchr = 0;
	  goto _Lexit;
	}
	if (inputptr > 0) {
	  endfilereading();
	  goto _Lrestart;
	}
	if (selector < logonly)
	  openlogfile();
	if (interaction > nonstopmode) {
	  if (endlinecharinactive) {
	    limit++;
	  }
	  if (limit == start)
	    printnl(S("(Please type a command or say `\\end')"));
	  println();
	  first = start;
	  print('*');
	  terminput();
	  limit = last;
	  if (endlinecharinactive) {
	    limit--;
	  } else
	    buffer[limit] = endlinechar;
	  first = limit + 1;
	  loc = start;
	} else
	  fatalerror(S("*** (job aborted, no legal \\end found)"));
      }
      checkinterrupt();
      goto _Lswitch__;
    }
    curchr = buffer[loc];
    loc++;
_Lreswitch:
    curcmd = catcode(curchr);   /*344:*/
    switch (state + curcmd) {   /*345:*/

    case midline + ignore:
    case skipblanks + ignore:
    case newline + ignore:
    case skipblanks + spacer:
    case newline + spacer:   /*:345*/
      goto _Lswitch__;
      break;

    case midline:
    case skipblanks:
    case newline:   /*354:*/
      if (loc > limit)
	cur_cs = nullcs;
      else {
_Lstartcs_:
	k = loc;
	curchr = buffer[k];
	cat = catcode(curchr);
	k++;
	if (cat == letter)
	  state = skipblanks;
	else if (cat == spacer)
	  state = skipblanks;
	else
	  state = midline;
	if (cat == letter && k <= limit) {   /*356:*/
	  do {
	    curchr = buffer[k];
	    cat = catcode(curchr);
	    k++;
	  } while (cat == letter && k <= limit);   /*355:*/
	  if (buffer[k] == curchr) {   /*:355*/
	    if (cat == supmark) {
	      if (k < limit) {
		c = buffer[k + 1];
		if (c < 128) {
		  d = 2;
		  if (ishex(c)) {
		    if (k + 2 <= limit) {
		      cc = buffer[k + 2];
		      if (ishex(cc)) {
			d++;
		      }
		    }
		  }
		  if (d > 2) {
		    buffer[k - 1] = curchr = hex_to_i(c,cc);
		  } else if (c < 64)
		    buffer[k - 1] = c + 64;
		  else
		    buffer[k - 1] = c - 64;
		  limit -= d;
		  first -= d;
		  while (k <= limit) {
		    buffer[k] = buffer[k + d];
		    k++;
		  }
		  goto _Lstartcs_;
		}
	      }
	    }
	  }
	  if (cat != letter)
	    k--;
	  if (k > loc + 1) {
	    cur_cs = idlookup_p(buffer+loc, k - loc, nonewcontrolsequence);
	    loc = k;
	    goto _Lfound;
	  }
	} else  /*355:*/
	{   /*:355*/
	  if (buffer[k] == curchr) {
	    if (cat == supmark) {
	      if (k < limit) {
		c = buffer[k + 1];
		if (c < 128) {
		  d = 2;
		  if (ishex(c)) {
		    if (k + 2 <= limit) {
		      cc = buffer[k + 2];
		      if (ishex(cc)) {
			d++;
		      }
		    }
		  }
		  if (d > 2) {
		    buffer[k - 1] = curchr = hex_to_i(c,cc);
		  } else if (c < 64)
		    buffer[k - 1] = c + 64;
		  else
		    buffer[k - 1] = c - 64;
		  limit -= d;
		  first -= d;
		  while (k <= limit) {
		    buffer[k] = buffer[k + d];
		    k++;
		  }
		  goto _Lstartcs_;
		}
	      }
	    }
	  }
	}
	/*:356*/
	cur_cs = singlebase + buffer[loc];
	loc++;
      }
_Lfound:
      curcmd = eqtype(cur_cs);
      curchr = equiv(cur_cs);
      if (curcmd >= outercall) {
	checkoutervalidity(cur_cs);
	cur_cs=curcs;
      }
      break;
      /*:354*/

    case midline + activechar:
    case skipblanks + activechar:
    case newline + activechar:   /*353:*/
      cur_cs = curchr + activebase;
      curcmd = eqtype(cur_cs);
      curchr = equiv(cur_cs);
      state = midline;
      if (curcmd >= outercall) {
	checkoutervalidity(cur_cs);
	cur_cs=curcs;
      }
      break;
      /*:353*/

    case midline + supmark:
    case skipblanks + supmark:
    case newline + supmark:   /*352:*/
      if (curchr == buffer[loc]) {
	if (loc < limit) {
	  c = buffer[loc + 1];
	  if (c < 128) {
	    loc += 2;
	    if (ishex(c)) {
	      if (loc <= limit) {
		cc = buffer[loc];
		if (ishex(cc)) {
		  loc++;
		  curchr = hex_to_i(c,cc);
		  goto _Lreswitch;
		}
	      }
	    }
	    if (c < 64)
	      curchr = c + 64;
	    else
	      curchr = c - 64;
	    goto _Lreswitch;
	  }
	}
      }
      state = midline;
      break;
      /*:352*/

    case midline + invalidchar:
    case skipblanks + invalidchar:
    case newline + invalidchar:   /*346:*/
      printnl(S("! "));
      print(S("Text line contains an invalid character"));
      help2(S("A funny symbol that I can't read has just been input."),S("Continue, and I'll forget that it ever happened."));
      deletionsallowed = false;
      error();
      deletionsallowed = true;
      goto _Lrestart;
      break;
      /*:346*/
      /*347:*/

    case midline + spacer:   /*349:*/
      state = skipblanks;
      curchr = ' ';
      break;
      /*:349*/

    case midline + carret:   /*348:*/
      loc = limit + 1;
      curcmd = spacer;
      curchr = ' ';
      break;
      /*:348*/

    case skipblanks + carret:
    case midline + comment:
    case skipblanks + comment:
    case newline + comment:   /*:350*/
      /*
350:*/
      loc = limit + 1;
      goto _Lswitch__;
      break;

    case newline + carret:   /*351:*/
      loc = limit + 1;
      cur_cs = parloc;
      curcmd = eqtype(cur_cs);
      curchr = equiv(cur_cs);
      if (curcmd >= outercall) {
	checkoutervalidity(cur_cs);
	cur_cs=curcs;
      }
      break;
      /*:351*/

    case midline + leftbrace:
      alignstate++;
      break;

    case skipblanks + leftbrace:
    case newline + leftbrace:
      state = midline;
      alignstate++;
      break;

    case midline + rightbrace:
      alignstate--;
      break;

    case skipblanks + rightbrace:
    case newline + rightbrace:
      state = midline;
      alignstate--;
      break;

    case skipblanks + mathshift:
    case skipblanks + tabmark:
    case skipblanks + macparam:
    case skipblanks + submark:
    case skipblanks + letter:
    case skipblanks + otherchar:
    case newline + mathshift:
    case newline + tabmark:
    case newline + macparam:
    case newline + submark:
    case newline + letter:
    case newline + otherchar:   /*:347*/
      state = midline;
      break;
    }
    /*:344*/
  } else {  /*357:*/
    if (loc == 0) {
      endtokenlist();
      goto _Lrestart;
    }
    t = info(loc);
    loc = link(loc);
    if (t >= cstokenflag) {
      cur_cs = t - cstokenflag;
      curcmd = eqtype(cur_cs);
      curchr = equiv(cur_cs);
      if (curcmd >= outercall) {
	if (curcmd == dontexpand) {   /*358:*/
	  cur_cs = info(loc) - cstokenflag;
	  loc = 0;
	  curcmd = eqtype(cur_cs);
	  curchr = equiv(cur_cs);
	  if (curcmd > maxcommand) {
	    curcmd = relax;
	    curchr = noexpandflag;
	  }
	} else {
	  checkoutervalidity(cur_cs);
	  cur_cs=curcs;
	}
	/*:358*/
      }
    } else {
      curcmd = t / dwa_do_8;
      curchr = t & (dwa_do_8-1);
      switch (curcmd) {

      case leftbrace:
	alignstate++;
	break;

      case rightbrace:
	alignstate--;
	break;

      case outparam:   /*359:*/
	begintokenlist(paramstack[paramstart + curchr - 1], parameter);
	goto _Lrestart;
	break;
	/*:359*/
      }
    }
  }
  /*:343*/
  /*342:*/
  if (curcmd <= carret) {
    if (curcmd >= tabmark) { /*789:*/
      if (alignstate == 0) {   
	if (scannerstatus == aligning)
	  fatalerror(S("(interwoven alignment preambles are not allowed)"));
	curcmd = extrainfo(curalign);
	extrainfo(curalign) = curchr;
	if (curcmd == omit)
	  begintokenlist(omittemplate, vtemplate);
	else
	  begintokenlist(vpart(curalign), vtemplate);
	alignstate = 1000000L;
	goto _Lrestart;
      }
      /*:789*/
      /*:342*/
    }
  }
_Lexit: ;


  curcs = cur_cs;

  /*:357*/
}

/*:341*/
/*363:*/
Static void firmuptheline(void)
{
  short k;

  limit = last;
  if (pausing <= 0)
    return;
  if (interaction <= nonstopmode)
    return;
  println();
  if (start < limit) {
    for (k = start; k < limit; k++)
      print(buffer[k]);
  }
  first = limit;
  print(S("=>"));
  terminput();
  if (last <= first)
    return;
  for (k = first; k < last; k++)
    buffer[k + start - first] = buffer[k];
  limit = start + last - first;
}


/*:363*/
/*365:*/
Static void gettoken(void)
{
  nonewcontrolsequence = false;
  getnext();
  nonewcontrolsequence = true;
  pack_tok(curtok,curcs,curcmd,curchr);
}


/*:365*/
/*366:*/
/*389:*/
Static void macrocall(void)
{
  pointer r, p=0 /* XXXX */, s, t, u, v, rbraceptr=0 /* XXXX */, refcount, savewarningindex;
  /* smallnumber */ int n; /* INT */
  halfword unbalance, m=0 /* XXXX */;
  smallnumber savescannerstatus;
  ASCIIcode matchchr=0 /* XXXX */;
  pointer pstack[9];

  savescannerstatus = scannerstatus;
  savewarningindex = warningindex;
  warningindex = curcs;
  refcount = curchr;
  r = link(refcount);
  n = 0;
  if (tracingmacros > 0) {   /*401:*/
    begindiagnostic();
    println();
    printcs(warningindex);
    tokenshow(refcount);
    enddiagnostic(false);
  }
  /*:401*/
  if (info(r) != endmatchtoken) {   /*391:*/
    scannerstatus = matching;
    unbalance = 0;
    longstate = eqtype(curcs);
    if (longstate >= outercall)
      longstate -= 2;
    do {
      link(temphead) = 0;
      if ((info(r) > matchtoken + (dwa_do_8-1)) | (info(r) < matchtoken))
	    /*392:*/
	      s = 0;
      else {
	matchchr = info(r) - matchtoken;
	s = link(r);
	r = s;
	p = temphead;
	m = 0;
      }
_Llabcontinue:
      gettoken();
      if (curtok == info(r)) {   /*394:*/
	r = link(r);
	if ((info(r) >= matchtoken) & (info(r) <= endmatchtoken)) {
	  if (curtok < leftbracelimit)
	    alignstate--;
	  goto _Lfound;
	} else
	  goto _Llabcontinue;
      }
      /*:394*/
      /*397:*/
      if (s != r) {
	if (s == 0) {   /*398:*/
	  printnl(S("! "));
	  print(S("Use of "));
	  sprintcs(warningindex);
	  print(S(" doesn't match its definition"));
	  help4(S("If you say, e.g., `\\def\\a1{...}', then you must always"),S("put `1' after `\\a', since control sequence names are"),S("made up of letters only. The macro here has not been"),S("followed by the required stuff, so I'm ignoring it."));
	  error();
	  goto _Lexit;
	}
	/*:398*/
	t = s;
	do {
	  storenewtoken(p,info(t));
	  m++;
	  u = link(t);
	  v = s;
	  while (true) {
	    if (u == r) {
	      if (curtok != info(v))
		goto _Ldone;
	      else {
		r = link(v);
		goto _Llabcontinue;
	      }
	    }
	    if (info(u) != info(v))
	      goto _Ldone;
	    u = link(u);
	    v = link(v);
	  }
_Ldone:
	  t = link(t);
	} while (t != r);
	r = s;
      }
      if (curtok == partoken) {
	if (longstate != longcall) {   /*396:*/
	  if (longstate == call) {
	    runaway();
	    printnl(S("! "));
	    print(S("Paragraph ended before "));
	    sprintcs(warningindex);
	    print(S(" was complete"));
	    help3(S("I suspect you've forgotten a `}', causing me to apply this"),S("control sequence to too much text. How can we recover?"),S("My plan is to forget the whole thing and hope for the best."));
	    backerror();
	  }
	  pstack[n] = link(temphead);
	  alignstate -= unbalance;
	  for (m = 0; m <= n; m++)
	    flushlist(pstack[m]);
	  goto _Lexit;
	}
	/*:396*/
      }
      if (curtok < rightbracelimit) {
	if (curtok < leftbracelimit) {   /*399:*/
	  unbalance = 1;
	  while (true) {
	    faststorenewtoken(p,curtok);
	    gettoken();
	    if (curtok == partoken) {
	      if (longstate != longcall) {   /*396:*/
		if (longstate == call) {
		  runaway();
		  printnl(S("! "));
		  print(S("Paragraph ended before "));
		  sprintcs(warningindex);
		  print(S(" was complete"));
		  help3(S("I suspect you've forgotten a `}', causing me to apply this"),S("control sequence to too much text. How can we recover?"),S("My plan is to forget the whole thing and hope for the best."));
		  backerror();
		}
		pstack[n] = link(temphead);
		alignstate -= unbalance;
		for (m = 0; m <= n; m++)
		  flushlist(pstack[m]);
		goto _Lexit;
	      }
	      /*:396*/
	    }
	    if (curtok >= rightbracelimit)
	      continue;
	    if (curtok < leftbracelimit)
	      unbalance++;
	    else {
	      unbalance--;
	      if (unbalance == 0)
		goto _Ldone1;
	    }
	  }
_Ldone1:
	  rbraceptr = p;
	  storenewtoken(p,curtok);
	} else {   /*395:*/
	  backinput();
	  printnl(S("! "));
	  print(S("Argument of "));
	  sprintcs(warningindex);
	  print(S(" has an extra }"));
	  help6(S("I've run across a `}' that doesn't seem to match anything."),S("For example, `\\def\\a#1{...}' and `\\a}' would produce"),S("this error. If you simply proceed now, the `\\par' that"),S("I've just inserted will cause me to report a runaway"),S("argument that might be the root of the problem. But if"),S("your `}' was spurious, just type `2' and it will go away."));
	  alignstate++;
	  longstate = call;
	  curtok = partoken;
	  inserror();
	}
	/*:399*/
      } else  /*393:*/
      {   /*:393*/
	if (curtok == spacetoken) {
	  if (info(r) <= endmatchtoken) {
	    if (info(r) >= matchtoken)
	      goto _Llabcontinue;
	  }
	}
	storenewtoken(p,curtok);
      }
      m++;
      if (info(r) > endmatchtoken)
	goto _Llabcontinue;
      if (info(r) < matchtoken)
	goto _Llabcontinue;
_Lfound:
      if (s != 0) {   /*400:*/
	if (((m == 1) & (info(p) < rightbracelimit)) && p != temphead) {
	  link(rbraceptr) = 0;
	  freeavail(p);
	  p = link(temphead);
	  pstack[n] = link(p);
	  freeavail(p);
	} else
	  pstack[n] = link(temphead);
	n++;
	if (tracingmacros > 0) {
	  begindiagnostic();
	  printnl(matchchr);
	  printint(n);
	  print(S("<-"));
	  showtokenlist(pstack[n - 1], 0, 1000);
	  enddiagnostic(false);
	}
      }
      /*:400*/
      /*:392*/
    } while (info(r) != endmatchtoken);
  }
  /*:391*/
  /*390:*/
  while (state == tokenlist && loc == 0)
    endtokenlist();
  begintokenlist(refcount, macro);
  name = warningindex;
  loc = link(r);
  if (n > 0) {   /*:390*/
    if (paramptr + n > maxparamstack) {
      maxparamstack = paramptr + n;
      if (maxparamstack > paramsize)
	overflow(S("parameter stack size"), paramsize);
    }
    for (m = 0; m < n; m++)
      paramstack[paramptr + m] = pstack[m];
    paramptr += n;
  }
_Lexit:
  scannerstatus = savescannerstatus;
  warningindex = savewarningindex;

  /*:397*/
  /*:395*/
}


/*:389*/
/*379:*/
Static void insertrelax(void)
{
  curtok = cstokenflag + curcs;
  backinput();
  curtok = cstokenflag + frozenrelax;
  backinput();
  tokentype = inserted;
}  /*:379*/


Static void passtext(void);

Static void startinput(void);

Static void conditional(void);

Static void getxtoken(void);

Static void convtoks(void);

Static void insthetoks(void);


Static void expand(void)
{
  halfword t;
  pointer p, r, backupbackup;
  short j;
  long cvbackup;
  smallnumber cvlbackup, radixbackup, cobackup, savescannerstatus;

  cvbackup = curval;
  cvlbackup = curvallevel;
  radixbackup = radix;
  cobackup = curorder;

  backupbackup = link(backuphead);

  if (curcmd < call) {   /*367:*/
    if (tracingcommands > 1)
      showcurcmdchr();
    switch (curcmd) {

    case topbotmark:   /*386:*/
      if (curmark[curchr - topmarkcode] != 0)
	begintokenlist(curmark[curchr - topmarkcode], marktext);
      break;
      /*:386*/

    case expandafter:   /*368:*/
      gettoken();
      t = curtok;
      gettoken();
      if (curcmd > maxcommand)
	expand();
      else
	backinput();
      curtok = t;
      backinput();
      break;
      /*:368*/

    case noexpand:   /*369:*/
      savescannerstatus = scannerstatus;
      scannerstatus = normal;
      gettoken();
      scannerstatus = savescannerstatus;
      t = curtok;
      backinput();
      if (t >= cstokenflag) {
	p = getavail();
	info(p) = cstokenflag + frozendontexpand;
	link(p) = loc;
	start = p;
	loc = p;
      }
      break;
      /*:369*/

    case csname:   /*372:*/
      r = getavail();
      p = r;
      do {
	getxtoken();
	if (curcs == 0) {
	  storenewtoken(p,curtok);
	}
      } while (curcs == 0);
      if (curcmd != endcsname) {   /*373:*/
	printnl(S("! "));
	print(S("Missing "));
	printesc(S("endcsname"));
	print(S(" inserted"));
	help2(S("The control sequence marked <to be read again> should"),S("not appear between \\csname and \\endcsname."));
	backerror();
      }
      /*:373*/
      /*374:*/
      j = first;
      p = link(r);
      while (p != 0) {
	if (j >= maxbufstack) {
	  maxbufstack = j + 1;
	  if (maxbufstack == bufsize)
	    overflow(S("buffer size"), bufsize);
	}
	buffer[j] = (info(p)) & (dwa_do_8-1);
	j++;
	p = link(p);
      }
      if (j > first + 1) {
/*	nonewcontrolsequence = false; 
*/
	curcs = idlookup_p(buffer+first, j - first,false);
/*
	nonewcontrolsequence = true;
*/
      } else if (j == first)
	curcs = nullcs;
      else
	curcs = singlebase + buffer[first];   /*:374*/
      flushlist(r);
      if (eqtype(curcs) == undefinedcs)
	eqdefine(curcs, relax, 256);
      curtok = curcs + cstokenflag;
      backinput();
      break;
      /*:372*/

    case convert:
      convtoks();
      break;

    case the:
      insthetoks();
      break;

    case iftest:
      conditional();
      break;

    case fiorelse:   /*510:*/
      if (curchr > iflimit) {
	if (iflimit == ifcode)
	  insertrelax();
	else {
	  printnl(S("! "));
	  print(S("Extra "));
	  printcmdchr(fiorelse, curchr);
	  help1(S("I'm ignoring this; it doesn't match any \\if."));
	  error();
	}
      } else {   /*:510*/
	while (curchr != ficode)   /*496:*/
	  passtext();
	p = condptr;
	ifline = iflinefield(p);
	curif = subtype(p);
	iflimit = type(p);
	condptr = link(p);
	freenode(p, ifnodesize);   /*:496*/
      }
      break;

    case input:   /*378:*/
      if (curchr > 0)
	forceeof = true;
      else if (nameinprogress)
	insertrelax();
      else
	startinput();
      break;
      /*370:*/

    default:
      printnl(S("! "));
      print(S("Undefined control sequence"));
      help5(S("The control sequence at the end of the top line"),S("of your error message was never \\def'ed. If you have"),S("misspelled it (e.g., `\\hobx'), type `I' and the correct"),S("spelling (e.g., `I\\hbox'). Otherwise just continue,"),S("and I'll forget about whatever was undefined."));
      error();   /*:370*/
      break;
    }
  }  /*:367*/
  else if (curcmd < endtemplate)
    macrocall();
  else {
    curtok = cstokenflag + frozenendv;
    backinput();
  }
  curval = cvbackup;
  curvallevel = cvlbackup;
  radix = radixbackup;
  curorder = cobackup;

  link(backuphead) = backupbackup;

  /*:378*/
  /*375:*/
  /*:375*/
}


/*:366*/
/*380:*/
#if 1
#if 0
/* Despite comment from Knuth does not work */
Static void xtoken(void);

Static void getxtoken(void)
{
  getnext();
  xtoken();
}
#endif

Static void getxtoken(void)
{
_Lrestart:
  getnext();
  if (curcmd <= maxcommand)
    goto _Ldone;
  if (curcmd >= call) {
    if (curcmd >= endtemplate) {
      curcs = frozenendv;
      curcmd = endv;
      goto _Ldone;
    }
    macrocall();
  } else
    expand();
  goto _Lrestart;
_Ldone:
  pack_tok(curtok,curcs,curcmd,curchr);
}
#else 

Static void getxtoken(void)
{
  getnext();
  while (curcmd > maxcommand) {
    expand();
    getnext();
  }
  if (curcs == 0)
    curtok = curcmd * dwa_do_8 + curchr;
  else
    curtok = cstokenflag + curcs;
}

#endif


/*:380*/
/*381:*/
Static void xtoken(void)
{
  while (curcmd > maxcommand) {
    expand();
    getnext();
  }
  pack_tok(curtok,curcs,curcmd,curchr);
}

/*:381*/
/*403:*/
Static void scanleftbrace(void)
{  /*404:*/
  do {
    getxtoken();   /*:404*/
  } while (curcmd == spacer || curcmd == relax);
  if (curcmd == leftbrace)
    return;
  printnl(S("! "));
  print(S("Missing { inserted"));
  help4(S("A left brace was mandatory here, so I've put one in."),S("You might want to delete and/or insert some corrections"),S("so that I will find a matching right brace soon."),S("(If you're confused by all this, try typing `I}' now.)"));
  backerror();
  curtok = leftbracetoken + '{';
  curcmd = leftbrace;
  curchr = '{';
  alignstate++;
}


/*:403*/
/*405:*/
Static void scanoptionalequals(void)
{   /*406:*/
  do {
    getxtoken();   /*:406*/
  } while (curcmd == spacer);
  if (curtok != othertoken + '=')
    backinput();
}


/*:405*/
/*407:*/
Static boolean scankeyword(strnumber s)
{
  boolean Result;
#if 1
  pointer p = getavail();
  pointer my_backup_head = p;
#else
  pointer my_backup_head = backuphead;
  pointer p = backuphead;
#endif
#if 0
  poolpointer k;
#else 
  int k;
  int k_e;
#endif
  link(p) = 0;
#if 0
  k = strstart[s];
  while (k < str_end(s) ) {
    getxtoken();
    if ((curcs == 0) & ((curchr == strpool[k]) |
			(curchr == strpool[k] - 'a' + 'A'))) {
#else
  k=0;
  k_e=flength(s);
  while(k<k_e) {
    int str_c = str_getc(s,k);
    getxtoken();
    if ((curcs == 0) & ((curchr == str_c) |
                        (curchr == str_c - 'a' + 'A'))) {
#endif
      storenewtoken(p,curtok);
      k++;
      continue;
    } else {
      if (curcmd == spacer && p == my_backup_head)
	continue;
      backinput();
      if (p != my_backup_head) {
	backlist(link(my_backup_head));
      }
      Result = false;
      goto _Lexit;
    }
  }
  flushlist(link(my_backup_head));
  Result = true;
_Lexit:

  freeavail(my_backup_head); 

  return Result;
}

/*:407*/
/*408:*/
Static void muerror(void)
{
  printnl(S("! "));
  print(S("Incompatible glue units"));
  help1(S("I'm going to assume that 1mu=1pt when they're mixed."));
  error();
}


/*:408*/
/*409:*/
Static void scanint(void);


/*433:*/
Static void scaneightbitint(void)
{
  scanint();
  if ((unsigned long)curval <= 255)
    return;
  printnl(S("! "));
  print(S("Bad register code"));
  help2(S("A register number must be between 0 and 255."),S("I changed this one to zero."));
  interror(curval);
  curval = 0;
}


/*:433*/
/*434:*/
Static void scancharnum(void)
{
  scanint();
  if ((unsigned long)curval <= 255)
    return;
  printnl(S("! "));
  print(S("Bad character code"));
  help2(S("A character number must be between 0 and 255."),S("I changed this one to zero."));
  interror(curval);
  curval = 0;
}


/*:434*/
/*435:*/
Static void scanfourbitint(void)
{
  scanint();
  if ((unsigned long)curval <= 15)
    return;
  printnl(S("! "));
  print(S("Bad number"));
  help2(S("Since I expected to read a number between 0 and 15,"),S("I changed this one to zero."));
  interror(curval);
  curval = 0;
}


/*:435*/
/*436:*/
Static void scanfifteenbitint(void)
{
  scanint();
  if ((unsigned long)curval <= 32767)
    return;
  printnl(S("! "));
  print(S("Bad mathchar"));
  help2(S("A mathchar number must be between 0 and 32767."),S("I changed this one to zero."));
  interror(curval);
  curval = 0;
}


/*:436*/
/*437:*/
Static void scantwentysevenbitint(void)
{
  scanint();
  if ((unsigned long)curval <= 134217727L)
    return;
  printnl(S("! "));
  print(S("Bad delimiter code"));
  help2(S("A numeric delimiter code must be between 0 and 2^{27}-1."),S("I changed this one to zero."));
  interror(curval);
  curval = 0;
}


/*:437*/
/*577:*/
Static void scanfontident(void)
{   /*406:*/
  internalfontnumber f;
  halfword m;

  do {
    getxtoken();   /*:406*/
  } while (curcmd == spacer);
  if (curcmd == deffont)
    f = curfont;
  else if (curcmd == setfont)
    f = curchr;
  else if (curcmd == deffamily) {
    m = curchr;
    scanfourbitint();
    f = equiv(m + curval);
  } else {
    printnl(S("! "));
    print(S("Missing font identifier"));
    help2(S("I was looking for a control sequence whose"),S("current meaning has been defined by \\font."));
    backerror();
    f = nullfont;
  }
  curval = f;
}


/*:577*/
/*578:*/
Static void findfontdimen(boolean writing)
{
  internalfontnumber f;
  long n;

  scanint();
  n = curval;
  scanfontident();
  f = curval;
  if (n <= 0)
    curval = fmemptr;
  else {
    if (writing && n <= spaceshrinkcode && n >= spacecode &&
	fontglue[f ] != 0) {
      deleteglueref(fontglue[f ]);
      fontglue[f ] = 0;
    }
    if (n > fontparams[f ]) {
      if (f < fontptr)
	curval = fmemptr;
      else  /*580:*/
      {   /*:580*/
	do {
	  if (fmemptr == fontmemsize)
	    overflow(S("font memory"), fontmemsize);
	  fontinfo[fmemptr].sc = 0;
	  fmemptr++;
	  fontparams[f ]++;
	} while (n != fontparams[f ]);
	curval = fmemptr - 1;
      }
    } else
      curval = n + parambase[f ];
  }  /*579:*/
  if (curval != fmemptr)   /*:579*/
    return;
  printnl(S("! "));
  print(S("Font "));
  printesc(fontidtext(f));
  print(S(" has only "));
  printint(fontparams[f ]);
  print(S(" fontdimen parameters"));
  help2(S("To increase the number of font parameters, you must"),S("use \\fontdimen immediately after the \\font is loaded."));
  error();
}


/*:578*/
/*:409*/
/*413:*/
Static void scansomethinginternal(smallnumber level, boolean negative)
{
  halfword m;
  /* char */ int p; /* INT */

  m = curchr;
  switch (curcmd) {

  case defcode:   /*414:*/
    scancharnum();
    if (m == mathcodebase) {
      curval = mathcode(curval);
      curvallevel = intval;
    } else if (m < mathcodebase) {
      curval = equiv(m + curval);
      curvallevel = intval;
    } else {
      curval = eqtb[m + curval - activebase].int_;
      curvallevel = intval;
    }
    break;
    /*:414*/

  case toksregister:
  case assigntoks:
  case deffamily:
  case setfont:
  case deffont:   /*415:*/
    if (level != tokval) {
      printnl(S("! "));
      print(S("Missing number, treated as zero"));
      help3(S("A number should have been here; I inserted `0'."),S("(If you can't figure out why I needed to see a number,"),S("look up `weird error' in the index to The TeXbook.)"));
      backerror();
      curval = 0;
      curvallevel = dimenval;
    } else if (curcmd <= assigntoks) {
      if (curcmd < assigntoks) {
	scaneightbitint();
	m = toksbase + curval;
      }
      curval = equiv(m);
      curvallevel = tokval;
    } else {
      backinput();
      scanfontident();
      curval += fontidbase;
      curvallevel = identval;
    }
    break;

  case assignint:
    curval = eqtb[m - activebase].int_;
    curvallevel = intval;
    break;

  case assigndimen:
    curval = eqtb[m - activebase].sc;
    curvallevel = dimenval;
    break;

  case assignglue:
    curval = equiv(m);
    curvallevel = glueval;
    break;

  case assignmuglue:
    curval = equiv(m);
    curvallevel = muval;
    break;

  case setaux:   /*418:*/
    if (labs(mode) != m) {
      printnl(S("! "));
      print(S("Improper "));
      printcmdchr(setaux, m);
      help4(S("You can refer to \\spacefactor only in horizontal mode;"),S("you can refer to \\prevdepth only in vertical mode; and"),S("neither of these is meaningful inside \\write. So"),S("I'm forgetting what you said and using zero instead."));
      error();
      if (level != tokval) {
	curval = 0;
	curvallevel = dimenval;
      } else {
	curval = 0;
	curvallevel = intval;
      }
    } else if (m == vmode) {
      curval = prevdepth;
      curvallevel = dimenval;
    } else {
      curval = spacefactor;
      curvallevel = intval;
    }
    break;

  case setprevgraf:   /*422:*/
    if (mode == 0) {
      curval = 0;
      curvallevel = intval;
    } else {   /*:422*/
      nest[nestptr] = curlist;
      p = nestptr;
      while (abs(nest[p].modefield) != vmode)
	p--;
      curval = nest[p].pgfield;
      curvallevel = intval;
    }
    break;

  case setpageint:   /*419:*/
    if (m == 0)
      curval = deadcycles;
    else
      curval = insertpenalties;
    curvallevel = intval;
    break;
    /*:419*/

  case setpagedimen:   /*421:*/
    if (pagecontents == empty && !outputactive) {
      if (m == 0)
	curval = maxdimen;
      else
	curval = 0;
    } else
      curval = pagesofar[m];
    curvallevel = dimenval;
    break;
    /*:421*/

  case setshape:   /*423:*/
    if (parshapeptr == 0)
      curval = 0;
    else
      curval = info(parshapeptr);
    curvallevel = intval;
    break;
    /*:423*/

  case setboxdimen:   /*420:*/
    scaneightbitint();
    if (box(curval) == 0)
      curval = 0;
    else
      curval = mem[box(curval) + m - memmin].sc;
    curvallevel = dimenval;
    break;
    /*:420*/

  case chargiven:
  case mathgiven:
    curval = curchr;
    curvallevel = intval;
    break;

  case assignfontdimen:   /*425:*/
    findfontdimen(false);
    fontinfo[fmemptr].sc = 0;
    curval = fontinfo[curval].sc;
    curvallevel = dimenval;
    break;
    /*:425*/

  case assignfontint:   /*426:*/
    scanfontident();
    if (m == 0) {
      curval = hyphenchar[curval ];
      curvallevel = intval;
    } else {
      curval = skewchar[curval ];
      curvallevel = intval;
    }
    break;
    /*:426*/

  case register_:   /*427:*/
    scaneightbitint();
    switch (m) {

    case intval:
      curval = count(curval);
      break;

    case dimenval:
      curval = dimen(curval);
      break;

    case glueval:
      curval = skip(curval);
      break;

    case muval:
      curval = muskip(curval);
      break;
    }
    curvallevel = m;
    break;
    /*:427*/

  case lastitem:   /*424:*/
    if (curchr > glueval) {
      if (curchr == inputlinenocode)
	curval = line;
      else
	curval = lastbadness;
      curvallevel = intval;
    } else {   /*:424*/
      if (curchr == glueval)
	curval = zeroglue;
      else
	curval = 0;
      curvallevel = curchr;
      if (!ischarnode(tail) && mode != 0) {
	switch (curchr) {

	case intval:
	  if (type(tail) == penaltynode)
	    curval = penalty(tail);
	  break;

	case dimenval:
	  if (type(tail) == kernnode)
	    curval = width(tail);
	  break;

	case glueval:
	  if (type(tail) == gluenode) {
	    curval = glueptr(tail);
	    if (subtype(tail) == muglue)
	      curvallevel = muval;
	  }
	  break;
	}
      } else if (mode == vmode && tail == head) {
	switch (curchr) {

	case intval:
	  curval = lastpenalty;
	  break;

	case dimenval:
	  curval = lastkern;
	  break;

	case glueval:
	  if (lastglue != maxhalfword)
	    curval = lastglue;
	  break;
	}
      }
    }
    break;
    /*428:*/

  default:
    printnl(S("! "));
    print(S("You can't use `"));
    printcmdchr(curcmd, curchr);
    print(S("' after "));
    printesc(S("the"));
    help1(S("I'm forgetting what you said and using zero instead."));
    error();
    if (level != tokval) {   /*:428*/
      curval = 0;
      curvallevel = dimenval;
    } else {
      curval = 0;
      curvallevel = intval;
    }
    break;
  }
  while (curvallevel > level) {   /*429:*/
    if (curvallevel == glueval)
      curval = width(curval);
    else if (curvallevel == muval)
      muerror();
    curvallevel--;
  }
  /*:429*/
  /*430:*/
  if (!negative) {
    if (curvallevel >= glueval && curvallevel <= muval) {
      addglueref(curval);   /*:430*/
    }
    return;
  }
  if (curvallevel < glueval) {
    curval = -curval;
    return;
  }
  curval = newspec(curval);   /*431:*/
  width(curval) = -width(curval);
  stretch(curval) = -stretch(curval);
  shrink(curval) = -shrink(curval);   /*:431*/

  /*:415*/
  /*:418*/
}


/*:413*/
/*440:*/
Static void scanint(void)
{
  boolean negative;
  long m;
  smallnumber d;
  boolean vacuous, OKsofar;

  radix = 0;
  OKsofar = true;   /*441:*/
  negative = false;
  do {   /*406:*/
    do {
      getxtoken();   /*:406*/
    } while (curcmd == spacer);
    if (curtok == othertoken + '-') {   /*:441*/
      negative = !negative;
      curtok = othertoken + '+';
    }
  } while (curtok == othertoken + '+');
  if (curtok == alphatoken) {   /*442:*/
    gettoken();
    if (curtok < cstokenflag) {
      curval = curchr;
      if (curcmd <= rightbrace) {
	if (curcmd == rightbrace)
	  alignstate++;
	else
	  alignstate--;
      }
    } else if (curtok < cstokenflag + singlebase)
      curval = curtok - cstokenflag - activebase;
    else
      curval = curtok - cstokenflag - singlebase;
    if (curval > 255) {
      printnl(S("! "));
      print(S("Improper alphabetic constant"));
      help2(S("A one-character control sequence belongs after a ` mark."),S("So I'm essentially inserting \\0 here."));
      curval = '0';
      backerror();
    } else {   /*443:*/
      getxtoken();
      if (curcmd != spacer)
	backinput();
    }
  }  /*:442*/
  else if (curcmd >= mininternal && curcmd <= maxinternal)
    scansomethinginternal(intval, false);
  else {
    radix = 10;
    m = 214748364L;
    if (curtok == octaltoken) {
      radix = 8;
      m = 268435456L;
      getxtoken();
    } else if (curtok == hextoken) {
      radix = 16;
      m = 134217728L;
      getxtoken();
    }
    vacuous = true;
    curval = 0;   /*445:*/
    while (true) {
      if (curtok < zerotoken + radix && curtok >= zerotoken &&
	  curtok <= zerotoken + 9)
	d = curtok - zerotoken;
      else if (radix == 16) {
	if (curtok <= Atoken + 5 && curtok >= Atoken)
	  d = curtok - Atoken + 10;
	else if (curtok <= otherAtoken + 5 && curtok >= otherAtoken)
	  d = curtok - otherAtoken + 10;
	else
	  goto _Ldone;
      } else
	goto _Ldone;
      vacuous = false;
      if (curval >= m && (curval > m || d > 7 || radix != 10)) {
	if (OKsofar) {
	  printnl(S("! "));
	  print(S("Number too big"));
	  help2(S("I can only go up to 2147483647='17777777777=\"7FFFFFFF,"),S("so I'm using that number instead of yours."));
	  error();
	  curval = infinity;
	  OKsofar = false;
	}
      } else
	curval = curval * radix + d;
      getxtoken();
    }
_Ldone:   /*:445*/
    if (vacuous) {   /*446:*/
      printnl(S("! "));
      print(S("Missing number, treated as zero"));
      help3(S("A number should have been here; I inserted `0'."),S("(If you can't figure out why I needed to see a number,"),S("look up `weird error' in the index to The TeXbook.)"));
      backerror();
    }  /*:446*/
    else if (curcmd != spacer)
      backinput();
  }
  if (negative)
    curval = -curval;

  /*:443*/
  /*444:*/
  /*:444*/
}


/*:440*/
/*448:*/
Static void scandimen(boolean mu, boolean inf, boolean shortcut)
{
  boolean negative;
  long f;
  /*450:*/
  long num, denom;
  /* smallnumber */ int k, kk; /* INT */
  pointer p, q;
  scaled v;
  long savecurval;   /*:450*/
  char digs[23];

  f = 0;
  aritherror = false;
  curorder = normal;
  negative = false;
  if (!shortcut) {   /*441:*/
    negative = false;
    do {   /*406:*/
      do {
	getxtoken();   /*:406*/
      } while (curcmd == spacer);
      if (curtok == othertoken + '-') {   /*:441*/
	negative = !negative;
	curtok = othertoken + '+';
      }
    } while (curtok == othertoken + '+');
    if (curcmd >= mininternal && curcmd <= maxinternal) {   /*449:*/
      if (mu) {
	scansomethinginternal(muval, false);   /*451:*/
	if (curvallevel >= glueval) {   /*:451*/
	  v = width(curval);
	  deleteglueref(curval);
	  curval = v;
	}
	if (curvallevel == muval)
	  goto _Lattachsign_;
	if (curvallevel != intval)
	  muerror();
      } else {
	scansomethinginternal(dimenval, false);
	if (curvallevel == dimenval)
	  goto _Lattachsign_;
      }  /*:449*/
    } else {
      backinput();
      if (curtok == continentalpointtoken)
	curtok = pointtoken;
      if (curtok != pointtoken)
	scanint();
      else {
	radix = 10;
	curval = 0;
      }
      if (curtok == continentalpointtoken)
	curtok = pointtoken;
      if (radix == 10 && curtok == pointtoken) {   /*452:*/
	k = 0;
	p = 0;
	gettoken();
	while (true) {
	  getxtoken();
	  if (curtok > zerotoken + 9 || curtok < zerotoken)
	    goto _Ldone1;
	  if (k >= 17)
	    continue;
	  q = getavail();
	  link(q) = p;
	  info(q) = curtok - zerotoken;
	  p = q;
	  k++;
	}
_Ldone1:
	for (kk = k - 1; kk >= 0; kk--) {
	  digs[kk] = info(p);
	  q = p;
	  p = link(p);
	  freeavail(q);
	}
	f = rounddecimals(k,digs);
	if (curcmd != spacer)
	  backinput();
      }
      /*:452*/
    }
  }
  if (curval < 0) {
    negative = !negative;
    curval = -curval;
  }  /*453:*/
  if (inf) {   /*454:*/
    if (scankeyword(S("fil"))) {   /*:454*/
      curorder = fil;
      while (scankeyword('l')) {
	if (curorder != filll) {
	  curorder++;
	  continue;
	}
	printnl(S("! "));
	print(S("Illegal unit of measure ("));
	print(S("replaced by filll)"));
	help1(S("I dddon't go any higher than filll."));
	error();
      }
      goto _Lattachfraction_;
    }
  }
  /*455:*/
  savecurval = curval;   /*406:*/
  do {
    getxtoken();   /*:406*/
  } while (curcmd == spacer);
  if (curcmd >= mininternal && curcmd <= maxinternal) {
    if (mu) {
      scansomethinginternal(muval, false);   /*451:*/
      if (curvallevel >= glueval) {   /*:451*/
	v = width(curval);
	deleteglueref(curval);
	curval = v;
      }
      if (curvallevel != muval)
	muerror();
    } else
      scansomethinginternal(dimenval, false);
    v = curval;
    goto _Lfound;
  }
  backinput();
  if (mu)
    goto _Lnotfound;
  if (scankeyword(S("em")))   /*443:*/
    v = quad(curfont);   /*558:*/
    /*:558*/
  else if (scankeyword(S("ex")))
    v = xheight(curfont);   /*559:*/
    /*:559*/
  else
    goto _Lnotfound;
  getxtoken();
  if (curcmd != spacer)   /*:443*/
    backinput();
_Lfound:
  curval = multandadd(savecurval, v, xnoverd(v, f, 65536L), 1073741823L);
  goto _Lattachsign_;
_Lnotfound:   /*:455*/
  if (mu) {   /*456:*/
    if (scankeyword(S("mu")))
      goto _Lattachfraction_;
    else {   /*:456*/
      printnl(S("! "));
      print(S("Illegal unit of measure ("));
      print(S("mu inserted)"));
      help4(S("The unit of measurement in math glue must be mu."),S("To recover gracefully from this error, it's best to"),S("delete the erroneous units; e.g., type `2' to delete"),S("two letters. (See Chapter 27 of The TeXbook.)"));
      error();
      goto _Lattachfraction_;
    }
  }
  if (scankeyword(S("true"))) {   /*457:*/
    preparemag();
    if (mag != 1000) {
      curval = xnoverd(curval, 1000, mag);
      f = (f * 1000 + texremainder * 65536L) / mag;
      curval += f / 65536L;
      f %= 65536L;
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
    }
  }
  /*:457*/
  if (scankeyword(S("pt")))   /*458:*/
    goto _Lattachfraction_;
  if (scankeyword(S("in"))) {
    num = 7227;
    denom = 100;
  } else if (scankeyword(S("pc"))) {
    num = 12;
    denom = 1;
  } else if (scankeyword(S("cm"))) {
    num = 7227;
    denom = 254;
  } else if (scankeyword(S("mm"))) {
    num = 7227;
    denom = 2540;
  } else if (scankeyword(S("bp"))) {
    num = 7227;
    denom = 7200;
  } else if (scankeyword(S("dd"))) {
    num = 1238;
    denom = 1157;
  } else if (scankeyword(S("cc"))) {
    num = 14856;
    denom = 1157;
  } else if (scankeyword(S("sp")))
    goto _Ldone;
  else {
    printnl(S("! "));
    print(S("Illegal unit of measure ("));
    print(S("pt inserted)"));
    help6(S("Dimensions can be in units of em, ex, in, pt, pc,"),S("cm, mm, dd, cc, bp, or sp; but yours is a new one!"),S("I'll assume that you meant to say pt, for printer's points."),S("To recover gracefully from this error, it's best to"),S("delete the erroneous units; e.g., type `2' to delete"),S("two letters. (See Chapter 27 of The TeXbook.)"));
    error();
    goto _Ldone2;
  }
  curval = xnoverd(curval, num, denom);
  f = (num * f + texremainder * 65536L) / denom;
  curval += f / 65536L;
  f %= 65536L;
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
_Ldone2:   /*:458*/
_Lattachfraction_:
  if (curval >= 16384)
    aritherror = true;
  else
    curval = curval * unity + f;
_Ldone:   /*:453*/
  /*443:*/
  getxtoken();
  if (curcmd != spacer)   /*:443*/
    backinput();
_Lattachsign_:
  if (aritherror || labs(curval) >= 1073741824L) {   /*460:*/
    printnl(S("! "));
    print(S("Dimension too large"));
    help2(S("I can't work with sizes bigger than about 19 feet."),S("Continue and I'll use the largest value I can."));
    error();
    curval = maxdimen;
    aritherror = false;
  }
  /*:460*/
  if (negative)
    curval = -curval;

  /*459:*/
  /*:459*/
}


/*:448*/
/*461:*/
Static void scanglue(smallnumber level)
{
  boolean negative, mu;
  pointer q;

  mu = (level == muval);   /*441:*/
  negative = false;
  do {   /*406:*/
    do {
      getxtoken();   /*:406*/
    } while (curcmd == spacer);
    if (curtok == othertoken + '-') {   /*:441*/
      negative = !negative;
      curtok = othertoken + '+';
    }
  } while (curtok == othertoken + '+');
  if (curcmd >= mininternal && curcmd <= maxinternal) {   /*462:*/
    scansomethinginternal(level, negative);
    if (curvallevel >= glueval) {
      if (curvallevel != level)
	muerror();
      goto _Lexit;
    }
    if (curvallevel == intval)
      scandimen(mu, false, true);
    else if (level == muval)
      muerror();
  } else {
    backinput();
    scandimen(mu, false, false);
    if (negative)
      curval = -curval;
  }
  q = newspec(zeroglue);
  width(q) = curval;
  if (scankeyword(S("plus"))) {
    scandimen(mu, true, false);
    stretch(q) = curval;
    stretchorder(q) = curorder;
  }
  if (scankeyword(S("minus"))) {
    scandimen(mu, true, false);
    shrink(q) = curval;
    shrinkorder(q) = curorder;
  }
  curval = q;   /*:462*/
_Lexit: ;
}


/*:461*/
/*463:*/
Static halfword scanrulespec(void)
{
  pointer q;

  q = newrule();
  if (curcmd == vrule)
    width(q) = defaultrule;
  else {
    height(q) = defaultrule;
    depth(q) = 0;
  }
_Lreswitch:
  if (scankeyword(S("width"))) {
    scannormaldimen();
    width(q) = curval;
    goto _Lreswitch;
  }
  if (scankeyword(S("height"))) {
    scannormaldimen();
    height(q) = curval;
    goto _Lreswitch;
  }
  if (!scankeyword(S("depth")))
    return q;
  scannormaldimen();
  depth(q) = curval;
  goto _Lreswitch;
/* p2c: tex1.p: Note: Deleting unreachable code [255] */
}


/*:463*/
/*464:*/

pointer tex_global_p;

Static void strtoks_helper(strASCIIcode t)
{
    long tt=t;
    pointer p=tex_global_p;
    if (tt == ' ')
      tt = spacetoken;
    else
      tt += othertoken;
    faststorenewtoken(p,tt);
    tex_global_p=p;
}

Static halfword strtoks(str_poolpointer b)
{
  pointer p;
  str_room(1);
  p = temphead;
  link(p) = 0;
  tex_global_p=p;
  str_map_from_mark(b, strtoks_helper); 
  p=tex_global_p;
  return p;
}

/*:464*/
/*465:*/
Static halfword thetoks(void)
{
  char oldsetting;
  pointer p, r;

  getxtoken();
  scansomethinginternal(tokval, false);
  if (curvallevel >= identval) {   /*466:*/
    p = temphead;
    link(p) = 0;
    if (curvallevel == identval) {
      storenewtoken(p,cstokenflag + curval);
      return p;
    }
    if (curval == 0)
      return p;
    r = link(curval);
    while (r != 0) {
      faststorenewtoken(p,info(r));
      r = link(r);
    }
    return p;
  } else {
#if 0
    poolpointer b = poolptr;
#else
    str_poolpointer b = str_mark();
#endif
    oldsetting = selector;
    selector = newstring;
    switch (curvallevel) {

    case intval:
      printint(curval);
      break;

    case dimenval:
      printscaled(curval);
      print(S("pt"));
      break;

    case glueval:
      printspec(curval, S("pt"));
      deleteglueref(curval);
      break;

    case muval:
      printspec(curval, S("mu"));
      deleteglueref(curval);
      break;
    }
    selector = oldsetting;
/*	fprintf(stderr,"(%d %d)",bb-b,poolptr-b); */
    return (strtoks(b));
  }
  /*:466*/
}

/*:465*/
/*467:*/
Static void insthetoks(void)
{
  link(garbage) = thetoks();
  inslist(link(temphead));
}  /*:467*/


/*470:*/
Static void convtoks(void)
{
  char oldsetting;
  char c;
  smallnumber savescannerstatus;
  str_poolpointer b;

  c = curchr;   /*471:*/
  switch (c) {   /*:471*/

  case numbercode:
  case romannumeralcode:
    scanint();
    break;

  case stringcode:
  case meaningcode:
    savescannerstatus = scannerstatus;
    scannerstatus = normal;
    gettoken();
    scannerstatus = savescannerstatus;
    break;

  case fontnamecode:
    scanfontident();
    break;

  case jobnamecode:
    if (jobname == 0)
      openlogfile();
    break;
  }
  oldsetting = selector;
  selector = newstring;
#if 0
  b = poolptr; 
#else
  b = str_mark();
#endif
  /*472:*/
  switch (c) {   /*:472*/

  case numbercode:
    printint(curval);
    break;

  case romannumeralcode:
    printromanint(curval);
    break;

  case stringcode:
    if (curcs != 0)
      sprintcs(curcs);
    else
      printchar(curchr);
    break;

  case meaningcode:
    printmeaning();
    break;

  case fontnamecode:
    print(fontname[curval ]);
    if (fontsize[curval ] != fontdsize[curval ]) {
      print(S(" at "));
      printscaled(fontsize[curval ]);
      print(S("pt"));
    }
    break;

  case jobnamecode:
    print(jobname);
    break;
  }
  selector = oldsetting;
  link(garbage) = strtoks(b);
  inslist(link(temphead));
}  /*:470*/

/*473:*/
Static halfword scantoks(boolean macrodef, boolean xpand)
{
  halfword t, s, unbalance, hashbrace;
  pointer p;

  if (macrodef)
    scannerstatus = defining;
  else
    scannerstatus = absorbing;
  warningindex = curcs;
  defref = getavail();
  tokenrefcount(defref) = 0;
  p = defref;
  hashbrace = 0;
  t = zerotoken;
  if (macrodef) {   /*474:*/
    while (true) {
      gettoken();
      if (curtok < rightbracelimit)
	goto _Ldone1;
      if (curcmd == macparam) {   /*476:*/
	s = matchtoken + curchr;
	gettoken();
	if (curcmd == leftbrace) {
	  hashbrace = curtok;
	  storenewtoken(p,curtok);
	  storenewtoken(p,endmatchtoken);
	  goto _Ldone;
	}
	if (t == zerotoken + 9) {
	  printnl(S("! "));
	  print(S("You already have nine parameters"));
	  help1(S("I'm going to ignore the # sign you just used."));
	  error();
	} else {
	  t++;
	  if (curtok != t) {
	    printnl(S("! "));
	    print(S("Parameters must be numbered consecutively"));
	    help2(S("I've inserted the digit you should have used after the #."),S("Type `1' to delete what you did use."));
	    backerror();
	  }
	  curtok = s;
	}
      }
      /*:476*/
      storenewtoken(p,curtok);
    }
_Ldone1:
    storenewtoken(p,endmatchtoken);
    if (curcmd == rightbrace) {   /*475:*/
      printnl(S("! "));
      print(S("Missing { inserted"));
      alignstate++;
      help2(S("Where was the left brace? You said something like `\\def\\a}',"),S("which I'm going to interpret as `\\def\\a{}'."));
      error();
      goto _Lfound;
    }
    /*:475*/
_Ldone: ;
  } else
    scanleftbrace();
  /*:474*/
  /*477:*/
  unbalance = 1;
  while (true) {   /*:477*/
    if (xpand) {   /*478:*/
      while (true) {
	getnext();
	if (curcmd <= maxcommand)
	  goto _Ldone2;
	if (curcmd != the)
	  expand();
	else {
	  pointer q = thetoks();
	  if (link(temphead) != 0) {
	    link(p) = link(temphead);
	    p = q;
	  }
	}
      }
_Ldone2:
      xtoken();
    } else
      gettoken();
    /*:478*/
    if (curtok < rightbracelimit) {
      if (curcmd < rightbrace)
	unbalance++;
      else {
	unbalance--;
	if (unbalance == 0)
	  goto _Lfound;
      }
    } else if (curcmd == macparam) {
      if (macrodef) {   /*479:*/
	s = curtok;
	if (xpand)
	  getxtoken();
	else
	  gettoken();
	if (curcmd != macparam) {
	  if (curtok <= zerotoken || curtok > t) {
	    printnl(S("! "));
	    print(S("Illegal parameter number in definition of "));
	    sprintcs(warningindex);
	    help3(S("You meant to type ## instead of #, right?"),S("Or maybe a } was forgotten somewhere earlier, and things"),S("are all screwed up? I'm going to assume that you meant ##."));
	    backerror();
	    curtok = s;
	  } else
	    curtok = outparamtoken - '0' + curchr;
	}
      }
      /*:479*/
    }
    storenewtoken(p,curtok);
  }
_Lfound:
  scannerstatus = normal;
  if (hashbrace != 0) {
    storenewtoken(p,hashbrace);
  }
  return p;
}  /*:473*/


/*482:*/
Static void readtoks(long n, halfword r)
{
  pointer p;
  long s;
  /* smallnumber */ int m; /* INT */

  scannerstatus = defining;
  warningindex = r;
  defref = getavail();
  tokenrefcount(defref) = 0;
  p = defref;
  storenewtoken(p,endmatchtoken);
  if ((unsigned long)n > 15)
    m = 16;
  else
    m = n;
  s = alignstate;
  alignstate = 1000000L;
  do {   /*483:*/
    beginfilereading();
    name = m + 1;
    if (readopen[m] == closed) {   /*484:*/
      if (interaction > nonstopmode) {
	if (n < 0) {
	  print(S(""));
	  terminput();
	} else {
	  println();
	  sprintcs(r);
	  print('=');
	  terminput();
	  n = -1;
	}
      } else   /*:484*/
	fatalerror(S("*** (cannot \\read from terminal in nonstop modes)"));
    } else if (readopen[m] == justopen) {
      if (inputln(&readfile[m], false))
	readopen[m] = normal;
      else {   /*:485*/
	aclose(&readfile[m]);
	readopen[m] = closed;
      }
    } else {
      if (!inputln(&readfile[m], true)) {
	aclose(&readfile[m]);
	readopen[m] = closed;
	if (alignstate != 1000000L) {
	  runaway();
	  printnl(S("! "));
	  print(S("File ended within "));
	  printesc(S("read"));
	  help1(S("This \\read has unbalanced braces."));
	  alignstate = 1000000L;
	  error();
	}
      }
    }
    limit = last;
    if (endlinecharinactive) {
      limit--;
    } else
      buffer[limit] = endlinechar;
    first = limit + 1;
    loc = start;
    state = newline;
    while (true) {
      gettoken();
      if (curtok == 0)
	goto _Ldone;
      if (alignstate < 1000000L) {
	do {
	  gettoken();
	} while (curtok != 0);
	alignstate = 1000000L;
	goto _Ldone;
      }
      storenewtoken(p,curtok);
    }
_Ldone:   /*:483*/
    endfilereading();
  } while (alignstate != 1000000L);
  curval = defref;
  scannerstatus = normal;
  alignstate = s;

  /*485:*/
  /*486:*/
  /*:486*/
}


/*:482*/
/*494:*/
Static void passtext(void)
{
  long l;
  smallnumber savescannerstatus;

  savescannerstatus = scannerstatus;
  scannerstatus = skipping;
  l = 0;
  skipline = line;
  while (true) {
    getnext();
    if (curcmd == fiorelse) {
      if (l == 0)
	goto _Ldone;
      if (curchr == ficode)
	l--;
    } else if (curcmd == iftest)
      l++;
  }
_Ldone:
  scannerstatus = savescannerstatus;
}


/*:494*/
/*497:*/
Static void changeiflimit(smallnumber l, halfword p)
{
  pointer q;

  if (p == condptr)
    iflimit = l;
  else {
    q = condptr;
    while (true) {
      if (q == 0)
	confusion(S("if"));
      if (link(q) == p) {
	type(q) = l;
	goto _Lexit;
      }
      q = link(q);
    }
  }
_Lexit: ;
}


/*:497*/
/*498:*/
Static void conditional(void)
{  /*495:*/
  boolean b=false /* XXXX */;
  long r;
  long m, n;
  pointer p, q, savecondptr;
  smallnumber savescannerstatus, thisif;

  p = getnode(ifnodesize);
  link(p) = condptr;
  type(p) = iflimit;
  subtype(p) = curif;
  iflinefield(p) = ifline;
  condptr = p;
  curif = curchr;
  iflimit = ifcode;
  ifline = line;   /*:495*/
  savecondptr = condptr;
  thisif = curchr;   /*501:*/
  switch (thisif) {   /*:501*/

  case ifcharcode:
  case ifcatcode:   /*506:*/
    getxtokenoractivechar();
    if (curcmd > activechar || curchr > 255) {
      m = relax;
      n = 256;
    } else {
      m = curcmd;
      n = curchr;
    }
    getxtokenoractivechar();
    if (curcmd > activechar || curchr > 255) {
      curcmd = relax;
      curchr = 256;
    }
    if (thisif == ifcharcode)
      b = (n == curchr);
    else
      b = (m == curcmd);
    break;
    /*:506*/

  case ifintcode:
  case ifdimcode:   /*503:*/
    if (thisif == ifintcode)
      scanint();
    else {
      scannormaldimen();
    }
    n = curval;
    /*406:*/
    do {
      getxtoken();
      /*:406*/
    } while (curcmd == spacer);
    if ((curtok >= othertoken + '<') & (curtok <= othertoken + '>'))
      r = curtok - othertoken;
    else {
      printnl(S("! "));
      print(S("Missing = inserted for "));
      printcmdchr(iftest, thisif);
      help1(S("I was expecting to see `<', `=', or `>'. Didn't."));
      backerror();
      r = '=';
    }
    if (thisif == ifintcode)
      scanint();
    else {
      scannormaldimen();
    }
    switch (r) {

    case '<':
      b = (n < curval);
      break;

    case '=':
      b = (n == curval);
      break;

    case '>':
      b = (n > curval);
      break;
    }
    break;
    /*:503*/

  case ifoddcode:   /*504:*/
    scanint();
    b = curval & 1;
    break;
    /*:504*/

  case ifvmodecode:
    b = (labs(mode) == vmode);
    break;

  case ifhmodecode:
    b = (labs(mode) == hmode);
    break;

  case ifmmodecode:
    b = (labs(mode) == mmode);
    break;

  case ifinnercode:
    b = (mode < 0);
    break;

  case ifvoidcode:
  case ifhboxcode:
  case ifvboxcode:   /*505:*/
    scaneightbitint();
    p = box(curval);
    if (thisif == ifvoidcode)
      b = (p == 0);
    else if (p == 0)
      b = false;
    else if (thisif == ifhboxcode)
      b = (type(p) == hlistnode);
    else
      b = (type(p) == vlistnode);
    break;
    /*:505*/

  case ifxcode:   /*507:*/
    savescannerstatus = scannerstatus;
    scannerstatus = normal;
    getnext();
    n = curcs;
    p = curcmd;
    q = curchr;
    getnext();
    if (curcmd != p)
      b = false;
    else if (curcmd < call)
      b = (curchr == q);
    else {
      /*
508:*/
      p = link(curchr);
      q = link(equiv(n));
      if (p == q)
	b = true;
      else {
	while (p != 0 && q != 0) {
	  if (info(p) != info(q))
	    p = 0;
	  else {
	    p = link(p);
	    q = link(q);
	  }
	}
	b = (p == 0 && q == 0);
      }
    }
    scannerstatus = savescannerstatus;
    break;
    /*:507*/

  case ifeofcode:
    scanfourbitint();
    b = (readopen[curval] == closed);
    break;

  case iftruecode:
    b = true;
    break;

  case iffalsecode:
    b = false;
    break;

  case ifcasecode:   /*509:*/
    scanint();
    n = curval;
    if (tracingcommands > 1) {
      begindiagnostic();
      print(S("{case "));
      printint(n);
      printchar('}');
      enddiagnostic(false);
    }
    while (n != 0) {
      passtext();
      if (condptr == savecondptr) {
	if (curchr != orcode)
	  goto _Lcommonending;
	n--;
	continue;
      }
      if (curchr != ficode)   /*496:*/
	continue;
      /*:496*/
      p = condptr;
      ifline = iflinefield(p);
      curif = subtype(p);
      iflimit = type(p);
      condptr = link(p);
      freenode(p, ifnodesize);
    }
    changeiflimit(orcode, savecondptr);
    goto _Lexit;
    break;
    /*:509*/
  }
  if (tracingcommands > 1) {   /*502:*/
    begindiagnostic();
    if (b)
      print(S("{true}"));
    else
      print(S("{false}"));
    enddiagnostic(false);
  }
  /*:502*/
  if (b) {
    changeiflimit(elsecode, savecondptr);
    goto _Lexit;
  }  /*500:*/
  while (true) {   /*:500*/
    passtext();
    if (condptr == savecondptr) {
      if (curchr != orcode)
	goto _Lcommonending;
      printnl(S("! "));
      print(S("Extra "));
      printesc(S("or"));
      help1(S("I'm ignoring this; it doesn't match any \\if."));
      error();
      continue;
    }
    if (curchr != ficode)   /*496:*/
      continue;
    /*:496*/
    p = condptr;
    ifline = iflinefield(p);
    curif = subtype(p);
    iflimit = type(p);
    condptr = link(p);
    freenode(p, ifnodesize);
  }
_Lcommonending:
  if (curchr == ficode) {   /*496:*/
    p = condptr;
    ifline = iflinefield(p);
    curif = subtype(p);
    iflimit = type(p);
    condptr = link(p);
    freenode(p, ifnodesize);
  }  /*:496*/
  else
    iflimit = ficode;
_Lexit: ;

  /*:508*/
}


/*:498*/
/*515:*/
Static void beginname(void)
{
#if 0
  areadelimiter = 0;
#endif
  extdelimiter = 0;
}


/*:515*/
/*516:*/
Static boolean morename(ASCIIcode c)
{
  if (c == ' ')
    return false;
  else {
    str_room(1);
#if 0
    appendchar(c);
    if ((c == '>') | (c == ':')) {
      areadelimiter = curlength;
      extdelimiter = 0;
    } else 
#endif
    if (c == '.' && extdelimiter == 0) {
	extdelimiter = makestring();
#if 0      
   extdelimiter = curlength;
#endif
    }
    appendchar(c);
    return true;
  }
}


/*:516*/
/*517:*/
Static void endname(void)
{
#if 0
  if (strptr + 3 > maxstrings)
    overflow(S("number of strings"), maxstrings - initstrptr);
  if (areadelimiter == 0)
    curarea = S("");
  else {
    curarea = strptr;
    strstart[strptr + 1] = strstart[strptr] + areadelimiter;
    strptr++;
  }
  if (extdelimiter == 0) {
    curext = S("");
    curname = makestring();
    return;
  }
  curname = strptr;
  strstart[strptr + 1] = strstart[strptr] + extdelimiter - areadelimiter - 1;
  strptr++;
  curext = makestring();
#else
  curarea = S("");
  if (extdelimiter == 0) {
	curext = S("");
	curname = makestring();
  } else { 
	curname = extdelimiter;
	curext = makestring();
  }
#endif
}

long filename_k;
Static void appendtoname(strASCIIcode x)
{
	filename_k++;
	if (filename_k<=filenamesize) { 
           nameoffile[filename_k-1]=xchr[x];
	}
}

/*:517*/
/*519:*/
void packfilename(strnumber n, strnumber a, strnumber e)
{
  long k;

  k = 0;
  filename_k = 0;
  str_map(a,appendtoname);
  str_map(n,appendtoname);
  str_map(e,appendtoname);
  k = filename_k;
  if (k <= filenamesize)
    namelength = k;
  else
    namelength = filenamesize;
  for (k = namelength; k < filenamesize; k++)
    nameoffile[k] = ' ';
}  /*:519*/

/*525:*/
Static strnumber makenamestring(void)
{
  /* char */ int k, FORLIM; /* INT */

#if 0
  if (poolptr + namelength > poolsize || strptr == maxstrings || curlength > 0) {
    return ('?');
  } else 
#endif
    {
    FORLIM = namelength;
    for (k = 0; k < namelength; k++) {
      appendchar(xord[nameoffile[k]]);
    }
    return (makestring());
  }
}


Static strnumber amakenamestring(FILE **f)
{
  return (makenamestring());
}


Static strnumber bmakenamestring(FILE **f)
{
  return (makenamestring());
}


Static strnumber wmakenamestring(FILE **f)
{
  return (makenamestring());
}


/*:525*/
/*526:*/
Static void scanfilename(void)
{
  nameinprogress = true;
  beginname();
  /*406:*/
  do {
    getxtoken();
    /*:406*/
  } while (curcmd == spacer);
  while (true) {
    if (curcmd > otherchar || curchr > 255) {
      backinput();
      goto _Ldone;
    }
    if (!morename(curchr))
      goto _Ldone;
    getxtoken();
  }
_Ldone:
  endname();
  nameinprogress = false;
}


/*:526*/
/*529:*/
Static void packjobname(strnumber s)
{
  curarea = S("");
  curext = s;
  curname = jobname;
  packfilename(curname,curarea,curext);
}


/*:529*/
/*530:*/
Static void promptfilename(strnumber s, strnumber e)
{
  short k;

  if (s == S("input file name")) {
    printnl(S("! "));
    print(S("I can't find file `"));
  } else {
    printnl(S("! "));
    print(S("I can't write on file `"));
  }
  printfilename(curname, curarea, curext);
  print(S("'."));
  if (e == S(".tex"))
    showcontext();
  printnl(S("Please type another "));
  print(s);
  if (interaction < scrollmode)
    fatalerror(S("*** (job aborted, file error in nonstop mode)"));
  print(S(": "));
  terminput();   /*531:*/
  beginname();
  k = first;
  while (buffer[k] == ' ' && k < last)
    k++;
  while (true) {
    if (k == last)
      goto _Ldone;
    if (!morename(buffer[k]))
      goto _Ldone;
    k++;
  }
_Ldone:
  endname();   /*:531*/
  if (curext == S(""))
    curext = e;
  packfilename(curname,curarea,curext);
}


/*:530*/
/*534:*/
Static void openlogfile(void)
{
  char oldsetting;
  short k;
  short l;
  Char months[36];
  short FORLIM;

  oldsetting = selector;
  if (jobname == 0)
    jobname = S("texput");
  packjobname(S(".log"));
  while (!aopenout(&logfile)) {   /*535:*/
    selector = termonly;
    promptfilename(S("transcript file name"), S(".log"));
  }
  /*:535*/
  logname = amakenamestring(&logfile);
  selector = logonly;
  logopened = true;
  /*536:*/
  fprintf(logfile,"%s",banner);
  slowprint(formatident);
  print(S("  "));
  printint(day);
  printchar(' ');
  memcpy(months, "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC", 36);
  FORLIM = month * 3;
  for (k = month * 3 - 3; k < FORLIM; k++)
    fwrite(&months[k], 1, 1, logfile);
  printchar(' ');
  printint(year);
  printchar(' ');
  printtwo(time / 60);
  printchar(':');
  printtwo(time % 60);   /*:536*/
  inputstack[inputptr] = curinput;
  printnl(S("**"));
  l = inputstack[0].limitfield;
  if (buffer[l] == endlinechar)
    l--;
  for (k = 1; k <= l; k++)
    print(buffer[k]);
  println();
  selector = oldsetting + 2;
}


/*:534*/
/*537:*/
Static void startinput(void)
{
  scanfilename();
  if (curext == S(""))
    curext = S(".tex");
  packfilename(curname,curarea,curext);
  while (true) {
    beginfilereading();
    if (aopenin(&curfile))
      goto _Ldone;
    if (curarea == S("")) {
      packfilename(curname, S("TeXinputs:"), curext);
      if (aopenin(&curfile))
	goto _Ldone;
    }
    endfilereading();
    promptfilename(S("input file name"), S(".tex"));
  }
_Ldone:
  name = amakenamestring(&curfile);
  if (jobname == 0) {
    jobname = curname;
    openlogfile();
  }
  if (termoffset + flength(name) > maxprintline - 2) {
    println();
  } else if (termoffset > 0 || fileoffset > 0)
    printchar(' ');
  printchar('(');
  openparens++;
  slowprint(name);
  fflush(termout);
  state = newline;
#if 0
  if (name == strptr - 1) {   /*538:*/
    flushstring();
    name = curname;
  }
#else 
   name = curname;
#endif
  line = 1;
  inputln(&curfile, false);
  firmuptheline();
  if (endlinecharinactive) {
    limit--;
  } else
    buffer[limit] = endlinechar;
  first = limit + 1;
  loc = start;   /*:538*/
}


/*:537*/

/*581:*/
Static void charwarning(internalfontnumber f, eightbits c)
{
  if (tracinglostchars <= 0)
    return;
  begindiagnostic();
  printnl(S("Missing character: There is no "));
  print(c);
  print(S(" in font "));
  slowprint(fontname[f ]);
  printchar('!');
  enddiagnostic(false);
}


/*:581*/
/*582:*/
Static halfword newcharacter(internalfontnumber f, eightbits c)
{
  halfword Result;
  pointer p;

  if (fontbc[f ] <= c) {
    if (fontec[f ] >= c) {
      if (charexists(charinfo(f, c))) {
	p = getavail();
	font(p) = f;
	character(p) = c;
	Result = p;
	goto _Lexit;
      }
    }
  }
  charwarning(f, c);
  Result = 0;
_Lexit:
  return Result;
}
/*:582*/

/*618:*/
Static void vlistout(void);


/*:618*/
/*619:*/
/*1368:*/
Static void specialout(halfword p)
{
  char oldsetting;

  synchh();
  synchv();
  oldsetting = selector;
  selector = newstring;
  showtokenlist(link(writetokens(p)), 0, poolsize /* - poolptr */ );
  selector = oldsetting;
  str_room(1);
  { int p_len=get_cur_length(); /* XXXX - Assumes byte=strASCIIcode */
#define xxx1            239
#define xxx4            242

    if (p_len< 256) {
	dviout(xxx1);
	dviout(p_len);
    } else { 
	dviout(xxx4);
	dvifour(p_len);
    }
    str_cur_map(dviout_helper);
  }
}
/*:1368*/

/*1370:*/
Static void writeout(halfword p)
{   /*1371:*/
  char oldsetting;
  long oldmode;
  /* smallnumber */ int j; /* INT */
  pointer q, r;

  q = getavail();
  info(q) = rightbracetoken + '}';
  r = getavail();
  link(q) = r;
  info(r) = endwritetoken;
  inslist(q);
  begintokenlist(writetokens(p), writetext);
  q = getavail();
  info(q) = leftbracetoken + '{';
  inslist(q);
  oldmode = mode;
  mode = 0;
  curcs = writeloc;
  q = scantoks(false, true);
  gettoken();
  if (curtok != endwritetoken) {   /*1372:*/
    printnl(S("! "));
    print(S("Unbalanced write command"));
    help2(S("On this page there's a \\write with fewer real {'s than }'s."),S("I can't handle that very well; good luck."));
    error();
    do {
      gettoken();
    } while (curtok != endwritetoken);
  }
  /*:1372*/
  mode = oldmode;   /*:1371*/
  endtokenlist();
  oldsetting = selector;
  j = writestream(p);
  if (writeopen[j])
    selector = j;
  else {
    if (j == 17 && selector == termandlog)
      selector = logonly;
    printnl(S(""));
  }
  tokenshow(defref);
  println();
  flushlist(defref);
  selector = oldsetting;
}
/*:1370*/

/*1373:*/
Static void outwhat(halfword p)
{
  /* smallnumber */ int j; /* INT */

  switch (subtype(p)) {

  case opennode:
  case writenode:
  case closenode:   /*1374:*/
    if (!doingleaders) {   /*:1374*/
      j = writestream(p);
      if (subtype(p) == writenode)
	writeout(p);
      else {
	if (writeopen[j])
	  aclose(&writefile[j]);
	if (subtype(p) == closenode)
	  writeopen[j] = false;
	else if (j < 16) {
	  curname = openname(p);
	  curarea = openarea(p);
	  curext = openext(p);
	  if (curext == S(""))
	    curext = S(".tex");
	packfilename(curname,curarea,curext);
	  while (!aopenout(&writefile[j]))
	    promptfilename(S("output file name"), S(".tex"));
	  writeopen[j] = true;
	}
      }
    }
    break;

  case specialnode:
    specialout(p);
    break;

  case languagenode:
    /* blank case */
    break;

  default:
    confusion(S("ext4"));
    break;
  }
}
/*:1373*/


Static void hlistout(void)
{
  scaled baseline, leftedge, saveh, savev, leaderwd, lx, edge;
  pointer thisbox, p, leaderbox;
  glueord gorder;
  char gsign;
  long saveloc;
  boolean outerdoingleaders;
  double gluetemp;

  thisbox = tempptr;
  gorder = glueorder(thisbox);
  gsign = gluesign(thisbox);
  p = listptr(thisbox);
  curs++;
  if (curs > 0) {
#if 0
    dviout(push);
#else
    dvi_push();
#endif
  }
  if (curs > maxpush)
    maxpush = curs;
  saveloc = get_dvi_mark();
  baseline = curv;
  leftedge = curh;
  while (p != 0) {   /*620:*/
_Lreswitch:
    if (ischarnode(p)) {
      synchh();
      synchv();
      do {
	quarterword c;
	quarterword f = font(p);
	c = character(p);
	if (f != dvif) {   /*621:*/
#if 0
	  if (!fontused[f ]) {
	    dvifontdef(f);
	    fontused[f ] = true;
	  }
	  if (f <= 64) {
	    dviout(f  + fntnum0 - 1);
	  } else {
	    dviout(fnt1);
	    dviout(f  - 1);
	  }
#else
	  dvi_set_font(f);
#endif
	  dvif = f;
	}
	/*:621*/
#if 1
	dvi_set_char(c);
#else
	if (c >= minquarterword + 128) {
	  dviout(set1);
	}
	dviout(c - minquarterword);
#endif
	curh += charwidth(f, charinfo(f, c));
	p = link(p);
      } while (ischarnode(p));
      dvih = curh;
      continue;
    }
    switch (type(p)) {

    case hlistnode:
    case vlistnode:   /*623:*/
      if (listptr(p) == 0)
	curh += width(p);
      else {   /*:623*/
	saveh = dvih;
	savev = dviv;
	curv = baseline + shiftamount(p);
	tempptr = p;
	edge = curh;
	if (type(p) == vlistnode)
	  vlistout();
	else
	  hlistout();
	dvih = saveh;
	dviv = savev;
	curh = edge + width(p);
	curv = baseline;
      }
      break;

    case rulenode:
      ruleht = height(p);
      ruledp = depth(p);
      rulewd = width(p);
      goto _Lfinrule_;
      break;

    case whatsitnode:   /*1367:*/
      outwhat(p);
      break;
      /*:1367*/

    case gluenode:   /*625:*/
      {pointer g = glueptr(p);
      rulewd = width(g);
      if (gsign != normal) {
	if (gsign == stretching) {
	  if (stretchorder(g) == gorder) {
	    vetglue(glueset(thisbox) * stretch(g));
	    rulewd += (long)floor(gluetemp + 0.5);
	  }
	} else if (shrinkorder(g) == gorder) {
	  vetglue(glueset(thisbox) * shrink(g));
	  rulewd -= (long)floor(gluetemp + 0.5);
	}
      }
      }
      if (subtype(p) >= aleaders) {   /*626:*/
	leaderbox = leaderptr(p);
	if (type(leaderbox) == rulenode) {
	  ruleht = height(leaderbox);
	  ruledp = depth(leaderbox);
	  goto _Lfinrule_;
	}
	leaderwd = width(leaderbox);
	if (leaderwd > 0 && rulewd > 0) {
	  rulewd += 10;
	  edge = curh + rulewd;
	  lx = 0;   /*627:*/
	  if (subtype(p) == aleaders) {
	    saveh = curh;
	    curh = leftedge + leaderwd * ((curh - leftedge) / leaderwd);
	    if (curh < saveh)
	      curh += leaderwd;
	  } else {   /*:627*/
	    lq = rulewd / leaderwd;
	    lr = rulewd % leaderwd;
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
	    if (subtype(p) == cleaders)
	      curh += lr / 2;
	    else {
	      lx = (lr * 2 + lq + 1) / (lq * 2 + 2);
	      curh += (lr - (lq - 1) * lx) / 2;
	    }
	  }
	  while (curh + leaderwd <= edge) {   /*628:*/
	    curv = baseline + shiftamount(leaderbox);
	    synchv();
	    savev = dviv;
	    synchh();
	    saveh = dvih;
	    tempptr = leaderbox;
	    outerdoingleaders = doingleaders;
	    doingleaders = true;
	    if (type(leaderbox) == vlistnode)
	      vlistout();
	    else
	      hlistout();
	    doingleaders = outerdoingleaders;
	    dviv = savev;
	    dvih = saveh;
	    curv = baseline;
	    curh = saveh + leaderwd + lx;
	  }
	  /*:628*/
	  curh = edge - 10;
	  goto _Lnextp_;
	}
      }  /*:626*/
      goto _Lmovepast_;
      break;
      /*:625*/

    case kernnode:
    case mathnode:
      curh += width(p);
      break;

    case ligaturenode:   /*652:*/
      mem[ligtrick - memmin] = mem[ligchar(p) - memmin];
      link(ligtrick) = link(p);
      p = ligtrick;
      goto _Lreswitch;
      break;
      /*:652*/
    }
    goto _Lnextp_;
_Lfinrule_:   /*624:*/
    if (isrunning(ruleht)) {
      ruleht = height(thisbox);
    }
    if (isrunning(ruledp)) {
      ruledp = depth(thisbox);
    }
    ruleht += ruledp;
    if (ruleht > 0 && rulewd > 0) {   /*:624*/
      synchh();
      curv = baseline + ruledp;
      synchv();
#if 0
      dviout(setrule);
      dvifour(ruleht);
      dvifour(rulewd);
#else
      dvi_setrule(ruleht,rulewd);
#endif
      curv = baseline;
      dvih += rulewd;
    }
_Lmovepast_:
    curh += rulewd;
_Lnextp_:
    p = link(p);
  }
  prunemovements(saveloc);
  if (curs > 0)
    dvipop(saveloc);
  curs--;

  /*622:*/
  /*:622*/
  /*:620*/
}


/*:619*/
/*629:*/
Static void vlistout(void)
{
  scaled leftedge, topedge, saveh, savev, leaderht, lx, edge;
  pointer thisbox, p, leaderbox;
  glueord gorder;
  char gsign;
  long saveloc;
  boolean outerdoingleaders;
  double gluetemp;

  thisbox = tempptr;
  gorder = glueorder(thisbox);
  gsign = gluesign(thisbox);
  p = listptr(thisbox);
  curs++;
  if (curs > 0) {
#if 0
    dviout(push);
#else
    dvi_push();
#endif
  }
  if (curs > maxpush)
    maxpush = curs;
  saveloc = get_dvi_mark();
  leftedge = curh;
  curv -= height(thisbox);
  topedge = curv;
  while (p != 0) {   /*630:*/
    if (ischarnode(p))
      confusion(S("vlistout"));
    else  /*631:*/
    {   /*:631*/
      switch (type(p)) {

      case hlistnode:
      case vlistnode:   /*632:*/
	if (listptr(p) == 0)
	  curv += height(p) + depth(p);
	else {   /*:632*/
	  curv += height(p);
	  synchv();
	  saveh = dvih;
	  savev = dviv;
	  curh = leftedge + shiftamount(p);
	  tempptr = p;
	  if (type(p) == vlistnode)
	    vlistout();
	  else
	    hlistout();
	  dvih = saveh;
	  dviv = savev;
	  curv = savev + depth(p);
	  curh = leftedge;
	}
	break;

      case rulenode:
	ruleht = height(p);
	ruledp = depth(p);
	rulewd = width(p);
	goto _Lfinrule_;
	break;

      case whatsitnode:   /*1366:*/
	outwhat(p);
	break;
	/*:1366*/

      case gluenode:   /*634:*/
	{
	pointer g = glueptr(p);
	ruleht = width(g);
	if (gsign != normal) {
	  if (gsign == stretching) {
	    if (stretchorder(g) == gorder) {
	      vetglue(glueset(thisbox) * stretch(g));
	      ruleht += (long)floor(gluetemp + 0.5);
	    }
	  } else if (shrinkorder(g) == gorder) {
	    vetglue(glueset(thisbox) * shrink(g));
	    ruleht -= (long)floor(gluetemp + 0.5);
	  }
	}
	}
	if (subtype(p) >= aleaders) {   /*635:*/
	  leaderbox = leaderptr(p);
	  if (type(leaderbox) == rulenode) {
	    rulewd = width(leaderbox);
	    ruledp = 0;
	    goto _Lfinrule_;
	  }
	  leaderht = height(leaderbox) + depth(leaderbox);
	  if (leaderht > 0 && ruleht > 0) {
	    ruleht += 10;
	    edge = curv + ruleht;
	    lx = 0;   /*636:*/
	    if (subtype(p) == aleaders) {
	      savev = curv;
	      curv = topedge + leaderht * ((curv - topedge) / leaderht);
	      if (curv < savev)
		curv += leaderht;
	    } else {   /*:636*/
	      lq = ruleht / leaderht;
	      lr = ruleht % leaderht;
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
	      if (subtype(p) == cleaders)
		curv += lr / 2;
	      else {
		lx = (lr * 2 + lq + 1) / (lq * 2 + 2);
		curv += (lr - (lq - 1) * lx) / 2;
	      }
	    }
	    while (curv + leaderht <= edge) {   /*637:*/
	      curh = leftedge + shiftamount(leaderbox);
	      synchh();
	      saveh = dvih;
	      curv += height(leaderbox);
	      synchv();
	      savev = dviv;
	      tempptr = leaderbox;
	      outerdoingleaders = doingleaders;
	      doingleaders = true;
	      if (type(leaderbox) == vlistnode)
		vlistout();
	      else
		hlistout();
	      doingleaders = outerdoingleaders;
	      dviv = savev;
	      dvih = saveh;
	      curh = leftedge;
	      curv = savev - height(leaderbox) + leaderht + lx;
	    }
	    /*:637*/
	    curv = edge - 10;
	    goto _Lnextp_;
	  }
	}
	/*:635*/
	goto _Lmovepast_;
	break;
	/*:634*/

      case kernnode:
	curv += width(p);
	break;
      }
      goto _Lnextp_;
_Lfinrule_:   /*633:*/
      if (isrunning(rulewd)) {
	rulewd = width(thisbox);
      }
      ruleht += ruledp;
      curv += ruleht;
      if (ruleht > 0 && rulewd > 0) {
	synchh();
	synchv();
#if 0
	dviout(putrule);
	dvifour(ruleht);
	dvifour(rulewd);
#else
	dvi_putrule( ruleht,  rulewd);
#endif
      }
      goto _Lnextp_;   /*:633*/
_Lmovepast_:
      curv += ruleht;
    }
_Lnextp_:
    p = link(p);
  }
  /*:630*/
  prunemovements(saveloc);
  if (curs > 0)
    dvipop(saveloc);
  curs--;
}


/*:629*/
/*638:*/
Static void shipout(halfword p)
{
  long pageloc;
  char j, k;
  char oldsetting;

  if (tracingoutput > 0) {
    printnl(S(""));
    println();
    print(S("Completed box being shipped out"));
  }
  if (termoffset > maxprintline - 9)
    println();
  else if (termoffset > 0 || fileoffset > 0)
    printchar(' ');
  printchar('[');
  j = 9;
  while (count(j) == 0 && j > 0)
    j--;
  for (k = 0; k <= j; k++) {
    printint(count(k));
    if (k < j)
      printchar('.');
  }
  fflush(termout);
  if (tracingoutput > 0) {   /*640:*/
    printchar(']');
    begindiagnostic();
    showbox(p);
    enddiagnostic(true);
  }
  /*641:*/
  if ((height(p) > maxdimen) | (depth(p) > maxdimen) |
      (height(p) + depth(p) + voffset > maxdimen) |
      (width(p) + hoffset > maxdimen)) {
    printnl(S("! "));
    print(S("Huge page cannot be shipped out"));
    help2(S("The page just created is more than 18 feet tall or"),S("more than 18 feet wide, so I suspect something went wrong."));
    error();
    if (tracingoutput <= 0) {
      begindiagnostic();
      printnl(S("The following box has been deleted:"));
      showbox(p);
      enddiagnostic(true);
    }
    goto _Ldone;
  }
  if (height(p) + depth(p) + voffset > maxv)
    maxv = height(p) + depth(p) + voffset;
  if (width(p) + hoffset > maxh)
    maxh = width(p) + hoffset;   /*:641*/
  /*617:*/
  dvih = 0;
  dviv = 0;
  curh = hoffset;
  dvif = nullfont;
  if (outputfilename == 0) {
    if (jobname == 0)
      openlogfile();
    packjobname(S(".dvi"));
    while (!bopenout(&dvifile))
      promptfilename(S("file name for output"), S(".dvi"));
    outputfilename = bmakenamestring(&dvifile);
  }
  if (totalpages == 0) {   /*:617*/
#if 0
    dviout(pre);
    dviout(idbyte);
    dvifour(25400000L);
    dvifour(473628672L);
    preparemag();
    dvifour(mag);
#else
    preparemag();
    dvi_pre(25400000L, 473628672L, mag);
#endif
    oldsetting = selector;
    selector = newstring;
    print(S(" TeX output "));
    printint(year);
    printchar('.');
    printtwo(month);
    printchar('.');
    printtwo(day);
    printchar(':');
    printtwo(time / 60);
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
    printtwo(time % 60);
    selector = oldsetting;
    dviout(get_cur_length()); /* XXXX */
    str_cur_map(dviout_helper);
  }
  {
    long cp[10];
    for (k = 0; k <= 9; k++) {
	cp[k]=count(k);
    }
    dvibop(cp);
  }
  curv = height(p) + voffset;
  tempptr = p;
  if (type(p) == vlistnode)
    vlistout();
  else
    hlistout();
#if 0
  dviout(eop);
#else
  dvi_eop();
#endif
  totalpages++;
  curs = -1;
_Ldone:   /*:640*/
  if (tracingoutput <= 0)
    printchar(']');
  deadcycles = 0;
  fflush(termout);   /*639:*/
  /*_STAT*/
  if (tracingstats > 1) {   /*_ENDSTAT*/
    printnl(S("Memory usage before: "));
    printint(varused);
    printchar('&');
    printint(dynused);
    printchar(';');
  }
  flushnodelist(p);   /*_STAT*/
  if (tracingstats <= 1)   /*_ENDSTAT*/
    return;
  /*:639*/
  print(S(" after: "));
  printint(varused);
  printchar('&');
  printint(dynused);
  print(S("; still untouched: "));
  printint(himemmin - lomemmax - 1);
  println();
}  /*:638*/


/*645:*/
Static void scanspec(groupcode c, boolean threecodes)
{
  long s=0 /* XXXX */;
  char speccode;

  if (threecodes)
    s = saved(0);
  if (scankeyword(S("to")))
    speccode = exactly;
  else if (scankeyword(S("spread")))
    speccode = additional;
  else {
    speccode = additional;
    curval = 0;
    goto _Lfound;
  }
  scannormaldimen();
_Lfound:
  if (threecodes) {
    saved(0) = s;
    saveptr++;
  }
  saved(0) = speccode;
  saved(1) = curval;
  saveptr += 2;
  newsavelevel(c);
  scanleftbrace();
}


/*:645*/
/*649:*/
Static halfword hpack(halfword p, long w, smallnumber m)
{
  pointer r, q, g;
  scaled h, d, x, s;
  glueord o;
  eightbits hd;

  lastbadness = 0;
  r = getnode(boxnodesize);
  type(r) = hlistnode;
  subtype(r) = minquarterword;
  shiftamount(r) = 0;
  q = r + listoffset;
  link(q) = p;
  h = 0;   /*650:*/
  d = 0;
  x = 0;
  totalstretch[0] = 0;
  totalshrink[0] = 0;
  totalstretch[fil - normal] = 0;
  totalshrink[fil - normal] = 0;
  totalstretch[fill - normal] = 0;
  totalshrink[fill - normal] = 0;
  totalstretch[filll - normal] = 0;
  totalshrink[filll - normal] = 0;   /*:650*/
  while (p != 0) {   /*651:*/
_Lreswitch:
    while (ischarnode(p)) {   /*654:*/
      internalfontnumber f = font(p);
      fourquarters i = charinfo(f, character(p));
      hd = heightdepth(i);
      x += charwidth(f, i);
      s = charheight(f, hd);
      if (s > h)
	h = s;
      s = chardepth(f, hd);
      if (s > d)
	d = s;
      p = link(p);
    }
    /*:654*/
    if (p == 0)
      break;
    switch (type(p)) {

    case hlistnode:
    case vlistnode:
    case rulenode:
    case unsetnode:   /*653:*/
      x += width(p);
      if (type(p) >= rulenode)
	s = 0;
      else
	s = shiftamount(p);
      if (height(p) - s > h)
	h = height(p) - s;
      if (depth(p) + s > d)
	d = depth(p) + s;
      break;
      /*:653*/

    case insnode:
    case marknode:
    case adjustnode:
      if (adjusttail != 0) {   /*655:*/
	while (link(q) != p)
	  q = link(q);
	if (type(p) == adjustnode) {
	  link(adjusttail) = adjustptr(p);
	  while (link(adjusttail) != 0)
	    adjusttail = link(adjusttail);
	  p = link(p);
	  freenode(link(q), smallnodesize);
	} else {
	  link(adjusttail) = p;
	  adjusttail = p;
	  p = link(p);
	}
	link(q) = p;
	p = q;
      }
      /*:655*/
      break;

    case whatsitnode:   /*1360:*/
      break;
      /*:1360*/

    case gluenode:   /*656:*/
      g = glueptr(p);
      x += width(g);
      o = stretchorder(g);
      totalstretch[o - normal] += stretch(g);
      o = shrinkorder(g);
      totalshrink[o - normal] += shrink(g);
      if (subtype(p) >= aleaders) {
	g = leaderptr(p);
	if (height(g) > h)
	  h = height(g);
	if (depth(g) > d)
	  d = depth(g);
      }
      break;
      /*:656*/

    case kernnode:
    case mathnode:
      x += width(p);
      break;

    case ligaturenode:   /*652:*/
      mem[ligtrick - memmin] = mem[ligchar(p) - memmin];
      link(ligtrick) = link(p);
      p = ligtrick;
      goto _Lreswitch;
      break;
      /*:652*/
    }
    p = link(p);
  }
  /*:651*/
  if (adjusttail != 0)
    link(adjusttail) = 0;
  height(r) = h;
  depth(r) = d;   /*657:*/
  if (m == additional)
    w += x;
  width(r) = w;
  x = w - x;
  if (x == 0) {
    gluesign(r) = normal;
    glueorder(r) = normal;
    glueset(r) = 0.0;
    goto _Lexit;
  } else if (x > 0) {
    if (totalstretch[filll - normal] != 0)
      o = filll;
    else if (totalstretch[fill - normal] != 0)
      o = fill;
    else if (totalstretch[fil - normal] != 0)
      o = fil;
    else {
      o = normal;
      /*:
659*/
    }
    glueorder(r) = o;
    gluesign(r) = stretching;
    if (totalstretch[o - normal] != 0)
      glueset(r) = (double)x / totalstretch[o - normal];
    else {
      gluesign(r) = normal;
      glueset(r) = 0.0;
    }
    if (o == normal) {
      if (listptr(r) != 0) {   /*660:*/
	lastbadness = badness(x, totalstretch[0]);
	if (lastbadness > hbadness) {
	  println();
	  if (lastbadness > 100)
	    printnl(S("Underfull"));
	  else
	    printnl(S("Loose"));
	  print(S(" \\hbox (badness "));
	  printint(lastbadness);
	  goto _Lcommonending;
	}
      }
      /*:660*/
    }
    goto _Lexit;
  } else {
    if (totalshrink[filll - normal] != 0)
      o = filll;
    else if (totalshrink[fill - normal] != 0)
      o = fill;
    else if (totalshrink[fil - normal] != 0)
      o = fil;
    else
      o = normal;   /*:665*/
    glueorder(r) = o;
    gluesign(r) = shrinking;
    if (totalshrink[o - normal] != 0)
      glueset(r) = (double)(-x) / totalshrink[o - normal];
    else {
      gluesign(r) = normal;
      glueset(r) = 0.0;
    }
    if ((totalshrink[o - normal] < -x && o == normal) & (listptr(r) != 0)) {
      lastbadness = 1000000L;
      glueset(r) = 1.0;   /*666:*/
      if (-x - totalshrink[0] > hfuzz || hbadness < 100) {   /*:666*/
	if (overfullrule > 0 && -x - totalshrink[0] > hfuzz) {
	  while (link(q) != 0)
	    q = link(q);
	  link(q) = newrule();
	  width(link(q)) = overfullrule;
	}
	println();
	printnl(S("Overfull \\hbox ("));
	printscaled(-x - totalshrink[0]);
	print(S("pt too wide"));
	goto _Lcommonending;
      }
    } else if (o == normal) {
      if (listptr(r) != 0) {   /*667:*/
	lastbadness = badness(-x, totalshrink[0]);
	if (lastbadness > hbadness) {
	  println();
	  printnl(S("Tight \\hbox (badness "));
	  printint(lastbadness);
	  goto _Lcommonending;
	}
      }
      /*:667*/
    }
    goto _Lexit;
  }
_Lcommonending:   /*663:*/
  if (outputactive)
    print(S(") has occurred while \\output is active"));
  else {
    if (packbeginline != 0) {
      if (packbeginline > 0)
	print(S(") in paragraph at lines "));
      else
	print(S(") in alignment at lines "));
      printint(labs(packbeginline));
      print(S("--"));
    } else
      print(S(") detected at line "));
    printint(line);
  }
  println();
  fontinshortdisplay = nullfont;
  shortdisplay(listptr(r));
  println();
  begindiagnostic();
  showbox(r);   /*:663*/
  enddiagnostic(true);
_Lexit:
  return r;

  /*658:*/
  /*659:*/
  /*:658*/
  /*664:*/
  /*665:*/
  /*:664*/
  /*:657*/
}


/*:649*/
/*668:*/
Static halfword vpackage(halfword p, long h, smallnumber m, long l)
{
  pointer r, g;
  scaled w, d, x, s;
  glueord o;

  lastbadness = 0;
  r = getnode(boxnodesize);
  type(r) = vlistnode;
  subtype(r) = minquarterword;
  shiftamount(r) = 0;
  listptr(r) = p;
  w = 0;   /*650:*/
  d = 0;
  x = 0;
  totalstretch[0] = 0;
  totalshrink[0] = 0;
  totalstretch[fil - normal] = 0;
  totalshrink[fil - normal] = 0;
  totalstretch[fill - normal] = 0;
  totalshrink[fill - normal] = 0;
  totalstretch[filll - normal] = 0;
  totalshrink[filll - normal] = 0;   /*:650*/
  while (p != 0) {   /*669:*/
    if (ischarnode(p))
      confusion(S("vpack"));
    else {
      switch (type(p)) {

      case hlistnode:
      case vlistnode:
      case rulenode:
      case unsetnode:   /*670:*/
	x += d + height(p);
	d = depth(p);
	if (type(p) >= rulenode)
	  s = 0;
	else
	  s = shiftamount(p);
	if (width(p) + s > w)
	  w = width(p) + s;
	break;
	/*:670*/

      case whatsitnode:   /*1359:*/
	break;

      /*:1359*/
      case gluenode:   /*:671*/
	/*671:*/
	x += d;
	d = 0;
	g = glueptr(p);
	x += width(g);
	o = stretchorder(g);
	totalstretch[o - normal] += stretch(g);
	o = shrinkorder(g);
	totalshrink[o - normal] += shrink(g);
	if (subtype(p) >= aleaders) {
	  g = leaderptr(p);
	  if (width(g) > w)
	    w = width(g);
	}
	break;

      case kernnode:
	x += d + width(p);
	d = 0;
	break;
      }
    }
    p = link(p);
  }
  /*:669*/
  width(r) = w;
  if (d > l) {   /*672:*/
    x += d - l;
    depth(r) = l;
  } else
    depth(r) = d;
  if (m == additional)
    h += x;
  height(r) = h;
  x = h - x;
  if (x == 0) {
    gluesign(r) = normal;
    glueorder(r) = normal;
    glueset(r) = 0.0;
    goto _Lexit;
  } else if (x > 0) {
    if (totalstretch[filll - normal] != 0)
      o = filll;
    else if (totalstretch[fill - normal] != 0)
      o = fill;
    else if (totalstretch[fil - normal] != 0)
      o = fil;
    else {
      o = normal;
      /*:
659*/
    }
    glueorder(r) = o;
    gluesign(r) = stretching;
    if (totalstretch[o - normal] != 0)
      glueset(r) = (double)x / totalstretch[o - normal];
    else {
      gluesign(r) = normal;
      glueset(r) = 0.0;
    }
    if (o == normal) {
      if (listptr(r) != 0) {   /*674:*/
	lastbadness = badness(x, totalstretch[0]);
	if (lastbadness > vbadness) {
	  println();
	  if (lastbadness > 100)
	    printnl(S("Underfull"));
	  else
	    printnl(S("Loose"));
	  print(S(" \\vbox (badness "));
	  printint(lastbadness);
	  goto _Lcommonending;
	}
      }
      /*:674*/
    }
    goto _Lexit;
  } else {
    if (totalshrink[filll - normal] != 0)
      o = filll;
    else if (totalshrink[fill - normal] != 0)
      o = fill;
    else if (totalshrink[fil - normal] != 0)
      o = fil;
    else
      o = normal;   /*:665*/
    glueorder(r) = o;
    gluesign(r) = shrinking;
    if (totalshrink[o - normal] != 0)
      glueset(r) = (double)(-x) / totalshrink[o - normal];
    else {
      gluesign(r) = normal;
      glueset(r) = 0.0;
    }
    if ((totalshrink[o - normal] < -x && o == normal) & (listptr(r) != 0)) {
      lastbadness = 1000000L;
      glueset(r) = 1.0;   /*677:*/
      if (-x - totalshrink[0] > vfuzz || vbadness < 100) {   /*:677*/
	println();
	printnl(S("Overfull \\vbox ("));
	printscaled(-x - totalshrink[0]);
	print(S("pt too high"));
	goto _Lcommonending;
      }
    } else if (o == normal) {
      if (listptr(r) != 0) {   /*678:*/
	lastbadness = badness(-x, totalshrink[0]);
	if (lastbadness > vbadness) {
	  println();
	  printnl(S("Tight \\vbox (badness "));
	  printint(lastbadness);
	  goto _Lcommonending;
	}
      }
      /*:678*/
    }
    goto _Lexit;
  }
_Lcommonending:   /*675:*/
  if (outputactive)
    print(S(") has occurred while \\output is active"));
  else {
    if (packbeginline != 0) {
      print(S(") in alignment at lines "));
      printint(labs(packbeginline));
      print(S("--"));
    } else
      print(S(") detected at line "));
    printint(line);
    println();
  }
  begindiagnostic();
  showbox(r);   /*:675*/
  enddiagnostic(true);
_Lexit:
  return r;

  /*673:*/
  /*659:*/
  /*:673*/
  /*676:*/
  /*665:*/
  /*:676*/
  /*:672*/
}


/*:668*/
/*679:*/
Static void appendtovlist(halfword b)
{
  scaled d;
  pointer p;

  if (prevdepth > ignoredepth) {
    d = width(baselineskip) - prevdepth - height(b);
    if (d < lineskiplimit)
      p = newparamglue(lineskipcode);
    else {
      p = newskipparam(baselineskipcode);
      width(tempptr) = d;
    }
    link(tail) = p;
    tail = p;
  }
  link(tail) = b;
  tail = b;
  prevdepth = depth(b);
}


/*:679*/
/*686:*/
Static halfword newnoad(void)
{
  pointer p;

  p = getnode(noadsize);
  type(p) = ordnoad;
  subtype(p) = normal;
  mem[nucleus(p) - memmin].hh = emptyfield;
  mem[subscr(p) - memmin].hh = emptyfield;
  mem[supscr(p) - memmin].hh = emptyfield;
  return p;
}


/*:686*/
/*688:*/
Static halfword newstyle(smallnumber s)
{
  pointer p;

  p = getnode(stylenodesize);
  type(p) = stylenode;
  subtype(p) = s;
  width(p) = 0;
  depth(p) = 0;
  return p;
}  /*:688*/


/*689:*/
Static halfword newchoice(void)
{
  pointer p;

  p = getnode(stylenodesize);
  type(p) = choicenode;
  subtype(p) = 0;
  displaymlist(p) = 0;
  textmlist(p) = 0;
  scriptmlist(p) = 0;
  scriptscriptmlist(p) = 0;
  return p;
}


/*:689*/
/*693:*/
Static void showinfo(void)
{
  shownodelist(info(tempptr));
}


/*:693*/
/*704:*/
Static halfword fractionrule(long t)
{
  pointer p;

  p = newrule();
  height(p) = t;
  depth(p) = 0;
  return p;
}


/*:704*/
/*705:*/
Static halfword overbar(halfword b, long k, long t)
{
  pointer p, q;

  p = newkern(k);
  link(p) = b;
  q = fractionrule(t);
  link(q) = p;
  p = newkern(t);
  link(p) = q;
  return (vpack(p, 0, additional));
/* p2c: tex1.p: Warning: Too many arguments for foovpack [299] */
}


/*:705*/
/*706:*/
/*709:*/
Static halfword charbox(internalfontnumber f, quarterword c)
{
  fourquarters q;
  eightbits hd;
  pointer b, p;

  q = charinfo(f, c);
  hd = heightdepth(q);
  b = newnullbox();
  width(b) = charwidth(f, q) + charitalic(f, q);
  height(b) = charheight(f, hd);
  depth(b) = chardepth(f, hd);
  p = getavail();
  character(p) = c;
  font(p) = f;
  listptr(b) = p;
  return b;
}


/*:709*/
/*711:*/
Static void stackintobox(halfword b, internalfontnumber f, quarterword c)
{
  pointer p;

  p = charbox(f, c);
  link(p) = listptr(b);
  listptr(b) = p;
  height(b) = height(p);
}


/*:711*/
/*712:*/
Static long heightplusdepth(internalfontnumber f, quarterword c)
{
  fourquarters q;
  eightbits hd;

  q = charinfo(f, c);
  hd = heightdepth(q);
  return (charheight(f, hd) + chardepth(f, hd));
}  /*:712*/


Static halfword vardelimiter(halfword d, smallnumber s, long v)
{
  pointer b;
  internalfontnumber f, g;
  quarterword c=0 /* XXXX */, x, y;
  long m, n;
  scaled u, w;
  fourquarters q;
  eightbits hd;
  fourquarters r;
  smallnumber z;
  boolean largeattempt;

  f = nullfont;
  w = 0;
  largeattempt = false;
  z = smallfam(d);
  x = smallchar(d);
  while (true) {  /*707:*/
    if (z != 0 || x != minquarterword) {   /*:707*/
      z += s + 16;
      do {
	z -= 16;
	g = famfnt(z);
	if (g != nullfont) {   /*708:*/
	  y = x;
	  if (y - minquarterword >= fontbc[g ] &&
	      y - minquarterword <= fontec[g ]) {
_Llabcontinue:
	    q = charinfo(g, y);
	    if (charexists(q)) {
	      if (chartag(q) == exttag) {
		f = g;
		c = y;
		goto _Lfound;
	      }
	      hd = heightdepth(q);
	      u = charheight(g, hd) + chardepth(g, hd);
	      if (u > w) {
		f = g;
		c = y;
		w = u;
		if (u >= v)
		  goto _Lfound;
	      }
	      if (chartag(q) == listtag) {
		y = rembyte(q);
		goto _Llabcontinue;
	      }
	    }
	  }
	}
	/*:708*/
      } while (z >= 16);
    }
    if (largeattempt)
      goto _Lfound;
    largeattempt = true;
    z = largefam(d);
    x = largechar(d);
  }
_Lfound:
  if (f != nullfont) {   /*710:*/
    if (chartag(q) == exttag) {   /*713:*/
      b = newnullbox();
      type(b) = vlistnode;
      r = exteninfo(f,q); /* fontinfo[extenbase[f ] + rembyte(q)].qqqq; */
  /*714:*/
      c = extrep(r);
      u = heightplusdepth(f, c);
      w = 0;
      q = charinfo(f, c);
      width(b) = charwidth(f, q) + charitalic(f, q);
      c = extbot(r);
      if (c != minquarterword)
	w += heightplusdepth(f, c);
      c = extmid(r);
      if (c != minquarterword)
	w += heightplusdepth(f, c);
      c = exttop(r);
      if (c != minquarterword)
	w += heightplusdepth(f, c);
      n = 0;
      if (u > 0) {
	while (w < v) {   /*:714*/
	  w += u;
	  n++;
	  if (extmid(r) != minquarterword)
	    w += u;
	}
      }
      c = extbot(r);
      if (c != minquarterword)
	stackintobox(b, f, c);
      c = extrep(r);
      for (m = 1; m <= n; m++)
	stackintobox(b, f, c);
      c = extmid(r);
      if (c != minquarterword) {
	stackintobox(b, f, c);
	c = extrep(r);
	for (m = 1; m <= n; m++)
	  stackintobox(b, f, c);
      }
      c = exttop(r);
      if (c != minquarterword)
	stackintobox(b, f, c);
      depth(b) = w - height(b);
    } else
      b = charbox(f, c);   /*:710*/
    /*:713*/
  } else {
    b = newnullbox();
    width(b) = nulldelimiterspace;
  }
  shiftamount(b) = half(height(b) - depth(b)) - axisheight(s);
  return b;
}


/*:706*/
/*715:*/
Static halfword rebox(halfword b, long w)
{
  pointer p;
  internalfontnumber f;
  scaled v;

  if ((width(b) != w) & (listptr(b) != 0)) {
    if (type(b) == vlistnode)
      b = hpack(b, 0, additional);
    p = listptr(b);
    if (ischarnode(p) & (link(p) == 0)) {
      f = font(p);
      v = charwidth(f, charinfo(f, character(p)));
      if (v != width(b))
	link(p) = newkern(width(b) - v);
    }
    freenode(b, boxnodesize);
    b = newglue(ssglue);
    link(b) = p;
    while (link(p) != 0)
      p = link(p);
    link(p) = newglue(ssglue);
    return (hpack(b, w, exactly));
  } else {
    width(b) = w;
    return b;
  }
}


/*:715*/
/*716:*/
Static halfword mathglue(halfword g, long m)
{
  pointer p;
  long n;
  scaled f;

  n = xovern(m, 65536L);
  f = texremainder;
  if (f < 0) {
    n--;
    f += 65536L;
  }
  p = getnode(gluespecsize);
  width(p) = multandadd(n, width(g), xnoverd(width(g), f, 65536L),
			    1073741823L);
  stretchorder(p) = stretchorder(g);
  if (stretchorder(p) == normal)
    stretch(p) = multandadd(n, stretch(g),
	xnoverd(stretch(g), f, 65536L), 1073741823L);
  else
    stretch(p) = stretch(g);
  shrinkorder(p) = shrinkorder(g);
  if (shrinkorder(p) == normal)
    shrink(p) = multandadd(n, shrink(g),
			       xnoverd(shrink(g), f, 65536L),
			       1073741823L);
  else
    shrink(p) = shrink(g);
  return p;
}


/*:716*/
/*717:*/
Static void mathkern(halfword p, long m)
{
  long n;
  scaled f;

  if (subtype(p) != muglue)
    return;
  n = xovern(m, 65536L);
  f = texremainder;
  if (f < 0) {
    n--;
    f += 65536L;
  }
  width(p) = multandadd(n, width(p), xnoverd(width(p), f, 65536L),
			    1073741823L);
  subtype(p) = explicit;
}


/*:717*/
/*718:*/
Static void flushmath(void)
{
  flushnodelist(link(head));
  flushnodelist(incompleatnoad);
  link(head) = 0;
  tail = head;
  incompleatnoad = 0;
}


/*:718*/
/*720:*/
Static void mlisttohlist(void);


Static halfword cleanbox(halfword p, smallnumber s)
{
  pointer q, x, r;
  smallnumber savestyle;

  switch (mathtype(p)) {

  case mathchar:
    curmlist = newnoad();
    mem[nucleus(curmlist) - memmin] = mem[p - memmin];
    break;

  case subbox:
    q = info(p);
    goto _Lfound;
    break;

  case submlist:
    curmlist = info(p);
    break;

  default:
    q = newnullbox();
    goto _Lfound;
    break;
  }
  savestyle = curstyle;
  curstyle = s;
  mlistpenalties = false;
  mlisttohlist();
  q = link(temphead);
  curstyle = savestyle;   /*703:*/
  if (curstyle < scriptstyle)
    cursize = textsize;
  else
    cursize = (curstyle - textstyle) / 2 * 16;
  curmu = xovern(mathquad(cursize), 18);   /*:703*/
_Lfound:
  if (ischarnode(q) || q == 0)   /*721:*/
    x = hpack(q, 0, additional);
  else if ((link(q) == 0) & (type(q) <= vlistnode) &
	   (shiftamount(q) == 0))
    x = q;
  else
    x = hpack(q, 0, additional);
  q = listptr(x);
  if (!ischarnode(q))   /*:721*/
    return x;
  r = link(q);
  if (r == 0)
    return x;
  if (link(r) != 0)
    return x;
  if (ischarnode(r))
    return x;
  if (type(r) == kernnode) {
    freenode(r, smallnodesize);
    link(q) = 0;
  }
  return x;
}


/*:720*/
/*722:*/
Static void fetch(halfword a)
{
  curc = character(a);
  curf = famfnt(fam(a) + cursize);
  if (curf == nullfont) {   /*723:*/
    printnl(S("! "));
    print(S(""));
    printsize(cursize);
    printchar(' ');
    printint(fam(a));
    print(S(" is undefined (character "));
    print(curc - minquarterword);
    printchar(')');
    help4(S("Somewhere in the math formula just ended, you used the"),S("stated character from an undefined font family. For example,"),S("plain TeX doesn't allow \\it or \\sl in subscripts. Proceed,"),S("and I'll try to forget that I needed that character."));
    error();
    curi = nullcharacter;
    mathtype(a) = empty;
    return;
  }  /*:723*/
  if (curc - minquarterword >= fontbc[curf ] &&
      curc - minquarterword <= fontec[curf ])
    curi = charinfo(curf, curc);
  else
    curi = nullcharacter;
  if (!charexists(curi)) {
    charwarning(curf, curc - minquarterword);
    mathtype(a) = empty;
  }
}


/*:722*/
/*726:*/
/*734:*/
Static void makeover(halfword q)
{
  info(nucleus(q)) = overbar(
      cleanbox(nucleus(q), crampedstyle(curstyle)),
      defaultrulethickness * 3, defaultrulethickness);
  mathtype(nucleus(q)) = subbox;
}


/*:734*/
/*735:*/
Static void makeunder(halfword q)
{
  pointer p, x, y;
  scaled delta;

  x = cleanbox(nucleus(q), curstyle);
  p = newkern(defaultrulethickness * 3);
  link(x) = p;
  link(p) = fractionrule(defaultrulethickness);
  y = vpack(x, 0, additional);
/* p2c: tex1.p: Warning: Too many arguments for foovpack [299] */
  delta = height(y) + depth(y) + defaultrulethickness;
  height(y) = height(x);
  depth(y) = delta - height(y);
  info(nucleus(q)) = y;
  mathtype(nucleus(q)) = subbox;
}


/*:735*/
/*736:*/
Static void makevcenter(halfword q)
{
  pointer v;
  scaled delta;

  v = info(nucleus(q));
  if (type(v) != vlistnode)
    confusion(S("vcenter"));
  delta = height(v) + depth(v);
  height(v) = axisheight(cursize) + half(delta);
  depth(v) = delta - height(v);
}


/*:736*/
/*737:*/
Static void makeradical(halfword q)
{
  pointer x, y;
  scaled delta, clr;

  x = cleanbox(nucleus(q), crampedstyle(curstyle));
  if (curstyle < textstyle)
    clr = defaultrulethickness + labs(mathxheight(cursize)) / 4;
  else {
    clr = defaultrulethickness;
    clr += labs(clr) / 4;
  }
  y = vardelimiter(leftdelimiter(q), cursize,
		   height(x) + depth(x) + clr + defaultrulethickness);
  delta = depth(y) - height(x) - depth(x) - clr;
  if (delta > 0)
    clr += half(delta);
  shiftamount(y) = -(height(x) + clr);
  link(y) = overbar(x, clr, height(y));
  info(nucleus(q)) = hpack(y, 0, additional);
  mathtype(nucleus(q)) = subbox;
}


/*:737*/
/*738:*/
Static void makemathaccent(halfword q)
{
  pointer p, x, y;
  long a;
  quarterword c;
  internalfontnumber f;
  fourquarters i;
  scaled s, h, delta, w;

  fetch(accentchr(q));
  if (!charexists(curi))
    return;
  i = curi;
  c = curc;
  f = curf;   /*741:*/
  s = 0;
  if (mathtype(nucleus(q)) == mathchar) {
    fetch(nucleus(q));
    if (chartag(curi) == ligtag) {
      a = ligkernstart(curf,curi); 
      curi = fontinfo[a].qqqq;
      if (skipbyte(curi) > stopflag) {
	a = ligkernrestart(curf,curi); 
	curi = fontinfo[a].qqqq;
      }
      while (true) {
	if (nextchar(curi) - minquarterword == skewchar[curf ]) {
	  if (opbyte(curi) >= kernflag) {
	    if (skipbyte(curi) <= stopflag)
	      s = charkern(curf, curi);
	  }
	  goto _Ldone1;
	}
	if (skipbyte(curi) >= stopflag)
	  goto _Ldone1;
	a += skipbyte(curi) - minquarterword + 1;
	curi = fontinfo[a].qqqq;
      }
    }
  }
_Ldone1:   /*:741*/
  x = cleanbox(nucleus(q), crampedstyle(curstyle));
  w = width(x);
  h = height(x);   /*740:*/
  while (true) {
    if (chartag(i) != listtag) {
      goto _Ldone;
    }
    y = rembyte(i);
    i = charinfo(f, y);
    if (!charexists(i))
      goto _Ldone;
    if (charwidth(f, i) > w)
      goto _Ldone;
    c = y;
  }
_Ldone:   /*:740*/
  if (h < xheight(f))
    delta = h;
  else
    delta = xheight(f);
  if ((mathtype(supscr(q)) != empty) |
      (mathtype(subscr(q)) != empty)) {
    if (mathtype(nucleus(q)) == mathchar) {   /*742:*/
      flushnodelist(x);
      x = newnoad();
      mem[nucleus(x) - memmin] = mem[nucleus(q) - memmin];
      mem[supscr(x) - memmin] = mem[supscr(q) - memmin];
      mem[subscr(x) - memmin] = mem[subscr(q) - memmin];
      mem[supscr(q) - memmin].hh = emptyfield;
      mem[subscr(q) - memmin].hh = emptyfield;
      mathtype(nucleus(q)) = submlist;
      info(nucleus(q)) = x;
      x = cleanbox(nucleus(q), curstyle);
      delta += height(x) - h;
      h = height(x);
    }
    /*:742*/
  }
  y = charbox(f, c);
  shiftamount(y) = s + half(w - width(y));
  width(y) = 0;
  p = newkern(-delta);
  link(p) = x;
  link(y) = p;
  y = vpack(y, 0, additional);
/* p2c: tex1.p: Warning: Too many arguments for foovpack [299] */
  width(y) = width(x);
  if (height(y) < h) {   /*739:*/
    p = newkern(h - height(y));
    link(p) = listptr(y);
    listptr(y) = p;
    height(y) = h;
  }  /*:739*/
  info(nucleus(q)) = y;
  mathtype(nucleus(q)) = subbox;
}


/*:738*/
/*743:*/
Static void makefraction(halfword q)
{
  pointer p, v, x, y, z;
  scaled delta, delta1, delta2, shiftup, shiftdown, clr;

  if (thickness(q) == defaultcode)   /*744:*/
    thickness(q) = defaultrulethickness;
  x = cleanbox(numerator(q), numstyle(curstyle));
  z = cleanbox(denominator(q), denomstyle(curstyle));
  if (width(x) < width(z))
    x = rebox(x, width(z));
  else
    z = rebox(z, width(x));
  if (curstyle < textstyle) {
    shiftup = num1(cursize);
    shiftdown = denom1(cursize);
  } else {   /*:744*/
    shiftdown = denom2(cursize);
    if (thickness(q) != 0)
      shiftup = num2(cursize);
    else
      shiftup = num3(cursize);
  }
  if (thickness(q) == 0) {   /*745:*/
    if (curstyle < textstyle)
      clr = defaultrulethickness * 7;
    else
      clr = defaultrulethickness * 3;
    delta = half(clr - shiftup + depth(x) + height(z) - shiftdown);
    if (delta > 0) {
      shiftup += delta;
      shiftdown += delta;
    }
  } else  /*746:*/
  {   /*:746*/
    if (curstyle < textstyle)
      clr = thickness(q) * 3;
    else
      clr = thickness(q);
    delta = half(thickness(q));
    delta1 = clr - shiftup + depth(x) + axisheight(cursize) + delta;
    delta2 = clr - axisheight(cursize) + delta + height(z) - shiftdown;
    if (delta1 > 0)
      shiftup += delta1;
    if (delta2 > 0)
      shiftdown += delta2;
  }
  /*:745*/
  /*747:*/
  v = newnullbox();
  type(v) = vlistnode;
  height(v) = shiftup + height(x);
  depth(v) = depth(z) + shiftdown;
  width(v) = width(x);
  if (thickness(q) == 0) {
    p = newkern(shiftup - depth(x) - height(z) + shiftdown);
    link(p) = z;
  } else {
    y = fractionrule(thickness(q));
    p = newkern(axisheight(cursize) - delta - height(z) + shiftdown);
    link(y) = p;
    link(p) = z;
    p = newkern(shiftup - depth(x) - axisheight(cursize) - delta);
    link(p) = y;
  }
  link(x) = p;
  listptr(v) = x;   /*:747*/
  /*748:*/
  if (curstyle < textstyle)
    delta = delim1(cursize);
  else
    delta = delim2(cursize);
  x = vardelimiter(leftdelimiter(q), cursize, delta);
  link(x) = v;
  z = vardelimiter(rightdelimiter(q), cursize, delta);
  link(v) = z;
  newhlist(q) = hpack(x, 0, additional);   /*:748*/
}  /*:743*/


/*749:*/
Static long makeop(halfword q)
{
  scaled delta, shiftup, shiftdown;
  pointer p, v, x, y, z;
  quarterword c;
  fourquarters i;

  if (subtype(q) == normal && curstyle < textstyle)
    subtype(q) = limits;
  if (mathtype(nucleus(q)) == mathchar) {
    fetch(nucleus(q));
    if ((curstyle < textstyle) & (chartag(curi) == listtag)) {
      c = rembyte(curi);
      i = charinfo(curf, c);
      if (charexists(i)) {
	curc = c;
	curi = i;
	character(nucleus(q)) = c;
      }
    }
    delta = charitalic(curf, curi);
    x = cleanbox(nucleus(q), curstyle);
    if ((mathtype(subscr(q)) != empty) & (subtype(q) != limits))
      width(x) -= delta;
    shiftamount(x) =
      half(height(x) - depth(x)) - axisheight(cursize);
    mathtype(nucleus(q)) = subbox;
    info(nucleus(q)) = x;
  } else
    delta = 0;
  if (subtype(q) != limits)   /*750:*/
    return delta;
  /*:750*/
  x = cleanbox(supscr(q), supstyle(curstyle));
  y = cleanbox(nucleus(q), curstyle);
  z = cleanbox(subscr(q), substyle(curstyle));
  v = newnullbox();
  type(v) = vlistnode;
  width(v) = width(y);
  if (width(x) > width(v))
    width(v) = width(x);
  if (width(z) > width(v))
    width(v) = width(z);
  x = rebox(x, width(v));
  y = rebox(y, width(v));
  z = rebox(z, width(v));
  shiftamount(x) = half(delta);
  shiftamount(z) = -shiftamount(x);
  height(v) = height(y);
  depth(v) = depth(y);   /*751:*/
  if (mathtype(supscr(q)) == empty) {
    freenode(x, boxnodesize);
    listptr(v) = y;
  } else {
    shiftup = bigopspacing3 - depth(x);
    if (shiftup < bigopspacing1)
      shiftup = bigopspacing1;
    p = newkern(shiftup);
    link(p) = y;
    link(x) = p;
    p = newkern(bigopspacing5);
    link(p) = x;
    listptr(v) = p;
    height(v) += bigopspacing5 + height(x) + depth(x) + shiftup;
  }
  if (mathtype(subscr(q)) == empty)
    freenode(z, boxnodesize);
  else {   /*:751*/
    shiftdown = bigopspacing4 - height(z);
    if (shiftdown < bigopspacing2)
      shiftdown = bigopspacing2;
    p = newkern(shiftdown);
    link(y) = p;
    link(p) = z;
    p = newkern(bigopspacing5);
    link(z) = p;
    depth(v) += bigopspacing5 + height(z) + depth(z) + shiftdown;
  }
  newhlist(q) = v;
  return delta;
}


/*:749*/
/*752:*/
Static void makeord(halfword q)
{
  long a;
  pointer p, r;

_Lrestart:
  if (mathtype(subscr(q)) == empty) {
    if (mathtype(supscr(q)) == empty) {
      if (mathtype(nucleus(q)) == mathchar) {
	p = link(q);
	if (p != 0) {
	  if ((type(p) >= ordnoad) & (type(p) <= punctnoad)) {
	    if (mathtype(nucleus(p)) == mathchar) {
	      if (fam(nucleus(p)) == fam(nucleus(q))) {
		mathtype(nucleus(q)) = mathtextchar;
		fetch(nucleus(q));
		if (chartag(curi) == ligtag) {
		  a = ligkernstart(curf,curi); 
		  curc = character(nucleus(p));
		  curi = fontinfo[a].qqqq;
		  if (skipbyte(curi) > stopflag) {
		    a = ligkernrestart(curf,curi); 
		    curi = fontinfo[a].qqqq;
		  }
		  while (true) {  /*753:*/
		    if (nextchar(curi) == curc) {
		      if (skipbyte(curi) <= stopflag) {
			if (opbyte(curi) >= kernflag) {
			  p = newkern(charkern(curf, curi));
			  link(p) = link(q);
			  link(q) = p;
			  goto _Lexit;
			} else {   /*:753*/
			  checkinterrupt();
			  switch (opbyte(curi)) {

			  case minquarterword + 1:
			  case minquarterword + 5:
			    character(nucleus(q)) = rembyte(curi);
			    break;

			  case minquarterword + 2:
			  case minquarterword + 6:
			    character(nucleus(p)) = rembyte(curi);
			    break;

			  case minquarterword + 3:
			  case minquarterword + 7:
			  case minquarterword + 11:
			    r = newnoad();
			    character(nucleus(r)) = rembyte(curi);
			    fam(nucleus(r)) = fam(nucleus(q));
			    link(q) = r;
			    link(r) = p;
			    if (opbyte(curi) < minquarterword + 11)
			      mathtype(nucleus(r)) = mathchar;
			    else
			      mathtype(nucleus(r)) = mathtextchar;
			    break;

			  default:
			    link(q) = link(p);
			    character(nucleus(q)) = rembyte(curi);
			    mem[subscr(q) - memmin] =
			      mem[subscr(p) - memmin];
			    mem[supscr(q) - memmin] =
			      mem[supscr(p) - memmin];
			    freenode(p, noadsize);
			    break;
			  }
			  if (opbyte(curi) > minquarterword + 3)
			    goto _Lexit;
			  mathtype(nucleus(q)) = mathchar;
			  goto _Lrestart;
			}
		      }
		    }
		    if (skipbyte(curi) >= stopflag)
		      goto _Lexit;
		    a += skipbyte(curi) - minquarterword + 1;
		    curi = fontinfo[a].qqqq;
		  }
		}
	      }
	    }
	  }
	}
      }
    }
  }
_Lexit: ;
}


/*:752*/
/*756:*/
Static void makescripts(halfword q, long delta)
{
  pointer p, x, y, z;
  scaled shiftup, shiftdown, clr;
  smallnumber t;

  p = newhlist(q);
  if (ischarnode(p)) {
    shiftup = 0;
    shiftdown = 0;
  } else {
    z = hpack(p, 0, additional);
    if (curstyle < scriptstyle)
      t = scriptsize;
    else
      t = scriptscriptsize;
    shiftup = height(z) - supdrop(t);
    shiftdown = depth(z) + subdrop(t);
    freenode(z, boxnodesize);
  }
  if (mathtype(supscr(q)) == empty) {   /*757:*/
    x = cleanbox(subscr(q), substyle(curstyle));
    width(x) += scriptspace;
    if (shiftdown < sub1(cursize))
      shiftdown = sub1(cursize);
    clr = height(x) - labs(mathxheight(cursize) * 4) / 5;
    if (shiftdown < clr)
      shiftdown = clr;
    shiftamount(x) = shiftdown;
  } else {  /*758:*/
    x = cleanbox(supscr(q), supstyle(curstyle));
    width(x) += scriptspace;
    if (curstyle & 1)
      clr = sup3(cursize);
    else if (curstyle < textstyle)
      clr = sup1(cursize);
    else
      clr = sup2(cursize);
    if (shiftup < clr)
      shiftup = clr;
    clr = depth(x) + labs(mathxheight(cursize)) / 4;
    if (shiftup < clr)   /*:758*/
      shiftup = clr;
    if (mathtype(subscr(q)) == empty)
      shiftamount(x) = -shiftup;
    else {   /*759:*/
      y = cleanbox(subscr(q), substyle(curstyle));
      width(y) += scriptspace;
      if (shiftdown < sub2(cursize))
	shiftdown = sub2(cursize);
      clr = defaultrulethickness * 4 - shiftup + depth(x) +
	    height(y) - shiftdown;
      if (clr > 0) {
	shiftdown += clr;
	clr = labs(mathxheight(cursize) * 4) / 5 - shiftup + depth(x);
	if (clr > 0) {
	  shiftup += clr;
	  shiftdown -= clr;
	}
      }
      shiftamount(x) = delta;
      p = newkern(shiftup - depth(x) - height(y) + shiftdown);
      link(x) = p;
      link(p) = y;
      x = vpack(x, 0, additional);
/* p2c: tex1.p: Warning: Too many arguments for foovpack [299] */
      shiftamount(x) = shiftdown;
    }
  }
  /*:757*/
  if (newhlist(q) == 0) {
    newhlist(q) = x;
    return;
  }
  p = newhlist(q);
  while (link(p) != 0)
    p = link(p);
  link(p) = x;

  /*:759*/
}  /*:756*/


/*762:*/
Static smallnumber makeleftright(halfword q, smallnumber style, long maxd,
				 long maxh)
{
  scaled delta, delta1, delta2;

  if (style < scriptstyle)
    cursize = textsize;
  else
    cursize = (style - textstyle) / 2 * 16;
  delta2 = maxd + axisheight(cursize);
  delta1 = maxh + maxd - delta2;
  if (delta2 > delta1)
    delta1 = delta2;
  delta = delta1 / 500 * delimiterfactor;
  delta2 = delta1 + delta1 - delimitershortfall;
  if (delta < delta2)
    delta = delta2;
  newhlist(q) = vardelimiter(delimiter(q), cursize, delta);
  return (type(q) - leftnoad + opennoad);
}  /*:762*/


Static void mlisttohlist(void)
{
  pointer mlist, q, r, p=0 /* XXXX */, x=0 /* XXXX */, y, z;
  boolean penalties;
  smallnumber style, savestyle, rtype, t;
  long pen;
  smallnumber s;
  scaled maxh, maxd, delta;

  mlist = curmlist;
  penalties = mlistpenalties;
  style = curstyle;
  q = mlist;
  r = 0;
  rtype = opnoad;
  maxh = 0;
  maxd = 0;   /*703:*/
  if (curstyle < scriptstyle)
    cursize = textsize;
  else
    cursize = (curstyle - textstyle) / 2 * 16;
  curmu = xovern(mathquad(cursize), 18);   /*:703*/
  while (q != 0) {   /*727:*/
_Lreswitch:
    delta = 0;
    switch (type(q)) {

    case binnoad:
      switch (rtype) {

      case binnoad:
      case opnoad:
      case relnoad:
      case opennoad:
      case punctnoad:
      case leftnoad:
	type(q) = ordnoad;
	goto _Lreswitch;
	break;
      }
      break;

    case relnoad:
    case closenoad:
    case punctnoad:
    case rightnoad:  /*729:*/
      if (rtype == binnoad)
	type(r) = ordnoad;   /*:729*/
      if (type(q) == rightnoad)
	goto _Ldonewithnoad_;
      break;
      /*733:*/

    case leftnoad:
      goto _Ldonewithnoad_;
      break;

    case fractionnoad:
      makefraction(q);
      goto _Lcheckdimensions_;
      break;

    case opnoad:
      delta = makeop(q);
      if (subtype(q) == limits)
	goto _Lcheckdimensions_;
      break;

    case ordnoad:
      makeord(q);
      break;

    case opennoad:
    case innernoad:
      /* blank case */
      break;

    case radicalnoad:
      makeradical(q);
      break;

    case overnoad:
      makeover(q);
      break;

    case undernoad:
      makeunder(q);
      break;

    case accentnoad:
      makemathaccent(q);
      break;

    case vcenternoad:   /*:733*/
      makevcenter(q);
      break;
      /*730:*/

    case stylenode:
      curstyle = subtype(q);   /*703:*/
      if (curstyle < scriptstyle)
	cursize = textsize;
      else
	cursize = (curstyle - textstyle) / 2 * 16;
      curmu = xovern(mathquad(cursize), 18);   /*:703*/
      goto _Ldonewithnode_;
      break;

    case choicenode:   /*731:*/
      switch (curstyle / 2) {

      case 0:
	p = displaymlist(q);
	displaymlist(q) = 0;
	break;

      case 1:
	p = textmlist(q);
	textmlist(q) = 0;
	break;

      case 2:
	p = scriptmlist(q);
	scriptmlist(q) = 0;
	break;

      case 3:
	p = scriptscriptmlist(q);
	scriptscriptmlist(q) = 0;
	break;
      }
      flushnodelist(displaymlist(q));
      flushnodelist(textmlist(q));
      flushnodelist(scriptmlist(q));
      flushnodelist(scriptscriptmlist(q));
      type(q) = stylenode;
      subtype(q) = curstyle;
      width(q) = 0;
      depth(q) = 0;
      if (p != 0) {
	z = link(q);
	link(q) = p;
	while (link(p) != 0)
	  p = link(p);
	link(p) = z;
      }
      goto _Ldonewithnode_;
      break;
      /*:731*/

    case insnode:
    case marknode:
    case adjustnode:
    case whatsitnode:
    case penaltynode:
    case discnode:
      goto _Ldonewithnode_;
      break;

    case rulenode:
      if (height(q) > maxh)
	maxh = height(q);
      if (depth(q) > maxd)
	maxd = depth(q);
      goto _Ldonewithnode_;
      break;

    case gluenode:  /*732:*/
      if (subtype(q) == muglue) {
	x = glueptr(q);
	y = mathglue(x, curmu);
	deleteglueref(x);
	glueptr(q) = y;
	subtype(q) = normal;
      } else if ((cursize != textsize) & (subtype(q) == condmathglue)) {
	p = link(q);
	if (p != 0) {
	  if ((type(p) == gluenode) | (type(p) == kernnode)) {
	    link(q) = link(p);
	    link(p) = 0;
	    flushnodelist(p);
	  }
	}
      }
      goto _Ldonewithnode_;
      break;

    case kernnode:   /*:730*/
      mathkern(q, curmu);
      goto _Ldonewithnode_;
      break;

    default:
      confusion(S("mlist1"));
      break;
    }
    /*754:*/
    switch (mathtype(nucleus(q))) {

    case mathchar:
    case mathtextchar:   /*:755*/
      /*755:*/
      fetch(nucleus(q));
      if (charexists(curi)) {
	delta = charitalic(curf, curi);
	p = newcharacter(curf, curc - minquarterword);
	if ((mathtype(nucleus(q)) == mathtextchar) & (space(curf) != 0))
	  delta = 0;
	if (mathtype(subscr(q)) == empty && delta != 0) {
	  link(p) = newkern(delta);
	  delta = 0;
	}
      } else
	p = 0;
      break;

    case empty:
      p = 0;
      break;

    case subbox:
      p = info(nucleus(q));
      break;

    case submlist:
      curmlist = info(nucleus(q));
      savestyle = curstyle;
      mlistpenalties = false;
      mlisttohlist();
      curstyle = savestyle;   /*703:*/
      if (curstyle < scriptstyle)
	cursize = textsize;
      else
	cursize = (curstyle - textstyle) / 2 * 16;
      curmu = xovern(mathquad(cursize), 18);   /*:703*/
      p = hpack(link(temphead), 0, additional);
      break;

    default:
      confusion(S("mlist2"));
      break;
    }
    newhlist(q) = p;
    if ((mathtype(subscr(q)) == empty) &
	(mathtype(supscr(q)) == empty))
	  /*:754*/
	    goto _Lcheckdimensions_;
    /*:728*/
    makescripts(q, delta);
_Lcheckdimensions_:
    z = hpack(newhlist(q), 0, additional);
    if (height(z) > maxh)
      maxh = height(z);
    if (depth(z) > maxd)
      maxd = depth(z);
    freenode(z, boxnodesize);
_Ldonewithnoad_:
    r = q;
    rtype = type(r);
_Ldonewithnode_:
    q = link(q);
  }
  /*728:*/
  /*:727*/
  /*729:*/
  if (rtype == binnoad)   /*760:*/
    type(r) = ordnoad;   /*:729*/
  p = temphead;
  link(p) = 0;
  q = mlist;
  rtype = 0;
  curstyle = style;   /*703:*/
  if (curstyle < scriptstyle)
    cursize = textsize;
  else
    cursize = (curstyle - textstyle) / 2 * 16;
  curmu = xovern(mathquad(cursize), 18);   /*:703*/
  while (q != 0) {   /*761:*/
    t = ordnoad;
    s = noadsize;
    pen = infpenalty;
    switch (type(q)) {   /*:761*/

    case opnoad:
    case opennoad:
    case closenoad:
    case punctnoad:
    case innernoad:
      t = type(q);
      break;

    case binnoad:
      t = binnoad;
      pen = binoppenalty;
      break;

    case relnoad:
      t = relnoad;
      pen = relpenalty;
      break;

    case ordnoad:
    case vcenternoad:
    case overnoad:
    case undernoad:
      /* blank case */
      break;

    case radicalnoad:
      s = radicalnoadsize;
      break;

    case accentnoad:
      s = accentnoadsize;
      break;

    case fractionnoad:
      t = innernoad;
      s = fractionnoadsize;
      break;

    case leftnoad:
    case rightnoad:
      t = makeleftright(q, style, maxd, maxh);
      break;

    case stylenode:   /*763:*/
      curstyle = subtype(q);
      s = stylenodesize;   /*703:*/
      if (curstyle < scriptstyle)
	cursize = textsize;
      else
	cursize = (curstyle - textstyle) / 2 * 16;
      curmu = xovern(mathquad(cursize), 18);   /*:703*/
      goto _Ldeleteq_;
      break;
      /*:763*/

    case whatsitnode:
    case penaltynode:
    case rulenode:
    case discnode:
    case adjustnode:
    case insnode:
    case marknode:
    case gluenode:
    case kernnode:
      link(p) = q;
      p = q;
      q = link(q);
      link(p) = 0;
      goto _Ldone;
      break;

    default:
      confusion(S("mlist3"));
      break;
    }
    /*766:*/
    if (rtype > 0) {   /*:766*/
      const char trans_table[]="0234000122*4000133**3**344*0400400*000000234000111*1111112341011";
      switch (trans_table[rtype * 8 + t - ordnoad * 9]) {
      case '0':
	x = 0;
	break;

      case '1':
	if (curstyle < scriptstyle)
	  x = thinmuskipcode;
	else
	  x = 0;
	break;

      case '2':
	x = thinmuskipcode;
	break;

      case '3':
	if (curstyle < scriptstyle)
	  x = medmuskipcode;
	else
	  x = 0;
	break;

      case '4':
	if (curstyle < scriptstyle)
	  x = thickmuskipcode;
	else
	  x = 0;
	break;

      default:
	confusion(S("mlist4"));
	break;
      }
      if (x != 0) {
	y = mathglue(gluepar(x), curmu);
	z = newglue(y);
	gluerefcount(y) = 0;
	link(p) = z;
	p = z;
	subtype(z) = x + 1;
      }
    }
    /*767:*/
    if (newhlist(q) != 0) {
      link(p) = newhlist(q);
      do {
	p = link(p);
      } while (link(p) != 0);
    }
    if (penalties) {
      if (link(q) != 0) {
	if (pen < infpenalty) {   /*:767*/
	  rtype = type(link(q));
	  if (rtype != penaltynode) {
	    if (rtype != relnoad) {
	      z = newpenalty(pen);
	      link(p) = z;
	      p = z;
	    }
	  }
	}
      }
    }
    rtype = t;
_Ldeleteq_:
    r = q;
    q = link(q);
    freenode(r, s);
_Ldone: ;
  }
  /*:760*/

  /*:732*/
}


/*:726*/
/*772:*/
Static void pushalignment(void)
{
  pointer p;

  p = getnode(alignstacknodesize);
  link(p) = alignptr;
  info(p) = curalign;
  llink(p) = preamble;
  rlink(p) = curspan;
  mem[p - memmin + 2].int_ = curloop;
  mem[p - memmin + 3].int_ = alignstate;
  info(p + 4) = curhead;
  link(p + 4) = curtail;
  alignptr = p;
  curhead = getavail();
}


Static void popalignment(void)
{
  pointer p;

  freeavail(curhead);
  p = alignptr;
  curtail = link(p + 4);
  curhead = info(p + 4);
  alignstate = mem[p - memmin + 3].int_;
  curloop = mem[p - memmin + 2].int_;
  curspan = rlink(p);
  preamble = llink(p);
  curalign = info(p);
  alignptr = link(p);
  freenode(p, alignstacknodesize);
}


/*:772*/
/*774:*/
/*782:*/
Static void getpreambletoken(void)
{
_Lrestart:
  gettoken();
  while (curchr == spancode && curcmd == tabmark) {
    gettoken();
    if (curcmd > maxcommand) {
      expand();
      gettoken();
    }
  }
  if (curcmd == endv)
    fatalerror(S("(interwoven alignment preambles are not allowed)"));
  if (curcmd != assignglue || curchr != gluebase + tabskipcode)
    return;
  scanoptionalequals();
  scanglue(glueval);
  if (globaldefs > 0)
    geqdefine(gluebase + tabskipcode, glueref, curval);
  else
    eqdefine(gluebase + tabskipcode, glueref, curval);
  goto _Lrestart;
}


/*:782*/
Static void alignpeek(void);

Static void normalparagraph(void);


Static void initalign(void)
{
  pointer savecsptr, p;

  savecsptr = curcs;
  pushalignment();
  alignstate = -1000000L;   /*776:*/
  if (mode == mmode && (tail != head || incompleatnoad != 0)) {   /*:776*/
    printnl(S("! "));
    print(S("Improper "));
    printesc(S("halign"));
    print(S(" inside $$'s"));
    help3(S("Displays can use special alignments (like \\eqalignno)"),S("only if nothing but the alignment itself is between $$'s."),S("So I've deleted the formulas that preceded this alignment."));
    error();
    flushmath();
  }
  pushnest();   /*775:*/
  if (mode == mmode) {
    mode = -vmode;
    prevdepth = nest[nestptr - 2].auxfield.sc;
  } else if (mode > 0)
    mode = -mode;   /*:775*/
  scanspec(aligngroup, false);
  /*777:*/
  preamble = 0;
  curalign = alignhead;
  curloop = 0;
  scannerstatus = aligning;
  warningindex = savecsptr;
  alignstate = -1000000L;
  while (true) {   /*778:*/
    link(curalign) = newparamglue(tabskipcode);
    curalign = link(curalign);   /*:778*/
    if (curcmd == carret)
      goto _Ldone;
    /*779:*/
    /*783:*/
    p = holdhead;
    link(p) = 0;
    while (true) {
      getpreambletoken();
      if (curcmd == macparam)
	goto _Ldone1;
      if (curcmd <= carret && curcmd >= tabmark && alignstate == -1000000L) {
	if (p == holdhead && curloop == 0 && curcmd == tabmark) {
	  curloop = curalign;
	  continue;
	} else {
	  printnl(S("! "));
	  print(S("Missing # inserted in alignment preamble"));
	  help3(S("There should be exactly one # between &'s, when an"),S("\\halign or \\valign is being set up. In this case you had"),S("none, so I've put one in; maybe that will work."));
	  backerror();
	  goto _Ldone1;
	}
      } else {
	if (curcmd != spacer || p != holdhead) {
	  link(p) = getavail();
	  p = link(p);
	  info(p) = curtok;
	}
	continue;
      }
    }
_Ldone1:   /*:783*/
    link(curalign) = newnullbox();
    curalign = link(curalign);
    info(curalign) = endspan;
    width(curalign) = nullflag;
    upart(curalign) = link(holdhead);   /*784:*/
    p = holdhead;
    link(p) = 0;
    while (true) {
_Llabcontinue:
      getpreambletoken();
      if (curcmd <= carret && curcmd >= tabmark && alignstate == -1000000L)
	goto _Ldone2;
      if (curcmd == macparam) {
	printnl(S("! "));
	print(S("Only one # is allowed per tab"));
	help3(S("There should be exactly one # between &'s, when an"),S("\\halign or \\valign is being set up. In this case you had"),S("more than one, so I'm ignoring all but the first."));
	error();
	goto _Llabcontinue;
      }
      link(p) = getavail();
      p = link(p);
      info(p) = curtok;
    }
_Ldone2:
    link(p) = getavail();
    p = link(p);
    info(p) = endtemplatetoken;   /*:784*/
    vpart(curalign) = link(holdhead);   /*:779*/
  }
_Ldone:
  scannerstatus = normal;   /*:777*/
  newsavelevel(aligngroup);
  if (everycr != 0)
    begintokenlist(everycr, everycrtext);
  alignpeek();
}


/*:774*/
/*786:*/
/*787:*/
Static void initspan(halfword p)
{
  pushnest();
  if (mode == -hmode)
    spacefactor = 1000;
  else {
    prevdepth = ignoredepth;
    normalparagraph();
  }
  curspan = p;
}


/*:787*/
Static void initrow(void)
{
  pushnest();
  mode = -hmode - vmode - mode;
  if (mode == -hmode)
    spacefactor = 0;
  else
    prevdepth = 0;
  tailappend(newglue(glueptr(preamble)));
  subtype(tail) = tabskipcode + 1;
  curalign = link(preamble);
  curtail = curhead;
  initspan(curalign);
}


/*:786*/
/*788:*/
Static void initcol(void)
{
  extrainfo(curalign) = curcmd;
  if (curcmd == omit)
    alignstate = 0;
  else {
    backinput();
    begintokenlist(upart(curalign), utemplate);
  }
}


/*:788*/
/*791:*/
Static boolean fincol(void)
{
  boolean Result;
  pointer p, q, r, s, u;
  scaled w;
  glueord o;
  halfword n;

  if (curalign == 0)
    confusion(S("endv"));
  q = link(curalign);
  if (q == 0)
    confusion(S("endv"));
  if (alignstate < 500000L)
    fatalerror(S("(interwoven alignment preambles are not allowed)"));
  p = link(q);
  /*792:*/
  if ((p == 0) & (extrainfo(curalign) < crcode)) {
    if (curloop != 0) {   /*793:*/
      link(q) = newnullbox();
      p = link(q);
      info(p) = endspan;
      width(p) = nullflag;
      curloop = link(curloop);   /*794:*/
      q = holdhead;
      r = upart(curloop);
      while (r != 0) {
	link(q) = getavail();
	q = link(q);
	info(q) = info(r);
	r = link(r);
      }
      link(q) = 0;
      upart(p) = link(holdhead);
      q = holdhead;
      r = vpart(curloop);
      while (r != 0) {
	link(q) = getavail();
	q = link(q);
	info(q) = info(r);
	r = link(r);
      }
      link(q) = 0;
      vpart(p) = link(holdhead);   /*:794*/
      curloop = link(curloop);
      link(p) = newglue(glueptr(curloop));
    } else {   /*:792*/
      printnl(S("! "));
      print(S("Extra alignment tab has been changed to "));
      printesc(S("cr"));
      help3(S("You have given more \\span or & marks than there were"),S("in the preamble to the \\halign or \\valign now in progress."),S("So I'll assume that you meant to type \\cr instead."));
      extrainfo(curalign) = crcode;
      error();
    }
    /*:793*/
  }
  if (extrainfo(curalign) != spancode) {
    unsave();
    newsavelevel(aligngroup);   /*796:*/
    if (mode == -hmode) {
      adjusttail = curtail;
      u = hpack(link(head), 0, additional);
      w = width(u);
      curtail = adjusttail;
      adjusttail = 0;
    } else {
      u = vpackage(link(head), 0, additional, 0);
      w = height(u);
    }
    n = minquarterword;
    if (curspan != curalign) {   /*798:*/
      q = curspan;
      do {
	n++;
	q = link(link(q));
      } while (q != curalign);
      if (n > maxquarterword)
	confusion(S("256 spans"));
      q = curspan;
      while (link(info(q)) < n)
	q = info(q);
      if (link(info(q)) > n) {
	s = getnode(spannodesize);
	info(s) = info(q);
	link(s) = n;
	info(q) = s;
	width(s) = w;
      } else if (width(info(q)) < w)
	width(info(q)) = w;
    } else if (w > width(curalign))   /*:798*/
      width(curalign) = w;
    type(u) = unsetnode;
    spancount(u) = n;   /*659:*/
    if (totalstretch[filll - normal] != 0)
      o = filll;
    else if (totalstretch[fill - normal] != 0)
      o = fill;
    else if (totalstretch[fil - normal] != 0)
      o = fil;
    else {
      o = normal;
      /*:
659*/
    }
    glueorder(u) = o;
    gluestretch(u) = totalstretch[o - normal];   /*665:*/
    if (totalshrink[filll - normal] != 0)
      o = filll;
    else if (totalshrink[fill - normal] != 0)
      o = fill;
    else if (totalshrink[fil - normal] != 0)
      o = fil;
    else
      o = normal;   /*:665*/
    gluesign(u) = o;
    glueshrink(u) = totalshrink[o - normal];
    popnest();
    link(tail) = u;
    tail = u;   /*:796*/
    /*795:*/
    tailappend(newglue(glueptr(link(curalign))));
    subtype(tail) = tabskipcode + 1;   /*:795*/
    if (extrainfo(curalign) >= crcode) {
      Result = true;
      goto _Lexit;
    }
    initspan(p);
  }
  alignstate = 1000000L;   /*406:*/
  do {
    getxtoken();   /*:406*/
  } while (curcmd == spacer);
  curalign = p;
  initcol();
  Result = false;
_Lexit:
  return Result;
}


/*:791*/
/*799:*/
Static void finrow(void)
{
  pointer p;

  if (mode == -hmode) {
    p = hpack(link(head), 0, additional);
    popnest();
    appendtovlist(p);
    if (curhead != curtail) {
      link(tail) = link(curhead);
      tail = curtail;
    }
  } else {
    p = vpack(link(head), 0, additional);
    popnest();
    link(tail) = p;
    tail = p;
    spacefactor = 1000;
  }
  type(p) = unsetnode;
  gluestretch(p) = 0;
  if (everycr != 0)
    begintokenlist(everycr, everycrtext);
  alignpeek();
}


/*:799*/
/*800:*/
Static void doassignments(void);

Static void resumeafterdisplay(void);

Static void buildpage(void);


Static void finalign(void)
{
  pointer p, q, r, s, u, v;
  scaled t, w, o, rulesave;
  halfword n;
  memoryword auxsave;

  if (curgroup != aligngroup)
    confusion(S("align1"));
  unsave();
  if (curgroup != aligngroup)
    confusion(S("align0"));
  unsave();
  if (nest[nestptr - 1].modefield == mmode)
    o = displayindent;
  else
    o = 0;
  /*801:*/
  q = link(preamble);
  do {   /*804:*/
    flushlist(upart(q));
    flushlist(vpart(q));
    p = link(link(q));
    if (width(q) == nullflag) {   /*802:*/
      width(q) = 0;
      r = link(q);
      s = glueptr(r);
      if (s != zeroglue) {
	addglueref(zeroglue);
	deleteglueref(s);
	glueptr(r) = zeroglue;
      }
    }
    /*:802*/
    if (info(q) != endspan) {   /*803:*/
      t = width(q) + width(glueptr(link(q)));
      r = info(q);
      s = endspan;
      info(s) = p;
      n = minquarterword + 1;
      do {
	width(r) -= t;
	u = info(r);
	while (link(r) > n) {
	  s = info(s);
	  n = link(info(s)) + 1;
	}
	if (link(r) < n) {
	  info(r) = info(s);
	  info(s) = r;
	  (link(r))--;
	  s = r;
	} else {
	  if (width(r) > width(info(s)))
	    width(info(s)) = width(r);
	  freenode(r, spannodesize);
	}
	r = u;
      } while (r != endspan);
    }
    /*:803*/
    type(q) = unsetnode;
    spancount(q) = minquarterword;
    height(q) = 0;
    depth(q) = 0;
    glueorder(q) = normal;
    gluesign(q) = normal;
    gluestretch(q) = 0;
    glueshrink(q) = 0;
    q = p;   /*:801*/
  } while (q != 0);
  saveptr -= 2;
  packbeginline = -modeline;
  if (mode == -vmode) {
    rulesave = overfullrule;
    overfullrule = 0;
    p = hpack(preamble, saved(1), saved(0));
    overfullrule = rulesave;
  } else {
    q = link(preamble);
    do {
      height(q) = width(q);
      width(q) = 0;
      q = link(link(q));
    } while (q != 0);
    p = vpack(preamble, saved(1), saved(0));
    q = link(preamble);
    do {
      width(q) = height(q);
      height(q) = 0;
      q = link(link(q));
    } while (q != 0);
  }
  packbeginline = 0;   /*:804*/
  /*805:*/
  q = link(head);
  s = head;
  while (q != 0) {   /*:805*/
    if (!ischarnode(q)) {
      if (type(q) == unsetnode) {   /*807:*/
	if (mode == -vmode) {
	  type(q) = hlistnode;
	  width(q) = width(p);
	} else {
	  type(q) = vlistnode;
	  height(q) = height(p);
	}
	glueorder(q) = glueorder(p);
	gluesign(q) = gluesign(p);
	glueset(q) = glueset(p);
	shiftamount(q) = o;
	r = link(listptr(q));
	s = link(listptr(p));
	do {   /*808:*/
	  n = spancount(r);
	  t = width(s);
	  w = t;
	  u = holdhead;
	  while (n > minquarterword) {
	    n--;
	    /*809:*/
	    s = link(s);
	    v = glueptr(s);
	    link(u) = newglue(v);
	    u = link(u);
	    subtype(u) = tabskipcode + 1;
	    t += width(v);
	    if (gluesign(p) == stretching) {
	      if (stretchorder(v) == glueorder(p))
		t += glueset(p) * stretch(v);
	    } else if (gluesign(p) == shrinking) {
	      if (shrinkorder(v) == glueorder(p))
		t -= glueset(p) * shrink(v);
	    }
	    s = link(s);
	    link(u) = newnullbox();
	    u = link(u);
	    t += width(s);
	    if (mode == -vmode)
	      width(u) = width(s);
	    else {   /*:809*/
	      type(u) = vlistnode;
	      height(u) = width(s);
	    }
	  }
	  if (mode == -vmode) {   /*810:*/
	    height(r) = height(q);
	    depth(r) = depth(q);
	    if (t == width(r)) {
	      gluesign(r) = normal;
	      glueorder(r) = normal;
	      glueset(r) = 0.0;
	    } else if (t > width(r)) {
	      gluesign(r) = stretching;
	      if (gluestretch(r) == 0)
		glueset(r) = 0.0;
	      else
		glueset(r) = (double)(t - width(r)) / gluestretch(r);
	    } else {
	      glueorder(r) = gluesign(r);
	      gluesign(r) = shrinking;
	      if (glueshrink(r) == 0)
		glueset(r) = 0.0;
	      else if ((glueorder(r) == normal) &
		       (width(r) - t > glueshrink(r)))
		glueset(r) = 1.0;
	      else
		glueset(r) = (double)(width(r) - t) / glueshrink(r);
	    }
	    width(r) = w;
	    type(r) = hlistnode;
	  } else  /*811:*/
	  {   /*:811*/
	    width(r) = width(q);
	    if (t == height(r)) {
	      gluesign(r) = normal;
	      glueorder(r) = normal;
	      glueset(r) = 0.0;
	    } else if (t > height(r)) {
	      gluesign(r) = stretching;
	      if (gluestretch(r) == 0)
		glueset(r) = 0.0;
	      else
		glueset(r) = (double)(t - height(r)) / gluestretch(r);
	    } else {
	      glueorder(r) = gluesign(r);
	      gluesign(r) = shrinking;
	      if (glueshrink(r) == 0)
		glueset(r) = 0.0;
	      else if ((glueorder(r) == normal) &
		       (height(r) - t > glueshrink(r)))
		glueset(r) = 1.0;
	      else
		glueset(r) = (double)(height(r) - t) / glueshrink(r);
	    }
	    height(r) = w;
	    type(r) = vlistnode;
	  }
	  /*:810*/
	  shiftamount(r) = 0;
	  if (u != holdhead) {   /*:808*/
	    link(u) = link(r);
	    link(r) = link(holdhead);
	    r = u;
	  }
	  r = link(link(r));
	  s = link(link(s));
	} while (r != 0);
      }  /*:807*/
      else if (type(q) == rulenode) {
	if (isrunning(width(q))) {
	  width(q) = width(p);
	}
	if (isrunning(height(q))) {
	  height(q) = height(p);
	}
	if (isrunning(depth(q))) {
	  depth(q) = depth(p);
	}
	if (o != 0) {
	  r = link(q);
	  link(q) = 0;
	  q = hpack(q, 0, additional);
	  shiftamount(q) = o;
	  link(q) = r;
	  link(s) = q;
	}
      }
    }
    s = q;
    q = link(q);
  }
  flushnodelist(p);
  popalignment();   /*812:*/
  memcpy(&auxsave, &aux, sizeof(memoryword));
/* p2c: tex1.p: Warning: Incompatible types or sizes [167] */
  p = link(head);
  q = tail;
  popnest();
  if (mode == mmode) {   /*1206:*/
    doassignments();
    if (curcmd != mathshift) {   /*1207:*/
      printnl(S("! "));
      print(S("Missing $$ inserted"));
      help2(S("Displays can use special alignments (like \\eqalignno)"),S("only if nothing but the alignment itself is between $$'s."));
      backerror();
    } else {   /*1197:*/
      getxtoken();
      if (curcmd != mathshift) {
	printnl(S("! "));
	print(S("Display math should end with $$"));
	help2(S("The `$' that I just saw supposedly matches a previous `$$'."),S("So I shall assume that you typed `$$' both times."));
	backerror();
      }
    }
    /*:1207*/
    popnest();
    tailappend(newpenalty(predisplaypenalty));
    tailappend(newparamglue(abovedisplayskipcode));
    link(tail) = p;
    if (p != 0)
      tail = q;
    tailappend(newpenalty(postdisplaypenalty));
    tailappend(newparamglue(belowdisplayskipcode));
    prevdepth = auxsave.sc;
    resumeafterdisplay();
    return;
  }
  /*:1206*/
  aux = auxsave;
  link(tail) = p;
  if (p != 0)
    tail = q;
  if (mode == vmode)
    buildpage();

  /*806:*/
  /*:806*/
  /*:1197*/
  /*:812*/
}  /*785:*/


Static void alignpeek(void)
{
_Lrestart:
  alignstate = 1000000L;
  /*406:*/
  do {
    getxtoken();
    /*:406*/
  } while (curcmd == spacer);
  if (curcmd == noalign) {
    scanleftbrace();
    newsavelevel(noaligngroup);
    if (mode == -vmode)
      normalparagraph();
    return;
  }
  if (curcmd == rightbrace) {
    finalign();
    return;
  }
  if (curcmd == carret && curchr == crcrcode)
    goto _Lrestart;
  initrow();
  initcol();
}


/*:785*/
/*:800*/
/*815:*/
/*826:*/
Static halfword finiteshrink(halfword p)
{
  pointer q;

  if (noshrinkerroryet) {
    noshrinkerroryet = false;
    printnl(S("! "));
    print(S("Infinite glue shrinkage found in a paragraph"));
    help5(S("The paragraph just ended includes some glue that has"),S("infinite shrinkability, e.g., `\\hskip 0pt minus 1fil'."),S("Such glue doesn't belong there---it allows a paragraph"),S("of any length to fit on one line. But it's safe to proceed,"),S("since the offensive shrinkability has been made finite."));
    error();
  }
  q = newspec(p);
  shrinkorder(q) = normal;
  deleteglueref(p);
  return q;
}  /*:826*/


/*829:*/
Static void trybreak(long pi, smallnumber breaktype)
{  /*831:*/
  pointer r, prevr;
  halfword oldl;
  boolean nobreakyet;
  /*830:*/
  pointer prevprevr=0 /* XXXXX */, s, q, v, savelink;
  long t;
  internalfontnumber f;
  halfword l;
  boolean noderstaysactive;
  scaled linewidth=0 /* XXXX */, shortfall;   /*:830*/
  char fitclass;
  halfword b;
  long d;
  boolean artificialdemerits;

  if (labs(pi) >= infpenalty) {
    if (pi > 0)
      goto _Lexit;
    pi = ejectpenalty;
    /*:831*/
  }
  nobreakyet = true;
  prevr = active;
  oldl = 0;
  copytocuractive(1);
  copytocuractive(2);
  copytocuractive(3);
  copytocuractive(4);
  copytocuractive(5);
  copytocuractive(6);
  while (true) {
_Llabcontinue:
    r = link(prevr);   /*832:*/
    if (type(r) == deltanode) {   /*:832*/
      updatewidth(1);
      updatewidth(2);
      updatewidth(3);
      updatewidth(4);
      updatewidth(5);
      updatewidth(6);
      prevprevr = prevr;
      prevr = r;
      goto _Llabcontinue;
    }
    /*835:*/
    l = linenumber(r);
    if (l > oldl) {   /*:835*/
      if (minimumdemerits < awfulbad && (oldl != easyline || r == lastactive))
      {   /*836:*/
	if (nobreakyet) {   /*837:*/
	  nobreakyet = false;
	  setbreakwidthtobackground(1);
	  setbreakwidthtobackground(2);
	  setbreakwidthtobackground(3);
	  setbreakwidthtobackground(4);
	  setbreakwidthtobackground(5);
	  setbreakwidthtobackground(6);
	  s = curp;
	  if (breaktype > unhyphenated) {
	    if (curp != 0) {   /*840:*/
	      t = replacecount(curp);
	      v = curp;
	      s = postbreak(curp);
	      while (t > 0) {
		t--;
		v = link(v);   /*841:*/
		if (ischarnode(v)) {
		  f = font(v);
		  breakwidth[0] -= charwidth(f,
		      charinfo(f, character(v)));
		  continue;
		}
		switch (type(v)) {   /*:841*/

		case ligaturenode:
		  f = font(ligchar(v));
		  breakwidth[0] -= charwidth(f,
		      charinfo(f, character(ligchar(v))));
		  break;

		case hlistnode:
		case vlistnode:
		case rulenode:
		case kernnode:
		  breakwidth[0] -= width(v);
		  break;

		default:
		  confusion(S("disc1"));
		  break;
		}
	      }
	      while (s != 0) {   /*842:*/
		if (ischarnode(s)) {
		  f = font(s);
		  breakwidth[0] += charwidth(f,
		      charinfo(f, character(s)));
		} else {
		  switch (type(s)) {   /*:842*/

		  case ligaturenode:
		    f = font(ligchar(s));
		    breakwidth[0] += charwidth(f,
			charinfo(f, character(ligchar(s))));
		    break;

		  case hlistnode:
		  case vlistnode:
		  case rulenode:
		  case kernnode:
		    breakwidth[0] += width(s);
		    break;

		  default:
		    confusion(S("disc2"));
		    break;
		  }
		}
		s = link(s);
	      }
	      breakwidth[0] += discwidth;
	      if (postbreak(curp) == 0)
		s = link(v);
	    }
	    /*:840*/
	  }
	  while (s != 0) {
	    if (ischarnode(s))
	      goto _Ldone;
	    switch (type(s)) {

	    case gluenode:   /*838:*/
	      v = glueptr(s);
	      breakwidth[0] -= width(v);
	      breakwidth[stretchorder(v) + 1] -= stretch(v);
	      breakwidth[5] -= shrink(v);
	      break;
	      /*:838*/

	    case penaltynode:
	      /* blank case */
	      break;

	    case mathnode:
	      breakwidth[0] -= width(s);
	      break;

	    case kernnode:
	      if (subtype(s) != explicit)
		goto _Ldone;
	      breakwidth[0] -= width(s);
	      break;

	    default:
	      goto _Ldone;
	      break;
	    }
	    s = link(s);
	  }
_Ldone: ;
	}
	/*:837*/
	/*843:*/
	if (type(prevr) == deltanode) {
	  converttobreakwidth(1);
	  converttobreakwidth(2);
	  converttobreakwidth(3);
	  converttobreakwidth(4);
	  converttobreakwidth(5);
	  converttobreakwidth(6);
	} else if (prevr == active) {
	  storebreakwidth(1);
	  storebreakwidth(2);
	  storebreakwidth(3);
	  storebreakwidth(4);
	  storebreakwidth(5);
	  storebreakwidth(6);
	} else {
	  q = getnode(deltanodesize);
	  link(q) = r;
	  type(q) = deltanode;
	  subtype(q) = 0;
	  newdeltatobreakwidth(1);
	  newdeltatobreakwidth(2);
	  newdeltatobreakwidth(3);
	  newdeltatobreakwidth(4);
	  newdeltatobreakwidth(5);
	  newdeltatobreakwidth(6);
	  link(prevr) = q;
	  prevprevr = prevr;
	  prevr = q;
	}
	if (labs(adjdemerits) >= awfulbad - minimumdemerits)
	  minimumdemerits = awfulbad - 1;
	else
	  minimumdemerits += labs(adjdemerits);
	for (fitclass = veryloosefit; fitclass <= tightfit; fitclass++) {
	  if (minimaldemerits[fitclass - veryloosefit] <= minimumdemerits)
	  {   /*845:*/
	    q = getnode(passivenodesize);
	    link(q) = passive;
	    passive = q;
	    curbreak(q) = curp;   /*_STAT*/
	    passnumber++;
	    serial(q) = passnumber;   /*_ENDSTAT*/
	    prevbreak(q) = bestplace[fitclass - veryloosefit];
	    q = getnode(activenodesize);
	    breaknode(q) = passive;
	    linenumber(q) = bestplline[fitclass - veryloosefit] + 1;
	    fitness(q) = fitclass;
	    type(q) = breaktype;
	    totaldemerits(q) = minimaldemerits[fitclass - veryloosefit];
	    link(q) = r;
	    link(prevr) = q;
	    prevr = q;   /*_STAT*/
	    if (tracingparagraphs > 0) {   /*846:*/
	      printnl(S("@@"));
	      printint(serial(passive));
	      print(S(": line "));
	      printint(linenumber(q) - 1);
	      printchar('.');
	      printint(fitclass);
	      if (breaktype == hyphenated)
		printchar('-');
	      print(S(" t="));
	      printint(totaldemerits(q));
	      print(S(" -> @@"));
	      if (prevbreak(passive) == 0)
		printchar('0');
	      else
		printint(serial(prevbreak(passive)));
	    }
	    /*:846*/
	    /*_ENDSTAT*/
	  }
	  /*:845*/
	  minimaldemerits[fitclass - veryloosefit] = awfulbad;
	}
	minimumdemerits = awfulbad;   /*844:*/
	if (r != lastactive) {   /*:844*/
	  q = getnode(deltanodesize);
	  link(q) = r;
	  type(q) = deltanode;
	  subtype(q) = 0;
	  newdeltafrombreakwidth(1);
	  newdeltafrombreakwidth(2);
	  newdeltafrombreakwidth(3);
	  newdeltafrombreakwidth(4);
	  newdeltafrombreakwidth(5);
	  newdeltafrombreakwidth(6);
	  link(prevr) = q;
	  prevprevr = prevr;
	  prevr = q;
	}
      }
      /*:836*/
      if (r == lastactive)   /*850:*/
	goto _Lexit;
      if (l > easyline) {
	linewidth = secondwidth;
	oldl = maxhalfword - 1;
      } else {   /*:850*/
	oldl = l;
	if (l > lastspecialline)
	  linewidth = secondwidth;
	else if (parshapeptr == 0)
	  linewidth = firstwidth;
	else
	  linewidth = mem[parshapeptr + l * 2 - memmin].sc;
      }
    }
    /*851:*/
    artificialdemerits = false;
    shortfall = linewidth - curactivewidth[0];
    if (shortfall > 0) {   /*852:*/
      if (curactivewidth[2] != 0 || curactivewidth[3] != 0 ||
	  curactivewidth[4] != 0) {
	b = 0;
	fitclass = decentfit;
      } else {   /*:852*/
	if (shortfall > 7230584L) {
	  if (curactivewidth[1] < 1663497L) {
	    b = infbad;
	    fitclass = veryloosefit;
	    goto _Ldone1;
	  }
	}
	b = badness(shortfall, curactivewidth[1]);
	if (b > 12) {
	  if (b > 99)
	    fitclass = veryloosefit;
	  else
	    fitclass = loosefit;
	} else
	  fitclass = decentfit;
_Ldone1: ;
      }
    } else  /*853:*/
    {   /*:853*/
      if (-shortfall > curactivewidth[5])
	b = infbad + 1;
      else
	b = badness(-shortfall, curactivewidth[5]);
      if (b > 12)
	fitclass = tightfit;
      else
	fitclass = decentfit;
    }
    if (b > infbad || pi == ejectpenalty) {   /*854:*/
      if (((finalpass && minimumdemerits == awfulbad) &
	   (link(r) == lastactive)) && prevr == active)
	artificialdemerits = true;
      else if (b > threshold)
	goto _Ldeactivate_;
      noderstaysactive = false;
    }  /*:854*/
    else {
      prevr = r;
      if (b > threshold)
	goto _Llabcontinue;
      noderstaysactive = true;
    }  /*855:*/
    if (artificialdemerits)
      d = 0;
    else {   /*859:*/
      d = linepenalty + b;
      if (labs(d) >= 10000)
	d = 100000000L;
      else
	d *= d;
      if (pi != 0) {
	if (pi > 0)
	  d += pi * pi;
	else if (pi > ejectpenalty)
	  d -= pi * pi;
      }
      if ((breaktype == hyphenated) & (type(r) == hyphenated)) {
	if (curp != 0)
	  d += doublehyphendemerits;
	else
	  d += finalhyphendemerits;
      }
      if (labs(fitclass - fitness(r)) > 1)
	d += adjdemerits;
    }
    /*_STAT*/
    if (tracingparagraphs > 0) {   /*:856*/
      /*856:*/
      if (printednode != curp) {   /*857:*/
	printnl(S(""));
	if (curp == 0)
	  shortdisplay(link(printednode));
	else {
	  savelink = link(curp);
	  link(curp) = 0;
	  printnl(S(""));
	  shortdisplay(link(printednode));
	  link(curp) = savelink;
	}
	printednode = curp;
      }
      /*:857*/
      printnl('@');
      if (curp == 0)
	printesc(S("par"));
      else if (type(curp) != gluenode) {
	if (type(curp) == penaltynode)
	  printesc(S("penalty"));
	else if (type(curp) == discnode)
	  printesc(S("discretionary"));
	else if (type(curp) == kernnode)
	  printesc(S("kern"));
	else
	  printesc(S("math"));
      }
      print(S(" via @@"));
      if (breaknode(r) == 0)
	printchar('0');
      else
	printint(serial(breaknode(r)));
      print(S(" b="));
      if (b > infbad)
	printchar('*');
      else
	printint(b);
      print(S(" p="));
      printint(pi);
      print(S(" d="));
      if (artificialdemerits)
	printchar('*');
      else
	printint(d);
    }
    /*_ENDSTAT*/
    d += totaldemerits(r);
    if (d <= minimaldemerits[fitclass - veryloosefit]) {   /*:855*/
      minimaldemerits[fitclass - veryloosefit] = d;
      bestplace[fitclass - veryloosefit] = breaknode(r);
      bestplline[fitclass - veryloosefit] = l;
      if (d < minimumdemerits)
	minimumdemerits = d;
    }
    if (noderstaysactive)
      goto _Llabcontinue;
_Ldeactivate_:   /*860:*/
    link(prevr) = link(r);
    freenode(r, activenodesize);
    if (prevr == active) {   /*861:*/
      r = link(active);
      if (type(r) != deltanode)
	continue;
      updateactive(1);
      updateactive(2);
      updateactive(3);
      updateactive(4);
      updateactive(5);
      updateactive(6);
      copytocuractive(1);
      copytocuractive(2);
      copytocuractive(3);
      copytocuractive(4);
      copytocuractive(5);
      copytocuractive(6);
      link(active) = link(r);
      freenode(r, deltanodesize);
      continue;
    }  /*:861*/
    /*:851*/
    if (type(prevr) != deltanode)   /*:860*/
      continue;
    r = link(prevr);
    if (r == lastactive) {
      downdatewidth(1);
      downdatewidth(2);
      downdatewidth(3);
      downdatewidth(4);
      downdatewidth(5);
      downdatewidth(6);
      link(prevprevr) = lastactive;
      freenode(prevr, deltanodesize);
      prevr = prevprevr;
      continue;
    }
    if (type(r) != deltanode)
      continue;
    updatewidth(1);
    updatewidth(2);
    updatewidth(3);
    updatewidth(4);
    updatewidth(5);
    updatewidth(6);
    combinetwodeltas(1);
    combinetwodeltas(2);
    combinetwodeltas(3);
    combinetwodeltas(4);
    combinetwodeltas(5);
    combinetwodeltas(6);
    link(prevr) = link(r);
    freenode(r, deltanodesize);
  }
_Lexit:   /*_STAT*/
  /*858:*/
  if (curp != printednode)
    return;
  if (curp == 0)
    return;
  if (type(curp) != discnode)   /*:858*/
    return;
  /*_ENDSTAT*/
  t = replacecount(curp);
  while (t > 0) {
    t--;
    printednode = link(printednode);
  }

  /*:843*/
  /*:859*/
}  /*:829*/


/*877:*/
Static void postlinebreak(long finalwidowpenalty)
{   /*878:*/
  pointer q, r, s;
  boolean discbreak, postdiscbreak;
  scaled curwidth, curindent;
  quarterword t;
  long pen;
  halfword curline;

  q = breaknode(bestbet);
  curp = 0;
  do {
    r = q;
    q = prevbreak(q);
    nextbreak(r) = curp;
    curp = r;   /*:878*/
  } while (q != 0);
  curline = prevgraf + 1;
  do {   /*880:*/
    q = curbreak(curp);
    discbreak = false;
    postdiscbreak = false;
    if (q != 0) {
      if (type(q) == gluenode) {
	deleteglueref(glueptr(q));
	glueptr(q) = rightskip;
	subtype(q) = rightskipcode + 1;
	addglueref(rightskip);
	goto _Ldone;
      }
      if (type(q) == discnode) {   /*882:*/
	t = replacecount(q);   /*883:*/
	if (t == 0)
	  r = link(q);
	else {   /*:883*/
	  r = q;
	  while (t > 1) {
	    r = link(r);
	    t--;
	  }
	  s = link(r);
	  r = link(s);
	  link(s) = 0;
	  flushnodelist(link(q));
	  replacecount(q) = 0;
	}
	if (postbreak(q) != 0) {   /*884:*/
	  s = postbreak(q);
	  while (link(s) != 0)
	    s = link(s);
	  link(s) = r;
	  r = postbreak(q);
	  postbreak(q) = 0;
	  postdiscbreak = true;
	}
	/*:884*/
	if (prebreak(q) != 0) {   /*885:*/
	  s = prebreak(q);
	  link(q) = s;
	  while (link(s) != 0)
	    s = link(s);
	  prebreak(q) = 0;
	  q = s;
	}  /*:885*/
	link(q) = r;
	discbreak = true;
      }  /*:882*/
      else if ((type(q) == mathnode) | (type(q) == kernnode))
	width(q) = 0;
    } else {
      q = temphead;
      while (link(q) != 0)
	q = link(q);
    }
    /*886:*/
    r = newparamglue(rightskipcode);
    link(r) = link(q);
    link(q) = r;
    q = r;   /*:886*/
_Ldone:   /*:881*/
    /*887:*/
    r = link(q);
    link(q) = 0;
    q = link(temphead);
    link(temphead) = r;
    if (leftskip != zeroglue) {   /*:887*/
      r = newparamglue(leftskipcode);
      link(r) = q;
      q = r;
    }
    /*889:*/
    if (curline > lastspecialline) {
      curwidth = secondwidth;
      curindent = secondindent;
    } else if (parshapeptr == 0) {
      curwidth = firstwidth;
      curindent = firstindent;
    } else {
      curwidth = mem[parshapeptr + curline * 2 - memmin].sc;
      curindent = mem[parshapeptr + curline * 2 - memmin - 1].sc;
    }
    adjusttail = adjusthead;
    justbox = hpack(q, curwidth, exactly);
    shiftamount(justbox) = curindent;   /*:889*/
    /*888:*/
    appendtovlist(justbox);
    if (adjusthead != adjusttail) {
      link(tail) = link(adjusthead);
      tail = adjusttail;
    }
    adjusttail = 0;   /*:888*/
    /*890:*/
    if (curline + 1 != bestline) {   /*:890*/
      pen = interlinepenalty;
      if (curline == prevgraf + 1)
	pen += clubpenalty;
      if (curline + 2 == bestline)
	pen += finalwidowpenalty;
      if (discbreak)
	pen += brokenpenalty;
      if (pen != 0) {
	r = newpenalty(pen);
	link(tail) = r;
	tail = r;
      }
    }
    /*:880*/
    curline++;
    curp = nextbreak(curp);
    if (curp != 0) {
      if (!postdiscbreak) {   /*879:*/
	r = temphead;
	while (true) {
	  q = link(r);
	  if (q == curbreak(curp))
	    goto _Ldone1;
	  if (ischarnode(q))
	    goto _Ldone1;
	  if (nondiscardable(q)) {
	    goto _Ldone1;
	  }
	  if (type(q) == kernnode) {
	    if (subtype(q) != explicit)
	      goto _Ldone1;
	  }
	  r = q;
	}
_Ldone1:
	if (r != temphead) {
	  link(r) = 0;
	  flushnodelist(link(temphead));
	  link(temphead) = q;
	}
      }
      /*:879*/
    }
  } while (curp != 0);
  /*881:*/
  if ((curline != bestline) | (link(temphead) != 0))
    confusion(S("line breaking"));
  prevgraf = bestline - 1;
}


/*:877*/
/*895:*/
/*906:*/
Static smallnumber reconstitute(/* smallnumber */ int j, smallnumber n, halfword bchar,
				halfword hchar)
{
  pointer p, t;
  fourquarters q;
  halfword currh, testchar;
  scaled w;
  fontindex k;

  hyphenpassed = 0;
  t = holdhead;
  w = 0;
  link(holdhead) = 0;   /*908:*/
  curl = hu[j];
  curq = t;
  if (j == 0) {
    ligaturepresent = initlig;
    p = initlist;
    if (ligaturepresent)
      lfthit = initlft;
    while (p > 0) {
      appendcharnodetot(character(p));
      p = link(p);
    }
  } else if (curl < nonchar) {
    appendcharnodetot(curl);
  }
  ligstack = 0;   /*:908*/
  setcurr();
_Llabcontinue:   /*909:*/
  if (curl == nonchar) {
    k = bcharlabel[hf ];
    if (k == nonaddress)
      goto _Ldone;
    q = fontinfo[k].qqqq;
  } else {
    q = charinfo(hf, curl);
    if (chartag(q) != ligtag) {
      goto _Ldone;
    }
    k = ligkernstart(hf,q);
    q = fontinfo[k].qqqq;
    if (skipbyte(q) > stopflag) {
      k = ligkernrestart(hf,q);
      q = fontinfo[k].qqqq;
    }
  }
  if (currh < nonchar)
    testchar = currh;
  else
    testchar = curr;
  while (true) {
    if (nextchar(q) == testchar) {
      if (skipbyte(q) <= stopflag) {
	if (currh < nonchar) {
	  hyphenpassed = j;
	  hchar = nonchar;
	  currh = nonchar;
	  goto _Llabcontinue;
	} else {
	  if (hchar < nonchar) {
	    if (hyf[j] & 1) {
	      hyphenpassed = j;
	      hchar = nonchar;
	    }
	  }
	  if (opbyte(q) < kernflag) {   /*911:*/
	    if (curl == nonchar)
	      lfthit = true;
	    if (j == n) {
	      if (ligstack == 0)
		rthit = true;
	    }
	    checkinterrupt();
	    switch (opbyte(q)) {

	    case minquarterword + 1:
	    case minquarterword + 5:
	      curl = rembyte(q);
	      ligaturepresent = true;
	      break;

	    case minquarterword + 2:
	    case minquarterword + 6:
	      curr = rembyte(q);
	      if (ligstack > 0)
		character(ligstack) = curr;
	      else {
		ligstack = newligitem(curr);
		if (j == n)
		  bchar = nonchar;
		else {
		  p = getavail();
		  ligptr(ligstack) = p;
		  character(p) = hu[j + 1];
		  font(p) = hf;
		}
	      }
	      break;

	    case minquarterword + 3:
	      curr = rembyte(q);
	      p = ligstack;
	      ligstack = newligitem(curr);
	      link(ligstack) = p;
	      break;

	    case minquarterword + 7:
	    case minquarterword + 11:
	      wraplig(false);
	      curq = t;
	      curl = rembyte(q);
	      ligaturepresent = true;
	      break;

	    default:
	      curl = rembyte(q);
	      ligaturepresent = true;
	      if (ligstack > 0) {
		popligstack();
	      } else if (j == n)
		goto _Ldone;
	      else {
		appendcharnodetot(curr);
		j++;
		setcurr();
	      }
	      break;
	    }
	    if (opbyte(q) > minquarterword + 4) {
	      if (opbyte(q) != minquarterword + 7)
		goto _Ldone;
	    }
	    goto _Llabcontinue;
	  }
	  /*:911*/
	  w = charkern(hf, q);
	  goto _Ldone;
	}
      }
    }
    if (skipbyte(q) >= stopflag) {
      if (currh == nonchar)
	goto _Ldone;
      else {
	currh = nonchar;
	goto _Llabcontinue;
      }
    }
    k += skipbyte(q) - minquarterword + 1;
    q = fontinfo[k].qqqq;
  }
_Ldone:   /*:909*/
  /*910:*/
  wraplig(rthit);
  if (w != 0) {
    link(t) = newkern(w);
    t = link(t);
    w = 0;
  }
  if (ligstack <= 0)   /*:910*/
    return j;
  curq = t;
  curl = character(ligstack);
  ligaturepresent = true;
  popligstack();
  goto _Llabcontinue;
/* p2c: tex1.p: Note: Deleting unreachable code [255] */
}


/*:906*/
Static void hyphenate(void)   /*:929*/
{  /*923:*/
  /*901:*/
  /* char */ int i, j, l; /* INT */
  pointer q, r, s;
  halfword bchar;
  /*:901*/
  /*912:*/
  pointer majortail, minortail, hyfnode;
  ASCIIcode c=0 /* XXXX */;
  /* char */ int cloc; /* INT */
  long rcount;
  /*:912*/
  /*922:*/
  triepointer z;
  long v;
  /*:922*/
  /*929:*/
  hyphpointer h;
  strnumber k;
  char FORLIM;

  for (j = 0; j <= hn; j++)   /*930:*/
    hyf[j] = 0;
  h = hc[1];
  hn++;
  hc[hn] = curlang;
  for (j = 2; j <= hn ; j++)
    h = (h + h + hc[j]) % hyphsize;
  while (true) {  /*931:*/
    k = hyphword[h];
    if (k == 0)
      goto _Lnotfound;
    if (flength(k) < hn) {
      goto _Lnotfound;
    }
    if (flength(k) == hn) {
	{
        int ress=str_scmp(k,hc+1);
	if(ress<0) goto _Lnotfound;
	if(ress>0) goto _Ldone;	
	}
      s = hyphlist[h];
      while (s != 0) {   /*:932*/
	hyf[info(s)] = 1;
	s = link(s);
      }
      hn--;
      goto _Lfound;
    }
_Ldone:   /*:931*/
    if (h > 0)
      h--;
    else
      h = hyphsize;
  }
_Lnotfound:
  hn--;   /*:930*/
  if (triechar(curlang + 1) != curlang)
    goto _Lexit;
  hc[0] = 0;
  hc[hn + 1] = 0;
  hc[hn + 2] = 256;
  FORLIM = hn - rhyf + 1;
  for (j = 0; j <= FORLIM; j++) {
    z = trielink(curlang + 1) + hc[j];
    l = j;
    while (hc[l] == triechar(z) - minquarterword) {
      if (trieop(z) != minquarterword) {   /*924:*/
	v = trieop(z);
	do {
	  v += opstart[curlang];
	  i = l - hyfdistance[v - 1];
	  if (hyfnum[v - 1] > hyf[i])
	    hyf[i] = hyfnum[v - 1];
	  v = hyfnext[v - 1];
	} while (v != minquarterword);
      }
      /*:924*/
      l++;
      z = trielink(z) + hc[l];
    }
  }
_Lfound:
  for (j = 0; j < lhyf; j++)
    hyf[j] = 0;
  for (j = 0; j < rhyf; j++)   /*902:*/
    hyf[hn - j] = 0;   /*:923*/
  for (j = lhyf; j <= hn - rhyf; j++) {
    if (hyf[j] & 1)
      goto _Lfound1;
  }
  goto _Lexit;
_Lfound1:   /*:902*/
  /*903:*/
  q = link(hb);
  link(hb) = 0;
  r = link(ha);
  link(ha) = 0;
  bchar = hyfbchar;
  if (ischarnode(ha)) {
    if (font(ha) != hf)
      goto _Lfound2;
    initlist = ha;
    initlig = false;
    hu[0] = character(ha) - minquarterword;
  } else if (type(ha) == ligaturenode) {
    if (font(ligchar(ha)) != hf) {
      goto _Lfound2;
    }
    initlist = ligptr(ha);
    initlig = true;
    initlft = (subtype(ha) > 1);
    hu[0] = character(ligchar(ha)) - minquarterword;
    if (initlist == 0) {
      if (initlft) {
	hu[0] = 256;
	initlig = false;
      }
    }
    freenode(ha, smallnodesize);
  } else {
    if (!ischarnode(r)) {
      if (type(r) == ligaturenode) {
	if (subtype(r) > 1)
	  goto _Lfound2;
      }
    }
    j = 1;
    s = ha;
    initlist = 0;
    goto _Lcommonending;
  }
  s = curp;
  while (link(s) != ha)
    s = link(s);
  j = 0;
  goto _Lcommonending;
_Lfound2:
  s = ha;
  j = 0;
  hu[0] = 256;
  initlig = false;
  initlist = 0;
_Lcommonending:
  flushnodelist(r);   /*913:*/
  do {
    l = j;
    j = reconstitute(j, hn, bchar, hyfchar) + 1;
    if (hyphenpassed == 0) {
      link(s) = link(holdhead);
      while (link(s) > 0)
	s = link(s);
      if (hyf[j - 1] & 1) {
	l = j;
	hyphenpassed = j - 1;
	link(holdhead) = 0;
      }
    }
    if (hyphenpassed > 0) {   /*914:*/
      do {
	r = getnode(smallnodesize);
	link(r) = link(holdhead);
	type(r) = discnode;
	majortail = r;
	rcount = 0;
	while (link(majortail) > 0) {
	  advancemajortail();
	}
	i = hyphenpassed;
	hyf[i] = 0;   /*915:*/
	minortail = 0;
	prebreak(r) = 0;
	hyfnode = newcharacter(hf, hyfchar);
	if (hyfnode != 0) {
	  i++;
	  c = hu[i];
	  hu[i] = hyfchar;
	  freeavail(hyfnode);
	}
	while (l <= i) {
	  l = reconstitute(l, i, fontbchar[hf ], nonchar) + 1;
	  if (link(holdhead) <= 0)
	    continue;
	  if (minortail == 0)
	    prebreak(r) = link(holdhead);
	  else
	    link(minortail) = link(holdhead);
	  minortail = link(holdhead);
	  while (link(minortail) > 0)
	    minortail = link(minortail);
	}
	if (hyfnode != 0) {   /*:915*/
	  hu[i] = c;
	  l = i;
	  i--;
	}
	/*916:*/
	minortail = 0;
	postbreak(r) = 0;
	cloc = 0;
	if (bcharlabel[hf ] != nonaddress) {
	  l--;
	  c = hu[l];
	  cloc = l;
	  hu[l] = 256;
	}
	while (l < j) {   /*:916*/
	  do {
	    l = reconstitute(l, hn, bchar, nonchar) + 1;
	    if (cloc > 0) {
	      hu[cloc] = c;
	      cloc = 0;
	    }
	    if (link(holdhead) > 0) {
	      if (minortail == 0)
		postbreak(r) = link(holdhead);
	      else
		link(minortail) = link(holdhead);
	      minortail = link(holdhead);
	      while (link(minortail) > 0)
		minortail = link(minortail);
	    }
	  } while (l < j);
	  while (l > j) {   /*917:*/
	    j = reconstitute(j, hn, bchar, nonchar) + 1;
	    link(majortail) = link(holdhead);
	    while (link(majortail) > 0) {
	      advancemajortail();
	    }
	  }
	  /*:917*/
	}
	/*918:*/
	if (rcount > 127) {
	  link(s) = link(r);
	  link(r) = 0;
	  flushnodelist(r);
	} else {
	  link(s) = r;
	  replacecount(r) = rcount;
	}
	s = majortail;   /*:918*/
	hyphenpassed = j - 1;
	link(holdhead) = 0;   /*:914*/
      } while (hyf[j - 1] & 1);
    }
  } while (j <= hn);
  link(s) = q;   /*:913*/
  /*:903*/
  flushlist(initlist);
_Lexit: ;
}


/*:895*/
/*942:*/
/*944:*/
Static quarterword newtrieop(smallnumber d, smallnumber n, quarterword v)
{
  quarterword Result;
  short h;
  quarterword u;
  short l;

  h = abs(n + d * 313 + v * 361 + curlang * 1009) % (trieopsize + trieopsize) -
      trieopsize;
  while (true) {
    l = trieophash[h + trieopsize];
    if (l == 0) {
      if (trieopptr == trieopsize)
	overflow(S("pattern memory ops"), trieopsize);
      u = trieused[curlang];
      if (u == maxquarterword)
	overflow(S("pattern memory ops per language"), maxquarterword - minquarterword);
      trieopptr++;
      u++;
      trieused[curlang] = u;
      hyfdistance[trieopptr - 1] = d;
      hyfnum[trieopptr - 1] = n;
      hyfnext[trieopptr - 1] = v;
      trieoplang[trieopptr - 1] = curlang;
      trieophash[h + trieopsize] = trieopptr;
      trieopval[trieopptr - 1] = u;
      Result = u;
      goto _Lexit;
    }
    if (hyfdistance[l - 1] == d && hyfnum[l - 1] == n &&
	hyfnext[l - 1] == v && trieoplang[l - 1] == curlang) {
      Result = trieopval[l - 1];
      goto _Lexit;
    }
    if (h > -trieopsize)
      h--;
    else
      h = trieopsize;
  }
_Lexit:
  return Result;
}  /*:944*/


/*948:*/
Static triepointer trienode(triepointer p)
{
  triepointer Result, h, q;

  h = abs(triec[p] + trieo[p] * 1009 + triel[p] * 2718 + trier[p] * 3142) %
      triesize;
  while (true) {
    q = triehash[h];
    if (q == 0) {
      triehash[h] = p;
      Result = p;
      goto _Lexit;
    }
    if (triec[q] == triec[p] && trieo[q] == trieo[p] &&
	triel[q] == triel[p] && trier[q] == trier[p]) {
      Result = q;
      goto _Lexit;
    }
    if (h > 0)
      h--;
    else
      h = triesize;
  }
_Lexit:
  return Result;
}


/*:948*/
/*949:*/
Static triepointer compresstrie(triepointer p)
{
  if (p == 0)
    return 0;
  else {
    triel[p] = compresstrie(triel[p]);
    trier[p] = compresstrie(trier[p]);
    return (trienode(p));
  }
}


/*:949*/
/*953:*/
Static void firstfit(triepointer p)
{
  triepointer h, z, q;
  ASCIIcode c;
  triepointer l, r;
  short ll;

  c = triec[p];
  z = triemin[c];
  while (true) {
    h = z - c;   /*954:*/
    if (triemax < h + 256) {   /*:954*/
      if (triesize <= h + 256)
	overflow(S("pattern memory"), triesize);
      do {
	triemax++;
	P_clrbits_B(trietaken, triemax - 1, 0, 3);
	trielink(triemax) = triemax + 1;
	trieback(triemax) = triemax - 1;
      } while (triemax != h + 256);
    }
    if (P_getbits_UB(trietaken, h - 1, 0, 3))   /*955:*/
      goto _Lnotfound;
    q = trier[p];
    while (q > 0) {
      if (trielink(h + triec[q]) == 0)
	goto _Lnotfound;
      q = trier[q];
    }
    goto _Lfound;   /*:955*/
_Lnotfound:
    z = trielink(z);
  }
_Lfound:   /*956:*/
  P_putbits_UB(trietaken, h - 1, 1, 0, 3);
  triehash[p] = h;
  q = p;
  do {
    z = h + triec[q];
    l = trieback(z);
    r = trielink(z);
    trieback(r) = l;
    trielink(l) = r;
    trielink(z) = 0;
    if (l < 256) {
      if (z < 256)
	ll = z;
      else
	ll = 256;
      do {
	triemin[l] = r;
	l++;
      } while (l != ll);
    }
    q = trier[q];   /*:956*/
  } while (q != 0);
}


/*:953*/
/*957:*/
Static void triepack(triepointer p)
{
  triepointer q;

  do {
    q = triel[p];
    if (q > 0 && triehash[q] == 0) {
      firstfit(q);
      triepack(q);
    }
    p = trier[p];
  } while (p != 0);
}


/*:957*/
/*959:*/
Static void triefix(triepointer p)
{
  triepointer q;
  ASCIIcode c;
  triepointer z;

  z = triehash[p];
  do {
    q = triel[p];
    c = triec[p];
    trielink(z + c) = triehash[q];
    triechar(z + c) = c;
    trieop(z + c) = trieo[p];
    if (q > 0)
      triefix(q);
    p = trier[p];
  } while (p != 0);
}


/*:959*/
/*960:*/
Static void newpatterns(void)
{
  unsigned char k, l; /* INT */
  boolean digitsensed;
  quarterword v;
  triepointer p, q;
  boolean firstchild;
  ASCIIcode c;

  if (trienotready) {
    setcurlang();
    scanleftbrace();
    /*961:*/
    k = 0;
    hyf[0] = 0;
    digitsensed = false;
    while (true) {
      getxtoken();
      switch (curcmd) {

      case letter:
      case otherchar:   /*962:*/
	if (digitsensed | (curchr < '0') | (curchr > '9')) {
	  if (curchr == '.')
	    curchr = 0;
	  else {
	    curchr = lccode(curchr);
	    if (curchr == 0) {
	      printnl(S("! "));
	      print(S("Nonletter"));
	      help1(S("(See Appendix H.)"));
	      error();
	    }
	  }
	  if (k < 63) {
	    k++;
	    hc[k] = curchr;
	    hyf[k] = 0;
	    digitsensed = false;
	  }
	} else if (k < 63) {
	  hyf[k] = curchr - '0';
	  digitsensed = true;
	}
	break;

      case spacer:
      case rightbrace:
	if (k > 0) {   /*963:*/
	  if (hc[1] == 0)
	    hyf[0] = 0;
	  if (hc[k] == 0)
	    hyf[k] = 0;
	  l = k;
	  v = minquarterword;
	  while (true) {
	    if (hyf[l] != 0)
	      v = newtrieop(k - l, hyf[l], v);
	    if (l <= 0)
	      goto _Ldone1;
	    l--;
	  }
_Ldone1:   /*:965*/
	  q = 0;
	  hc[0] = curlang;
	  while (l <= k) {
	    c = hc[l];
	    l++;
	    p = triel[q];
	    firstchild = true;
	    while (p > 0 && c > triec[p]) {
	      q = p;
	      p = trier[q];
	      firstchild = false;
	    }
	    if (p == 0 || c < triec[p]) {   /*964:*/
	      if (trieptr == triesize)
		overflow(S("pattern memory"), triesize);
	      trieptr++;
	      trier[trieptr] = p;
	      p = trieptr;
	      triel[p] = 0;
	      if (firstchild)
		triel[q] = p;
	      else
		trier[q] = p;
	      triec[p] = c;
	      trieo[p] = minquarterword;
	    }
	    /*:964*/
	    q = p;
	  }
	  if (trieo[q] != minquarterword) {
	    printnl(S("! "));
	    print(S("Duplicate pattern"));
	    help1(S("(See Appendix H.)"));
	    error();
	  }
	  trieo[q] = v;
	}
	/*965:*/
	/*:963*/
	if (curcmd == rightbrace)
	  goto _Ldone;
	k = 0;
	hyf[0] = 0;
	digitsensed = false;
	break;

      default:
	printnl(S("! "));
	print(S("Bad "));
	printesc(S("patterns"));
	help1(S("(See Appendix H.)"));
	error();
	break;
      }
    }
_Ldone:   /*:961*/
    return;
  }
  printnl(S("! "));
  print(S("Too late for "));
  printesc(S("patterns"));
  help1(S("All patterns must be given before typesetting begins."));
  error();
  link(garbage) = scantoks(false, false);
  flushlist(defref);

  /*:962*/
}


/*:960*/
/*966:*/
Static void inittrie(void)
{   /*952:*/
  triepointer p;
  long j, k, t;
  triepointer r, s;
  twohalves h;

  /*945:*/
  opstart[0] = -minquarterword;
  for (j = 1; j <= 255; j++)
    opstart[j] = opstart[j - 1] + trieused[j - 1] - minquarterword;
  for (j = 1; j <= trieopptr; j++)
    trieophash[j + trieopsize] = opstart[trieoplang[j - 1]] + trieopval[j - 1];
  for (j = 1; j <= trieopptr; j++) {
    while (trieophash[j + trieopsize] > j) {   /*:945*/
      k = trieophash[j + trieopsize];
      t = hyfdistance[k - 1];
      hyfdistance[k - 1] = hyfdistance[j - 1];
      hyfdistance[j - 1] = t;
      t = hyfnum[k - 1];
      hyfnum[k - 1] = hyfnum[j - 1];
      hyfnum[j - 1] = t;
      t = hyfnext[k - 1];
      hyfnext[k - 1] = hyfnext[j - 1];
      hyfnext[j - 1] = t;
      trieophash[j + trieopsize] = trieophash[k + trieopsize];
      trieophash[k + trieopsize] = k;
    }
  }
  for (p = 0; p <= triesize; p++)
    triehash[p] = 0;
  trieroot = compresstrie(trieroot);
  for (p = 0; p <= trieptr; p++)
    triehash[p] = 0;
  for (p = 0; p <= 255; p++)
    triemin[p] = p + 1;
  trielink(0) = 1;
  triemax = 0;   /*:952*/
  if (trieroot != 0) {
    firstfit(trieroot);
    triepack(trieroot);
  }
  /*958:*/
  h.rh = 0;
  h.UU.U2.b0 = minquarterword;
  h.UU.U2.b1 = minquarterword;
  if (trieroot == 0) {
    for (r = 0; r <= 256; r++)
      trie[r] = h;
    triemax = 256;
  } else {
    triefix(trieroot);
    r = 0;
    do {
      s = trielink(r);
      trie[r] = h;
      r = s;
    } while (r <= triemax);
  }
  triechar(0) = '?';   /*:958*/
  trienotready = false;
}


/*:966*/
/*:942*/
Static void linebreak(long finalwidowpenalty)
{
  /*862:*/
  boolean autobreaking;
  pointer prevp, q, r, s, prevs;
  internalfontnumber f;
  /*:862*/
  /*893:*/
  /* smallnumber */ int j; /* INT */
  uchar c;   /*:893*/

  packbeginline = modeline;   /*816:*/
  link(temphead) = link(head);
  if (ischarnode(tail)) {
    tailappend(newpenalty(infpenalty));
  } else if (type(tail) != gluenode) {
    tailappend(newpenalty(infpenalty));
  } else {
    type(tail) = penaltynode;
    deleteglueref(glueptr(tail));
    flushnodelist(leaderptr(tail));
    penalty(tail) = infpenalty;
  }
  link(tail) = newparamglue(parfillskipcode);
  initcurlang = prevgraf % 65536L;
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
  initlhyf = prevgraf / 4194304L;
  initrhyf = (prevgraf / 65536L) & 63;
  popnest();   /*:816*/
  /*827:*/
  noshrinkerroryet = true;
  checkshrinkage(leftskip);
  checkshrinkage(rightskip);
  q = leftskip;
  r = rightskip;
  background[0] = width(q) + width(r);
  background[1] = 0;
  background[2] = 0;
  background[3] = 0;
  background[4] = 0;
  background[stretchorder(q) + 1] = stretch(q);
  background[stretchorder(r) + 1] += stretch(r);
  background[5] = shrink(q) + shrink(r);   /*:827*/
  /*834:*/
  minimumdemerits = awfulbad;
  minimaldemerits[tightfit - veryloosefit] = awfulbad;
  minimaldemerits[decentfit - veryloosefit] = awfulbad;
  minimaldemerits[loosefit - veryloosefit] = awfulbad;
  minimaldemerits[0] = awfulbad;   /*:834*/
  /*848:*/
  if (parshapeptr == 0) {
    if (hangindent == 0) {
      lastspecialline = 0;
      secondwidth = hsize;
      secondindent = 0;
    } else  /*849:*/
    {   /*:849*/
      lastspecialline = labs(hangafter);
      if (hangafter < 0) {
	firstwidth = hsize - labs(hangindent);
	if (hangindent >= 0)
	  firstindent = hangindent;
	else
	  firstindent = 0;
	secondwidth = hsize;
	secondindent = 0;
      } else {
	firstwidth = hsize;
	firstindent = 0;
	secondwidth = hsize - labs(hangindent);
	if (hangindent >= 0)
	  secondindent = hangindent;
	else
	  secondindent = 0;
      }
    }
  } else {
    lastspecialline = info(parshapeptr) - 1;
    secondwidth = mem[parshapeptr + (lastspecialline + 1) * 2 - memmin].sc;
    secondindent = mem[parshapeptr + lastspecialline * 2 - memmin + 1].sc;
  }
  if (looseness == 0)
    easyline = lastspecialline;
  else {
    easyline = maxhalfword;
    /*:848*/
  }
  /*863:*/
  threshold = pretolerance;
  if (threshold >= 0) {  /*_STAT*/
    if (tracingparagraphs > 0) {   /*_ENDSTAT*/
      begindiagnostic();
      printnl(S("@firstpass"));
    }
    secondpass = false;
    finalpass = false;
  } else {
    threshold = tolerance;
    secondpass = true;
    finalpass = (emergencystretch <= 0);   /*_STAT*/
    if (tracingparagraphs > 0)   /*_ENDSTAT*/
      begindiagnostic();
  }
  while (true) {
    if (threshold > infbad)
      threshold = infbad;
    if (secondpass) {   /*891:*/
      if (trienotready)
	inittrie();
      curlang = initcurlang;
      lhyf = initlhyf;
      rhyf = initrhyf;
    }
    /*:891*/
    /*864:*/
    q = getnode(activenodesize);
    type(q) = unhyphenated;
    fitness(q) = decentfit;
    link(q) = lastactive;
    breaknode(q) = 0;
    linenumber(q) = prevgraf + 1;
    totaldemerits(q) = 0;
    link(active) = q;
    storebackground(1);
    storebackground(2);
    storebackground(3);
    storebackground(4);
    storebackground(5);
    storebackground(6);
    passive = 0;
    printednode = temphead;
    passnumber = 0;
    fontinshortdisplay = nullfont;   /*:864*/
    curp = link(temphead);
    autobreaking = true;
    prevp = curp;
    while ((curp != 0) & (link(active) != lastactive)) {   /*866:*/
      if (ischarnode(curp)) {   /*867:*/
	prevp = curp;
	do {
	  f = font(curp);
	  actwidth += charwidth(f, charinfo(f, character(curp)));
	  curp = link(curp);
	} while (ischarnode(curp));
      }
      /*:867*/
      switch (type(curp)) {

      case hlistnode:
      case vlistnode:
      case rulenode:
	actwidth += width(curp);
	break;

      case whatsitnode:   /*1362:*/
	advpast(curp);   /*:1362*/
	break;

      case gluenode:  /*868:*/
	if (autobreaking) {
	  if (ischarnode(prevp))
	    trybreak(0, unhyphenated);
	  else if (precedesbreak(prevp)) {
	    trybreak(0, unhyphenated);
	  } else if ((type(prevp) == kernnode) &
		     (subtype(prevp) != explicit))
	    trybreak(0, unhyphenated);
	}
	checkshrinkage(glueptr(curp));
	q = glueptr(curp);
	actwidth += width(q);
	activewidth[stretchorder(q) + 1] += stretch(q);
	activewidth[5] += shrink(q);   /*:868*/
	if (secondpass && autobreaking) {   /*894:*/
	  prevs = curp;
	  s = link(prevs);
	  if (s != 0) {  /*896:*/
	    while (true) {
	      if (ischarnode(s)) {
		c = character(s) - minquarterword;
		hf = font(s);
	      } else if (type(s) == ligaturenode) {
		if (ligptr(s) == 0)
		  goto _Llabcontinue;
		q = ligptr(s);
		c = character(q) - minquarterword;
		hf = font(q);
	      } else if ((type(s) == kernnode) & (subtype(s) == normal))
		goto _Llabcontinue;
	      else if (type(s) == whatsitnode) {
		advpast(s);   /*:1363*/
		goto _Llabcontinue;
	      } else
		goto _Ldone1;
	      if (lccode(c) != 0) {
		if (lccode(c) == c || uchyph > 0)
		  goto _Ldone2;
		else
		  goto _Ldone1;
	      }
_Llabcontinue:
	      prevs = s;
	      s = link(prevs);
	    }
_Ldone2:
	    hyfchar = hyphenchar[hf ];
	    if (hyfchar < 0)
	      goto _Ldone1;
	    if (hyfchar > 255)
	      goto _Ldone1;
	    ha = prevs;   /*:896*/
	    if (lhyf + rhyf > 63)   /*897:*/
	      goto _Ldone1;
	    hn = 0;
	    while (true) {
	      if (ischarnode(s)) {
		if (font(s) != hf)
		  goto _Ldone3;
		hyfbchar = character(s);
		c = hyfbchar - minquarterword;
		if (lccode(c) == 0)
		  goto _Ldone3;
		if (hn == 63)
		  goto _Ldone3;
		hb = s;
		hn++;
		hu[hn] = c;
		hc[hn] = lccode(c);
		hyfbchar = nonchar;
	      } else if (type(s) == ligaturenode) {
		if (font(ligchar(s)) != hf) {
		  goto _Ldone3;
		}
		j = hn;
		q = ligptr(s);
		if (q > 0)
		  hyfbchar = character(q);
		while (q > 0) {
		  c = character(q) - minquarterword;
		  if (lccode(c) == 0)
		    goto _Ldone3;
		  if (j == 63)
		    goto _Ldone3;
		  j++;
		  hu[j] = c;
		  hc[j] = lccode(c);
		  q = link(q);
		}
		hb = s;
		hn = j;
		if ((subtype(s)) & 1)
		  hyfbchar = fontbchar[hf ];
		else
		  hyfbchar = nonchar;
	      } else if ((type(s) == kernnode) & (subtype(s) == normal)) {
		hb = s;
		hyfbchar = fontbchar[hf ];
	      } else
		goto _Ldone3;
	      s = link(s);
	    }
_Ldone3:   /*:897*/
	    /*899:*/
	    if (hn < lhyf + rhyf)
	      goto _Ldone1;
	    while (true) {
	      if (!ischarnode(s)) {
		switch (type(s)) {

		case ligaturenode:
		  /* blank case */
		  break;

		case kernnode:
		  if (subtype(s) != normal)
		    goto _Ldone4;
		  break;

		case whatsitnode:
		case gluenode:
		case penaltynode:
		case insnode:
		case adjustnode:
		case marknode:
		  goto _Ldone4;
		  break;

		default:
		  goto _Ldone1;
		  break;
		}
	      }
	      s = link(s);
	    }
_Ldone4:   /*:899*/
	    hyphenate();
	  }
_Ldone1: ;
	}
	/*:894*/
	break;

      case kernnode:
	if (subtype(curp) == explicit) {
	  kernbreak();
	} else
	  actwidth += width(curp);
	break;

      case ligaturenode:
	f = font(ligchar(curp));
	actwidth += charwidth(f,
	    charinfo(f, character(ligchar(curp))));
	break;

      case discnode:   /*869:*/
	s = prebreak(curp);
	discwidth = 0;
	if (s == 0)
	  trybreak(exhyphenpenalty, hyphenated);
	else {
	  do {   /*870:*/
	    if (ischarnode(s)) {
	      f = font(s);
	      discwidth += charwidth(f, charinfo(f, character(s)));
	    } else {
	      switch (type(s)) {   /*:870*/

	      case ligaturenode:
		f = font(ligchar(s));
		discwidth += charwidth(f,
		    charinfo(f, character(ligchar(s))));
		break;

	      case hlistnode:
	      case vlistnode:
	      case rulenode:
	      case kernnode:
		discwidth += width(s);
		break;

	      default:
		confusion(S("disc3"));
		break;
	      }
	    }
	    s = link(s);
	  } while (s != 0);
	  actwidth += discwidth;
	  trybreak(hyphenpenalty, hyphenated);
	  actwidth -= discwidth;
	}
	r = replacecount(curp);
	s = link(curp);
	while (r > 0) {  /*871:*/
	  if (ischarnode(s)) {
	    f = font(s);
	    actwidth += charwidth(f, charinfo(f, character(s)));
	  } else {
	    switch (type(s)) {   /*:871*/

	    case ligaturenode:
	      f = font(ligchar(s));
	      actwidth += charwidth(f,
		  charinfo(f, character(ligchar(s))));
	      break;

	    case hlistnode:
	    case vlistnode:
	    case rulenode:
	    case kernnode:
	      actwidth += width(s);
	      break;

	    default:
	      confusion(S("disc4"));
	      break;
	    }
	  }
	  r--;
	  s = link(s);
	}
	prevp = curp;
	curp = s;
	goto _Ldone5;
	break;
	/*:869*/

      case mathnode:
	autobreaking = (subtype(curp) == after);
	kernbreak();
	break;

      case penaltynode:
	trybreak(penalty(curp), unhyphenated);
	break;

      case marknode:
      case insnode:
      case adjustnode:
	/* blank case */
	break;

      default:
	confusion(S("paragraph"));
	break;
      }
      prevp = curp;
      curp = link(curp);
_Ldone5: ;
    }
    /*:866*/
    if (curp == 0) {   /*873:*/
      trybreak(ejectpenalty, hyphenated);
      if (link(active) != lastactive) {   /*874:*/
	r = link(active);
	fewestdemerits = awfulbad;
	do {
	  if (type(r) != deltanode) {
	    if (totaldemerits(r) < fewestdemerits) {
	      fewestdemerits = totaldemerits(r);
	      bestbet = r;
	    }
	  }
	  r = link(r);
	} while (r != lastactive);
	bestline = linenumber(bestbet);   /*:874*/
	if (looseness == 0)
	  goto _Ldone;
	/*875:*/
	r = link(active);
	actuallooseness = 0;
	do {
	  if (type(r) != deltanode) {
	    linediff = linenumber(r) - bestline;
	    if ( (linediff < actuallooseness && looseness <= linediff) ||
		(linediff > actuallooseness && looseness >= linediff) ) {
	      bestbet = r;
	      actuallooseness = linediff;
	      fewestdemerits = totaldemerits(r);
	    } else if ((linediff == actuallooseness) &
		       (totaldemerits(r) < fewestdemerits)) {
	      bestbet = r;
	      fewestdemerits = totaldemerits(r);
	    }
	  }
	  r = link(r);
	} while (r != lastactive);
	bestline = linenumber(bestbet);   /*:875*/
	if (actuallooseness == looseness || finalpass)
	  goto _Ldone;
      }
    }
    /*:873*/
    /*865:*/
    q = link(active);
    while (q != lastactive) {
      curp = link(q);
      if (type(q) == deltanode)
	freenode(q, deltanodesize);
      else
	freenode(q, activenodesize);
      q = curp;
    }
    q = passive;
    while (q != 0) {   /*:865*/
      curp = link(q);
      freenode(q, passivenodesize);
      q = curp;
    }
    if (secondpass) {  /*_STAT*/
      if (tracingparagraphs > 0)   /*_ENDSTAT*/
	printnl(S("@emergencypass"));
      background[1] += emergencystretch;
      finalpass = true;
      continue;
    }
    if (tracingparagraphs > 0)   /*_ENDSTAT*/
      printnl(S("@secondpass"));
    threshold = tolerance;
    secondpass = true;
    finalpass = (emergencystretch <= 0);
  }
_Ldone:   /*_STAT*/
  if (tracingparagraphs > 0) {   /*_ENDSTAT*/
    enddiagnostic(true);
    normalizeselector();
  }
  /*:863*/
  /*876:*/
  /*:876*/
  postlinebreak(finalwidowpenalty);   /*865:*/
  q = link(active);
  while (q != lastactive) {
    curp = link(q);
    if (type(q) == deltanode)
      freenode(q, deltanodesize);
    else
      freenode(q, activenodesize);
    q = curp;
  }
  q = passive;
  while (q != 0) {   /*:865*/
    curp = link(q);
    freenode(q, passivenodesize);
    q = curp;
  }
  packbeginline = 0;

  /*1363:*/
  /*898:*/
  /*:898*/
  /*_STAT*/
}


/*:815*/
/*934:*/
Static void newhyphexceptions(void)
{
  unsigned char n; /* INT */
  unsigned char j; /* INT */
  hyphpointer h;
  strnumber k, s, t;
  pointer p, q;

  scanleftbrace();
  setcurlang();   /*935:*/
  n = 0;
  p = 0;
  while (true) {   /*:935*/
    getxtoken();
_Lreswitch:
    switch (curcmd) {

    case letter:
    case otherchar:
    case chargiven:   /*937:*/
      if (curchr == '-') {   /*938:*/
	if (n < 63) {
	  q = getavail();
	  link(q) = p;
	  info(q) = n;
	  p = q;
	}
      }  /*:938*/
      else {   /*:937*/
	if (lccode(curchr) == 0) {
	  printnl(S("! "));
	  print(S("Not a letter"));
	  help2(S("Letters in \\hyphenation words must have \\lccode>0."),S("Proceed; I'll ignore the character I just read."));
	  error();
	} else if (n < 63) {
	  n++;
	  hc[n] = lccode(curchr);
	}
      }
      break;

    case charnum:
      scancharnum();
      curchr = curval;
      curcmd = chargiven;
      goto _Lreswitch;
      break;

    case spacer:
    case rightbrace:   /*936:*/
      if (n > 1) {   /*939:*/
	n++;
	hc[n] = curlang;
	h = 0;
	for (j = 1; j <= n; j++) {
	  h = (h + h + hc[j]) % hyphsize;
	}
	s = str_ins(hc+1,n);
	if (hyphcount == hyphsize)
	  overflow(S("exception dictionary"), hyphsize);
	hyphcount++;
	while (hyphword[h] != 0) {  /*941:*/
	  k = hyphword[h];
	  if (flength(k) < flength(s)) {
	    goto _Lfound;
	  }
	  if (flength(k) > flength(s)) {
	    goto _Lnotfound;
	  }
	{ int ress = str_cmp(k,s);
	if(ress < 0) goto _Lfound;
	if(ress > 0) goto _Lnotfound;
	}	
_Lfound:
	  q = hyphlist[h];
	  hyphlist[h] = p;
	  p = q;
	  t = hyphword[h];
	  hyphword[h] = s;
	  s = t;
_Lnotfound:   /*:941*/
	  if (h > 0)
	    h--;
	  else
	    h = hyphsize;
	}
	hyphword[h] = s;
	hyphlist[h] = p;   /*:940*/
      }
      /*:939*/
      if (curcmd == rightbrace)
	goto _Lexit;
      n = 0;
      p = 0;
      break;

    default:
      printnl(S("! "));
      print(S("Improper "));
      printesc(S("hyphenation"));
      print(S(" will be flushed"));
      help2(S("Hyphenation exceptions must contain only letters"),S("and hyphens. But continue; I'll forgive and forget."));
      error();   /*:936*/
      break;
    }
  }
_Lexit: ;
}


/*:934*/
/*968:*/
Static halfword prunepagetop(halfword p)
{
  pointer prevp, q;

  prevp = temphead;
  link(temphead) = p;
  while (p != 0) {
    switch (type(p)) {

    case hlistnode:
    case vlistnode:
    case rulenode:   /*969:*/
      q = newskipparam(splittopskipcode);
      link(prevp) = q;
      link(q) = p;
      if (width(tempptr) > height(p))
	width(tempptr) -= height(p);
      else
	width(tempptr) = 0;
      p = 0;
      break;
      /*:969*/

    case whatsitnode:
    case marknode:
    case insnode:
      prevp = p;
      p = link(prevp);
      break;

    case gluenode:
    case kernnode:
    case penaltynode:
      q = p;
      p = link(q);
      link(q) = 0;
      link(prevp) = p;
      flushnodelist(q);
      break;

    default:
      confusion(S("pruning"));
      break;
    }
  }
  return (link(temphead));
}


/*:968*/
/*970:*/
Static halfword vertbreak(halfword p, long h, long d)
{
  pointer prevp, q, r, bestplace=p /* XXXX */ ;
  long pi=0 /* XXXX */, b, leastcost;
  scaled prevdp;
  smallnumber t;

  prevp = p;
  leastcost = awfulbad;
  setheightzero(1);
  setheightzero(2);
  setheightzero(3);
  setheightzero(4);
  setheightzero(5);
  setheightzero(6);
  prevdp = 0;
  while (true) {  /*972:*/
    if (p == 0)   /*974:*/
      pi = ejectpenalty;
    else {  /*973:*/
      switch (type(p)) {   /*:973*/

      case hlistnode:
      case vlistnode:
      case rulenode:
	curheight += prevdp + height(p);
	prevdp = depth(p);
	goto _Lnotfound;
	break;

      case whatsitnode:   /*1365:*/
	goto _Lnotfound;   /*:1365*/
	break;

      case gluenode:
	if (!precedesbreak(prevp))
	  goto _Lupdateheights_;
	pi = 0;
	break;

      case kernnode:
	if (link(p) == 0)
	  t = penaltynode;
	else
	  t = type(link(p));
	if (t != gluenode)
	  goto _Lupdateheights_;
	pi = 0;
	break;

      case penaltynode:
	pi = penalty(p);
	break;

      case marknode:
      case insnode:
	goto _Lnotfound;
	break;

      default:
	confusion(S("vertbreak"));
	break;
      }
    }
    if (pi < infpenalty)   /*:974*/
    {  /*975:*/
      if (curheight < h) {
	if (activeheight[2] != 0 || activeheight[3] != 0 ||
	    activeheight[4] != 0)
	  b = 0;
	else
	  b = badness(h - curheight, activeheight[1]);
      } else if (curheight - h > activeheight[5])
	b = awfulbad;
      else
	b = badness(curheight - h, activeheight[5]);   /*:975*/
      if (b < awfulbad) {
	if (pi <= ejectpenalty)
	  b = pi;
	else if (b < infbad)
	  b += pi;
	else
	  b = deplorable;
      }
      if (b <= leastcost) {
	bestplace = p;
	leastcost = b;
	bestheightplusdepth = curheight + prevdp;
      }
      if (b == awfulbad || pi <= ejectpenalty)
	goto _Ldone;
    }
    if ((type(p) < gluenode) | (type(p) > kernnode))
      goto _Lnotfound;
_Lupdateheights_:   /*976:*/
    if (type(p) == kernnode)
      q = p;
    else {
      q = glueptr(p);
      activeheight[stretchorder(q) + 1] += stretch(q);
      activeheight[5] += shrink(q);
      if ((shrinkorder(q) != normal) & (shrink(q) != 0)) {
	printnl(S("! "));
	print(S("Infinite glue shrinkage found in box being split"));
	help4(S("The box you are \\vsplitting contains some infinitely"),S("shrinkable glue, e.g., `\\vss' or `\\vskip 0pt minus 1fil'."),S("Such glue doesn't belong there; but you can safely proceed,"),S("since the offensive shrinkability has been made finite."));
	error();
	r = newspec(q);
	shrinkorder(r) = normal;
	deleteglueref(q);
	glueptr(p) = r;
	q = r;
      }
    }
    curheight += prevdp + width(q);
    prevdp = 0;   /*:976*/
_Lnotfound:
    if (prevdp > d) {   /*:972*/
      curheight += prevdp - d;
      prevdp = d;
    }
    prevp = p;
    p = link(prevp);
  }
_Ldone:
  return bestplace;
}


/*:970*/
/*977:*/
Static halfword vsplit(eightbits n, long h)
{
  halfword Result;
  pointer v, p, q;

  v = box(n);
  if (splitfirstmark != 0) {
    deletetokenref(splitfirstmark);
    splitfirstmark = 0;
    deletetokenref(splitbotmark);
    splitbotmark = 0;
  }
  /*978:*/
  if (v == 0) {
    Result = 0;
    goto _Lexit;
  }
  if (type(v) != vlistnode) {   /*:978*/
    printnl(S("! "));
    print(S(""));
    printesc(S("vsplit"));
    print(S(" needs a "));
    printesc(S("vbox"));
    help2(S("The box you are trying to split is an \\hbox."),S("I can't split such a box, so I'll leave it alone."));
    error();
    Result = 0;
    goto _Lexit;
  }
  q = vertbreak(listptr(v), h, splitmaxdepth);   /*979:*/
  p = listptr(v);
  if (p == q)
    listptr(v) = 0;
  else {
    while (true) {
      if (type(p) == marknode) {
	if (splitfirstmark == 0) {
	  splitfirstmark = markptr(p);
	  splitbotmark = splitfirstmark;
	  tokenrefcount(splitfirstmark) += 2;
	} else {
	  deletetokenref(splitbotmark);
	  splitbotmark = markptr(p);
	  addtokenref(splitbotmark);
	}
      }
      if (link(p) == q) {
	link(p) = 0;
	goto _Ldone;
      }
      p = link(p);
    }
  }
_Ldone:   /*:979*/
  q = prunepagetop(q);
  p = listptr(v);
  freenode(v, boxnodesize);
  if (q == 0)
    box(n) = 0;
  else {
    box(n) = vpack(q, 0, additional);
/* p2c: tex1.p: Warning: Too many arguments for foovpack [299] */
  }
  Result = vpackage(p, h, exactly, splitmaxdepth);
_Lexit:
  return Result;
}


/*:977*/
/*985:*/
Static void printtotals(void)
{
  printscaled(pagetotal);
  if (pagesofar[2] != 0) {
    print(S(" plus "));
    printscaled(pagesofar[2]);
    print(S(""));
  }
  if (pagesofar[3] != 0) {
    print(S(" plus "));
    printscaled(pagesofar[3]);
    print(S("fil"));
  }
  if (pagesofar[4] != 0) {
    print(S(" plus "));
    printscaled(pagesofar[4]);
    print(S("fill"));
  }
  if (pagesofar[5] != 0) {
    print(S(" plus "));
    printscaled(pagesofar[5]);
    print(S("filll"));
  }
  if (pageshrink != 0) {
    print(S(" minus "));
    printscaled(pageshrink);
  }
}


/*:985*/
/*987:*/
Static void freezepagespecs(smallnumber s)
{
  pagecontents = s;
  pagegoal = vsize;
  pagemaxdepth = maxdepth;
  pagedepth = 0;
  setpagesofarzero(1);
  setpagesofarzero(2);
  setpagesofarzero(3);
  setpagesofarzero(4);
  setpagesofarzero(5);
  setpagesofarzero(6);
  leastpagecost = awfulbad;   /*_STAT*/
  if (tracingpages <= 0)   /*_ENDSTAT*/
    return;
  begindiagnostic();
  printnl(S("%% goal height="));
  printscaled(pagegoal);
  print(S(", max depth="));
  printscaled(pagemaxdepth);
  enddiagnostic(false);
}  /*:987*/


/*992:*/
Static void boxerror(eightbits n)
{
  error();
  begindiagnostic();
  printnl(S("The following box has been deleted:"));
  showbox(box(n));
  enddiagnostic(true);
  flushnodelist(box(n));
  box(n) = 0;
}


/*:992*/
/*993:*/
Static void ensurevbox(eightbits n)
{
  pointer p;

  p = box(n);
  if (p == 0)
    return;
  if (type(p) != hlistnode)
    return;
  printnl(S("! "));
  print(S("Insertions can only be added to a vbox"));
  help3(S("Tut tut: You're trying to \\insert into a"),S("\\box register that now contains an \\hbox."),S("Proceed, and I'll discard its present contents."));
  boxerror(n);
}


/*:993*/
/*994:*/
/*1012:*/
Static void fireup(halfword c)
{  /*1013:*/
  pointer p, q, r, s, prevp, savesplittopskip;
  uchar n;
  boolean wait;
  long savevbadness;
  scaled savevfuzz;

  if (type(bestpagebreak) == penaltynode) {
    geqworddefine(intbase + outputpenaltycode, penalty(bestpagebreak));
    penalty(bestpagebreak) = infpenalty;
  } else   /*:1013*/
    geqworddefine(intbase + outputpenaltycode, infpenalty);
  if (botmark != 0) {   /*1014:*/
    if (topmark != 0)
      deletetokenref(topmark);
    topmark = botmark;
    addtokenref(topmark);
    deletetokenref(firstmark);
    firstmark = 0;
  }
  if (c == bestpagebreak)   /*1015:*/
    bestpagebreak = 0;
  if (box(255) != 0) {   /*:1015*/
    printnl(S("! "));
    print(S(""));
    printesc(S("box"));
    print(S("255 is not void"));
    help2(S("You shouldn't use \\box255 except in \\output routines."),S("Proceed, and I'll discard its present contents."));
    boxerror(255);
  }
  insertpenalties = 0;
  savesplittopskip = splittopskip;
  if (holdinginserts <= 0) {   /*1018:*/
    r = link(pageinshead);
    while (r != pageinshead) {
      if (bestinsptr(r) != 0) {
	n = subtype(r) - minquarterword;
	ensurevbox(n);
	if (box(n) == 0)
	  box(n) = newnullbox();
	p = box(n) + listoffset;
	while (link(p) != 0)
	  p = link(p);
	lastinsptr(r) = p;
      }
      r = link(r);
    }
  }
  /*:1018*/
  q = holdhead;
  link(q) = 0;
  prevp = pagehead;
  p = link(prevp);
  while (p != bestpagebreak) {
    if (type(p) == insnode) {
      if (holdinginserts <= 0) {   /*1020:*/
	r = link(pageinshead);
	while (subtype(r) != subtype(p))
	  r = link(r);
	if (bestinsptr(r) == 0)   /*1022:*/
	  wait = true;
	else {
	  wait = false;
	  s = lastinsptr(r);
	  link(s) = insptr(p);
	  if (bestinsptr(r) == p) {   /*1021:*/
	    if (type(r) == splitup) {
	      if ((brokenins(r) == p) & (brokenptr(r) != 0)) {
		while (link(s) != brokenptr(r))
		  s = link(s);
		link(s) = 0;
		splittopskip = splittopptr(p);
		insptr(p) = prunepagetop(brokenptr(r));
		if (insptr(p) != 0) {
		  tempptr = vpack(insptr(p), 0, additional);
		  height(p) = height(tempptr) + depth(tempptr);
		  freenode(tempptr, boxnodesize);
		  wait = true;
		}
	      }
	    }
	    bestinsptr(r) = 0;
	    n = subtype(r) - minquarterword;
	    tempptr = listptr(box(n));
	    freenode(box(n), boxnodesize);
	    box(n) = vpack(tempptr, 0, additional);
	  }  /*:1021*/
	  else {
	    while (link(s) != 0)
	      s = link(s);
	    lastinsptr(r) = s;
	  }
	}
	link(prevp) = link(p);
	link(p) = 0;
	if (wait) {
	  link(q) = p;
	  q = p;
	  insertpenalties++;
	} else {
	  deleteglueref(splittopptr(p));
	  freenode(p, insnodesize);
	}
	p = prevp;   /*:1022*/
      }
      /*:1020*/
    } else if (type(p) == marknode) {
      if (firstmark == 0) {
	firstmark = markptr(p);
	addtokenref(firstmark);
      }
      if (botmark != 0)
	deletetokenref(botmark);
      botmark = markptr(p);
      addtokenref(botmark);
    }
    prevp = p;
    p = link(prevp);
  }
  splittopskip = savesplittopskip;   /*1017:*/
  if (p != 0) {
    if (link(contribhead) == 0) {
      if (nestptr == 0)
	tail = pagetail;
      else
	contribtail = pagetail;
    }
    link(pagetail) = link(contribhead);
    link(contribhead) = p;
    link(prevp) = 0;
  }
  savevbadness = vbadness;
  vbadness = infbad;
  savevfuzz = vfuzz;
  vfuzz = maxdimen;
  box(255) = vpackage(link(pagehead), bestsize, exactly, pagemaxdepth);
  vbadness = savevbadness;
  vfuzz = savevfuzz;
  if (lastglue != maxhalfword)   /*991:*/
    deleteglueref(lastglue);
  pagecontents = empty;
  pagetail = pagehead;
  link(pagehead) = 0;
  lastglue = maxhalfword;
  lastpenalty = 0;
  lastkern = 0;
  pagedepth = 0;
  pagemaxdepth = 0;   /*:991*/
  if (q != holdhead) {   /*:1017*/
    link(pagehead) = link(holdhead);
    pagetail = q;
  }
  /*1019:*/
  r = link(pageinshead);
  while (r != pageinshead) {
    q = link(r);
    freenode(r, pageinsnodesize);
    r = q;
  }
  link(pageinshead) = pageinshead;   /*:1019*/
  /*:1014*/
  if (topmark != 0 && firstmark == 0) {
    firstmark = topmark;
    addtokenref(topmark);
  }
  if (outputroutine != 0) {   /*1023:*/
    if (deadcycles < maxdeadcycles) {   /*1024:*/
      outputactive = true;
      deadcycles++;
      pushnest();
      mode = -vmode;
      prevdepth = ignoredepth;
      modeline = -line;
      begintokenlist(outputroutine, outputtext);
      newsavelevel(outputgroup);
      normalparagraph();
      scanleftbrace();
      goto _Lexit;
    }
    /*:1024*/
    printnl(S("! "));
    print(S("Output loop---"));
    printint(deadcycles);
    print(S(" consecutive dead cycles"));
    help3(S("I've concluded that your \\output is awry; it never does a"),S("\\shipout, so I'm shipping \\box255 out myself. Next time"),S("increase \\maxdeadcycles if you want me to be more patient!"));
    error();
  }
  if (link(pagehead) != 0) {
    if (link(contribhead) == 0) {
      if (nestptr == 0)
	tail = pagetail;
      else
	contribtail = pagetail;
    } else
      link(pagetail) = link(contribhead);
    link(contribhead) = link(pagehead);
    link(pagehead) = 0;
    pagetail = pagehead;
  }
  shipout(box(255));
  box(255) = 0;   /*:1023*/
_Lexit: ;

  /*1016:*/
  /*:1016*/
  /*1025:*/
  /*:1025*/
}


/*:1012*/
Static void buildpage(void)
{
  pointer p, q, r;
  long b, c, pi=0 /* XXXX */;
  uchar n;
  scaled delta, h, w;

  if (link(contribhead) == 0 || outputactive)
    goto _Lexit;
  do {
_Llabcontinue:
    p = link(contribhead);   /*996:*/
    if (lastglue != maxhalfword)
      deleteglueref(lastglue);
    lastpenalty = 0;
    lastkern = 0;
    if (type(p) == gluenode) {   /*997:*/
      lastglue = glueptr(p);
      addglueref(lastglue);
    } else {   /*:996*/
      lastglue = maxhalfword;
      if (type(p) == penaltynode)
	lastpenalty = penalty(p);
      else if (type(p) == kernnode)
	lastkern = width(p);
    }
    /*1000:*/
    switch (type(p)) {   /*:1000*/

    case hlistnode:
    case vlistnode:
    case rulenode:
      if (pagecontents < boxthere) {   /*1001:*/
	if (pagecontents == empty)
	  freezepagespecs(boxthere);
	else
	  pagecontents = boxthere;
	q = newskipparam(topskipcode);
	if (width(tempptr) > height(p))
	  width(tempptr) -= height(p);
	else
	  width(tempptr) = 0;
	link(q) = p;
	link(contribhead) = q;
	goto _Llabcontinue;
      } else  /*1002:*/
      {   /*:1002*/
	pagetotal += pagedepth + height(p);
	pagedepth = depth(p);
	goto _Lcontribute_;
      }
      /*:1001*/
      break;

    case whatsitnode:   /*1364:*/
      goto _Lcontribute_;   /*:1364*/
      break;

    case gluenode:
      if (pagecontents < boxthere)
	goto _Ldone1;
      if (!precedesbreak(pagetail))
	goto _Lupdateheights_;
      pi = 0;
      break;

    case kernnode:
      if (pagecontents < boxthere)
	goto _Ldone1;
      if (link(p) == 0)
	goto _Lexit;
      if (type(link(p)) != gluenode)
	goto _Lupdateheights_;
      pi = 0;
      break;

    case penaltynode:
      if (pagecontents < boxthere)
	goto _Ldone1;
      pi = penalty(p);
      break;

    case marknode:
      goto _Lcontribute_;
      break;

    case insnode:   /*1008:*/
      if (pagecontents == empty)
	freezepagespecs(insertsonly);
      n = subtype(p);
      r = pageinshead;
      while (n >= subtype(link(r)))
	r = link(r);
      n -= minquarterword;
      if (subtype(r) != n) {   /*1009:*/
	q = getnode(pageinsnodesize);
	link(q) = link(r);
	link(r) = q;
	r = q;
	subtype(r) = n;
	type(r) = inserting;
	ensurevbox(n);
	if (box(n) == 0)
	  height(r) = 0;
	else
	  height(r) = height(box(n)) + depth(box(n));
	bestinsptr(r) = 0;
	q = skip(n);
	if (count(n) == 1000)
	  h = height(r);
	else
	  h = xovern(height(r), 1000) * count(n);
	pagegoal += -h - width(q);
	pagesofar[stretchorder(q) + 2] += stretch(q);
	pageshrink += shrink(q);
	if ((shrinkorder(q) != normal) & (shrink(q) != 0)) {
	  printnl(S("! "));
	  print(S("Infinite glue shrinkage inserted from "));
	  printesc(S("skip"));
	  printint(n);
	  help3(S("The correction glue for page breaking with insertions"),S("must have finite shrinkability. But you may proceed,"),S("since the offensive shrinkability has been made finite."));
	  error();
	}
      }
      /*:1009*/
      if (type(r) == splitup)
	insertpenalties += floatcost(p);
      else {
	lastinsptr(r) = p;
	delta = pagegoal - pagetotal - pagedepth + pageshrink;
	if (count(n) == 1000)
	  h = height(p);
	else
	  h = xovern(height(p), 1000) * count(n);
	if ((h <= 0 || h <= delta) & (height(p) + height(r) <=
				      dimen(n))) {
	  pagegoal -= h;
	  height(r) += height(p);
	} else  /*1010:*/
	{   /*:1010*/
	  if (count(n) <= 0)
	    w = maxdimen;
	  else {
	    w = pagegoal - pagetotal - pagedepth;
	    if (count(n) != 1000)
	      w = xovern(w, count(n)) * 1000;
	  }
	  if (w > dimen(n) - height(r))
	    w = dimen(n) - height(r);
	  q = vertbreak(insptr(p), w, depth(p));
	  height(r) += bestheightplusdepth;   /*_STAT*/
	  if (tracingpages > 0) {   /*1011:*/
	    begindiagnostic();
	    printnl(S("% split"));
	    printint(n);
	    print(S(" to "));
	    printscaled(w);
	    printchar(',');
	    printscaled(bestheightplusdepth);
	    print(S(" p="));
	    if (q == 0)
	      printint(ejectpenalty);
	    else if (type(q) == penaltynode)
	      printint(penalty(q));
	    else
	      printchar('0');
	    enddiagnostic(false);
	  }
	  /*:1011*/
	  /*_ENDSTAT*/
	  if (count(n) != 1000)
	    bestheightplusdepth = xovern(bestheightplusdepth, 1000) * count(n);
	  pagegoal -= bestheightplusdepth;
	  type(r) = splitup;
	  brokenptr(r) = q;
	  brokenins(r) = p;
	  if (q == 0)
	    insertpenalties += ejectpenalty;
	  else if (type(q) == penaltynode)
	    insertpenalties += penalty(q);
	}
      }
      goto _Lcontribute_;
      break;
      /*:1008*/

    default:
      confusion(S("page"));
      break;
    }
    /*1005:*/
    if (pi < infpenalty)   /*:1005*/
    {  /*1007:*/
      if (pagetotal < pagegoal) {
	if (pagesofar[3] != 0 || pagesofar[4] != 0 || pagesofar[5] != 0)
	  b = 0;
	else
	  b = badness(pagegoal - pagetotal, pagesofar[2]);
      } else if (pagetotal - pagegoal > pageshrink)
	b = awfulbad;
      else
	b = badness(pagetotal - pagegoal, pageshrink);   /*:1007*/
      if (b < awfulbad) {
	if (pi <= ejectpenalty)
	  c = pi;
	else if (b < infbad)
	  c = b + pi + insertpenalties;
	else
	  c = deplorable;
      } else
	c = b;
      if (insertpenalties >= 10000)   /*_STAT*/
	c = awfulbad;
      if (tracingpages > 0) {   /*1006:*/
	begindiagnostic();
	printnl('%');
	print(S(" t="));
	printtotals();
	print(S(" g="));
	printscaled(pagegoal);
	print(S(" b="));
	if (b == awfulbad)
	  printchar('*');
	else
	  printint(b);
	print(S(" p="));
	printint(pi);
	print(S(" c="));
	if (c == awfulbad)
	  printchar('*');
	else
	  printint(c);
	if (c <= leastpagecost)
	  printchar('#');
	enddiagnostic(false);
      }
      /*:1006*/
      /*_ENDSTAT*/
      if (c <= leastpagecost) {
	bestpagebreak = p;
	bestsize = pagegoal;
	leastpagecost = c;
	r = link(pageinshead);
	while (r != pageinshead) {
	  bestinsptr(r) = lastinsptr(r);
	  r = link(r);
	}
      }
      if (c == awfulbad || pi <= ejectpenalty) {
	fireup(p);
	if (outputactive)
	  goto _Lexit;
	goto _Ldone;
      }
    }
    if ((type(p) < gluenode) | (type(p) > kernnode))
      goto _Lcontribute_;
_Lupdateheights_:   /*1004:*/
    if (type(p) == kernnode)
      q = p;
    else {
      q = glueptr(p);
      pagesofar[stretchorder(q) + 2] += stretch(q);
      pageshrink += shrink(q);
      if ((shrinkorder(q) != normal) & (shrink(q) != 0)) {
	printnl(S("! "));
	print(S("Infinite glue shrinkage found on current page"));
	help4(S("The page about to be output contains some infinitely"),S("shrinkable glue, e.g., `\\vss' or `\\vskip 0pt minus 1fil'."),S("Such glue doesn't belong there; but you can safely proceed,"),S("since the offensive shrinkability has been made finite."));
	error();
	r = newspec(q);
	shrinkorder(r) = normal;
	deleteglueref(q);
	glueptr(p) = r;
	q = r;
      }
    }
    pagetotal += pagedepth + width(q);
    pagedepth = 0;   /*:1004*/
_Lcontribute_:   /*1003:*/
    if (pagedepth > pagemaxdepth) {   /*:1003*/
      pagetotal += pagedepth - pagemaxdepth;
      pagedepth = pagemaxdepth;
    }
    /*998:*/
    link(pagetail) = p;
    pagetail = p;
    link(contribhead) = link(p);
    link(p) = 0;
    goto _Ldone;   /*:998*/
_Ldone1:   /*999:*/
    link(contribhead) = link(p);
    link(p) = 0;   /*:999*/
    flushnodelist(p);
_Ldone: ;   /*:997*/
  } while (link(contribhead) != 0);   /*995:*/
  if (nestptr == 0)
    tail = contribhead;
  else
    contribtail = contribhead;   /*:995*/
_Lexit: ;
}


/*:994*/
/*1030:*/
/*1043:*/
Static void appspace(void)
{
  pointer q;

  if (spacefactor >= 2000 && xspaceskip != zeroglue)
    q = newparamglue(xspaceskipcode);
  else {
    if (spaceskip != zeroglue)
      mainp = spaceskip;
    else {   /*1042:*/
      mainp = fontglue[curfont ];
      if (mainp == 0) {
	fontindex mmaink;
	mainp = newspec(zeroglue);
	mmaink = parambase[curfont ] + spacecode;
#if 1
	maink = mmaink;
#endif
	width(mainp) = fontinfo[maink].sc;
	stretch(mainp) = fontinfo[mmaink + 1].sc;
	shrink(mainp) = fontinfo[mmaink + 2].sc;
	fontglue[curfont ] = mainp;
      }
    }
    mainp = newspec(mainp);   /*1044:*/
    if (spacefactor >= 2000)
      width(mainp) += extraspace(curfont);
    stretch(mainp) = xnoverd(stretch(mainp), spacefactor, 1000);
    shrink(mainp) = xnoverd(shrink(mainp), 1000, spacefactor);
	/*:1044*/
    q = newglue(mainp);
    gluerefcount(mainp) = 0;
  }
  link(tail) = q;
  tail = q;

  /*:1042*/
}


/*:1043*/
/*1047:*/
Static void insertdollarsign(void)
{
  backinput();
  curtok = mathshifttoken + '$';
  printnl(S("! "));
  print(S("Missing $ inserted"));
  help2(S("I've inserted a begin-math/end-math symbol since I think"),S("you left one out. Proceed, with fingers crossed."));
  inserror();
}


/*:1047*/
/*1049:*/
Static void youcant(void)
{
  printnl(S("! "));
  print(S("You can't use `"));
  printcmdchr(curcmd, curchr);
  print(S("' in "));
  printmode(mode);
}


/*:1049*/
/*1050:*/
Static void reportillegalcase(void)
{
  youcant();
  help4(S("Sorry, but I'm not programmed to handle this case;"),S("I'll just pretend that you didn't ask for it."),S("If you're in the wrong mode, you might be able to"),S("return to the right one by typing `I}' or `I$' or `I\\par'."));
  error();
}


/*:1050*/
/*1051:*/
Static boolean privileged(void)
{
  if (mode > 0)
    return true;
  else {
    reportillegalcase();
    return false;
  }
}


/*:1051*/
/*1054:*/
Static boolean itsallover(void)
{
  boolean Result;

  if (privileged()) {
    if (pagehead == pagetail && head == tail && deadcycles == 0) {
      Result = true;
      goto _Lexit;
    }
    backinput();
    tailappend(newnullbox());
    width(tail) = hsize;
    tailappend(newglue(fillglue));
    tailappend(newpenalty(-1073741824L));
    buildpage();
  }
  Result = false;
_Lexit:
  return Result;
}


/*:1054*/
/*1060:*/
Static void appendglue(void)
{
  smallnumber s;

  s = curchr;
  switch (s) {

  case filcode:
    curval = filglue;
    break;

  case fillcode:
    curval = fillglue;
    break;

  case sscode:
    curval = ssglue;
    break;

  case filnegcode:
    curval = filnegglue;
    break;

  case skipcode:
    scanglue(glueval);
    break;

  case mskipcode:
    scanglue(muval);
    break;
  }
  tailappend(newglue(curval));
  if (s < skipcode)
    return;
  (gluerefcount(curval))--;
  if (s > skipcode)
    subtype(tail) = muglue;
}  /*:1060*/


/*1061:*/
Static void appendkern(void)
{
  quarterword s;

  s = curchr;
  scandimen(s == muglue, false, false);
  tailappend(newkern(curval));
  subtype(tail) = s;
}


/*:1061*/
/*1064:*/
Static void offsave(void)
{
  pointer p;

  if (curgroup == bottomlevel) {   /*1066:*/
    printnl(S("! "));
    print(S("Extra "));
    printcmdchr(curcmd, curchr);
    help1(S("Things are pretty mixed up, but I think the worst is over."));
    error();
    return;
  }  /*:1066*/
  backinput();
  p = getavail();
  link(temphead) = p;
  printnl(S("! "));
  print(S("Missing "));   /*1065:*/
  switch (curgroup) {   /*:1065*/

  case semisimplegroup:
    info(p) = cstokenflag + frozenendgroup;
    printesc(S("endgroup"));
    break;

  case mathshiftgroup:
    info(p) = mathshifttoken + '$';
    printchar('$');
    break;

  case mathleftgroup:
    info(p) = cstokenflag + frozenright;
    link(p) = getavail();
    p = link(p);
    info(p) = othertoken + '.';
    printesc(S("right."));
    break;

  default:
    info(p) = rightbracetoken + '}';
    printchar('}');
    break;
  }
  print(S(" inserted"));
  inslist(link(temphead));
  help5(S("I've inserted something that you may have forgotten."),S("(See the <inserted text> above.)"),S("With luck, this will get me unwedged. But if you"),S("really didn't forget anything, try typing `2' now; then"),S("my insertion and my current dilemma will both disappear."));
  error();
}


/*:1064*/
/*1069:*/
Static void extrarightbrace(void)
{
  printnl(S("! "));
  print(S("Extra }, or forgotten "));
  switch (curgroup) {

  case semisimplegroup:
    printesc(S("endgroup"));
    break;

  case mathshiftgroup:
    printchar('$');
    break;

  case mathleftgroup:
    printesc(S("right"));
    break;
  }
  help5(S("I've deleted a group-closing symbol because it seems to be"),S("spurious, as in `$x}$'. But perhaps the } is legitimate and"),S("you forgot something else, as in `\\hbox{$x}'. In such cases"),S("the way to recover is to insert both the forgotten and the"),S("deleted material, e.g., by typing `I$}'."));
  error();
  alignstate++;
}


/*:1069*/
/*1070:*/
Static void normalparagraph(void)
{
  if (looseness != 0)
    eqworddefine(intbase + loosenesscode, 0);
  if (hangindent != 0)
    eqworddefine(dimenbase + hangindentcode, 0);
  if (hangafter != 1)
    eqworddefine(intbase + hangaftercode, 1);
  if (parshapeptr != 0)
    eqdefine(parshapeloc, shaperef, 0);
}  /*:1070*/


/*1075:*/
Static void boxend(long boxcontext)
{
  pointer p;

  if (boxcontext < boxflag) {   /*1076:*/
    if (curbox == 0)
      return;
    shiftamount(curbox) = boxcontext;
    if (labs(mode) == vmode) {
      appendtovlist(curbox);
      if (adjusttail != 0) {
	if (adjusthead != adjusttail) {
	  link(tail) = link(adjusthead);
	  tail = adjusttail;
	}
	adjusttail = 0;
      }
      if (mode > 0)
	buildpage();
      return;
    }
    if (labs(mode) == hmode)
      spacefactor = 1000;
    else {
      p = newnoad();
      mathtype(nucleus(p)) = subbox;
      info(nucleus(p)) = curbox;
      curbox = p;
    }
    link(tail) = curbox;
    tail = curbox;
    return;
  }  /*:1076*/
  if (boxcontext < shipoutflag) {   /*1077:*/
    if (boxcontext < boxflag + 256)
      eqdefine(boxbase - boxflag + boxcontext, boxref, curbox);
    else   /*:1077*/
      geqdefine(boxbase - boxflag + boxcontext - 256, boxref, curbox);
    return;
  }
  if (curbox == 0)
    return;
  if (boxcontext <= shipoutflag)   /*1078:*/
  {  /*404:*/
    shipout(curbox);
    return;
  }
  /*:1078*/
  do {
    getxtoken();   /*:404*/
  } while (curcmd == spacer || curcmd == relax);
  if ( (curcmd == hskip && labs(mode) != vmode) ||
      (curcmd == vskip && labs(mode) == vmode) ||
      (curcmd == mskip && labs(mode) == mmode) ) {
    appendglue();
    subtype(tail) = boxcontext - leaderflag + aleaders;
    leaderptr(tail) = curbox;
    return;
  }
  printnl(S("! "));
  print(S("Leaders not followed by proper glue"));
  help3(S("You should say `\\leaders <box or rule><hskip or vskip>'."),S("I found the <box or rule>, but there's no suitable"),S("<hskip or vskip>, so I'm ignoring these leaders."));
  backerror();
  flushnodelist(curbox);
}


/*:1075*/
/*1079:*/
Static void beginbox(long boxcontext)
{
  pointer p, q;
  quarterword m;
  halfword k;
  eightbits n;
  quarterword FORLIM;

  switch (curchr) {

  case boxcode:
    scaneightbitint();
    curbox = box(curval);
    box(curval) = 0;
    break;

  case copycode:
    scaneightbitint();
    curbox = copynodelist(box(curval));
    break;

  case lastboxcode:   /*1080:*/
    curbox = 0;
    if (labs(mode) == mmode) {
      youcant();
      help1(S("Sorry; this \\lastbox will be void."));
      error();
    } else if (mode == vmode && head == tail) {
      youcant();
      help2(S("Sorry...I usually can't take things from the current page."),S("This \\lastbox will therefore be void."));
      error();
    } else {
      if (!ischarnode(tail)) {
	if ((type(tail) == hlistnode) | (type(tail) == vlistnode))
	{   /*1081:*/
	  q = head;
	  do {
	    p = q;
	    if (!ischarnode(q)) {
	      if (type(q) == discnode) {
		FORLIM = replacecount(q);
		for (m = 1; m <= FORLIM; m++)
		  p = link(p);
		if (p == tail)
		  goto _Ldone;
	      }
	    }
	    q = link(p);
	  } while (q != tail);
	  curbox = tail;
	  shiftamount(curbox) = 0;
	  tail = p;
	  link(p) = 0;
_Ldone: ;
	}
	/*:1081*/
      }
    }
    break;
    /*:1080*/

  case vsplitcode:   /*1082:*/
    scaneightbitint();
    n = curval;
    if (!scankeyword(S("to"))) {
      printnl(S("! "));
      print(S("Missing `to' inserted"));
      help2(S("I'm working on `\\vsplit<box number> to <dimen>';"),S("will look for the <dimen> next."));
      error();
    }
    scannormaldimen();
    curbox = vsplit(n, curval);
    break;
    /*:1082*/
    /*1083:*/

  default:
    k = curchr - vtopcode;
    saved(0) = boxcontext;
    if (k == hmode) {
      if (boxcontext < boxflag && labs(mode) == vmode)
	scanspec(adjustedhboxgroup, true);
      else
	scanspec(hboxgroup, true);
    } else {
      if (k == vmode)
	scanspec(vboxgroup, true);
      else {
	scanspec(vtopgroup, true);
	k = vmode;
      }
      normalparagraph();
    }
    pushnest();
    mode = -k;
    if (k == vmode) {
      prevdepth = ignoredepth;
      if (everyvbox != 0)
	begintokenlist(everyvbox, everyvboxtext);
    } else {
      spacefactor = 1000;
      if (everyhbox != 0)
	begintokenlist(everyhbox, everyhboxtext);
    }
    goto _Lexit;   /*:1083*/
    break;
  }
  boxend(boxcontext);
_Lexit: ;
}


/*:1079*/
/*1084:*/
Static void scanbox(long boxcontext)
{   /*404:*/
  do {
    getxtoken();   /*:404*/
  } while (curcmd == spacer || curcmd == relax);
  if (curcmd == makebox) {
    beginbox(boxcontext);
    return;
  }
  if (boxcontext >= leaderflag && (curcmd == hrule || curcmd == vrule)) {
    curbox = scanrulespec();
    boxend(boxcontext);
    return;
  }
  printnl(S("! "));
  print(S("A <box> was supposed to be here"));
  help3(S("I was expecting to see \\hbox or \\vbox or \\copy or \\box or"),S("something like that. So you might find something missing in"),S("your output. But keep trying; you can fix this later."));
  backerror();
}


/*:1084*/
/*1086:*/
Static void package(smallnumber c)
{
  scaled h, d;
  pointer p;

  d = boxmaxdepth;
  unsave();
  saveptr -= 3;
  if (mode == -hmode)
    curbox = hpack(link(head), saved(2), saved(1));
  else {
    curbox = vpackage(link(head), saved(2), saved(1), d);
    if (c == vtopcode) {   /*1087:*/
      h = 0;
      p = listptr(curbox);
      if (p != 0) {
	if (type(p) <= rulenode)
	  h = height(p);
      }
      depth(curbox) += height(curbox) - h;
      height(curbox) = h;
    }
    /*:1087*/
  }
  popnest();
  boxend(saved(0));
}


/*:1086*/
/*1091:*/
Static smallnumber normmin(long h)
{
  if (h <= 0)
    return 1;
  else if (h >= 63)
    return 63;
  else
    return h;
}


Static void newgraf(boolean indented)
{
  prevgraf = 0;
  if (mode == vmode || head != tail) {
    tailappend(newparamglue(parskipcode));
  }
  pushnest();
  mode = hmode;
  spacefactor = 1000;
  setcurlang();
  clang = curlang;
  prevgraf = (normmin(lefthyphenmin) * 64 + normmin(righthyphenmin)) * 65536L +
	     curlang;
  if (indented) {
    tail = newnullbox();
    link(head) = tail;
    width(tail) = parindent;
  }
  if (everypar != 0)
    begintokenlist(everypar, everypartext);
  if (nestptr == 1)
    buildpage();
}


/*:1091*/
/*1093:*/
Static void indentinhmode(void)
{
  pointer p, q;

  if (curchr <= 0)
    return;
  p = newnullbox();
  width(p) = parindent;
  if (labs(mode) == hmode)
    spacefactor = 1000;
  else {
    q = newnoad();
    mathtype(nucleus(q)) = subbox;
    info(nucleus(q)) = p;
    p = q;
  }
  tailappend(p);
}


/*:1093*/
/*1095:*/
Static void headforvmode(void)
{
  if (mode < 0) {
    if (curcmd != hrule) {
      offsave();
      return;
    }
    printnl(S("! "));
    print(S("You can't use `"));
    printesc(S("hrule"));
    print(S("' here except with leaders"));
    help2(S("To put a horizontal rule in an hbox or an alignment,"),S("you should use \\leaders or \\hrulefill (see The TeXbook)."));
    error();
    return;
  }
  backinput();
  curtok = partoken;
  backinput();
  tokentype = inserted;
}


/*:1095*/
/*1096:*/
Static void endgraf(void)
{
  if (mode != hmode)
    return;
  if (head == tail)
    popnest();
  else
    linebreak(widowpenalty);
  normalparagraph();
  errorcount = 0;
}


/*:1096*/
/*1099:*/
Static void begininsertoradjust(void)
{
  if (curcmd == vadjust)
    curval = 255;
  else {
    scaneightbitint();
    if (curval == 255) {
      printnl(S("! "));
      print(S("You can't "));
      printesc(S("insert"));
      printint(255);
      help1(S("I'm changing to \\insert0; box 255 is special."));
      error();
      curval = 0;
    }
  }
  saved(0) = curval;
  saveptr++;
  newsavelevel(insertgroup);
  scanleftbrace();
  normalparagraph();
  pushnest();
  mode = -vmode;
  prevdepth = ignoredepth;
}


/*:1099*/
/*1101:*/
Static void makemark(void)
{
  pointer p;

  p = scantoks(false, true);
  p = getnode(smallnodesize);
  type(p) = marknode;
  subtype(p) = 0;
  markptr(p) = defref;
  link(tail) = p;
  tail = p;
}


/*:1101*/
/*1103:*/
Static void appendpenalty(void)
{
  scanint();
  tailappend(newpenalty(curval));
  if (mode == vmode)
    buildpage();
}


/*:1103*/
/*1105:*/
Static void deletelast(void)
{
  pointer p, q;
  quarterword m, FORLIM;

  if (mode == vmode && tail == head) {   /*1106:*/
    if (curchr != gluenode || lastglue != maxhalfword) {
      youcant();
      help2(S("Sorry...I usually can't take things from the current page."),S("Try `I\\vskip-\\lastskip' instead."));
      if (curchr == kernnode)
	helpline[0] = S("Try `I\\kern-\\lastkern' instead.");
      else if (curchr != gluenode)
	helpline[0] = S("Perhaps you can make the output routine do it.");
      error();
    }
  }  /*:1106*/
  else {
    if (!ischarnode(tail)) {
      if (type(tail) == curchr) {
	q = head;
	do {
	  p = q;
	  if (!ischarnode(q)) {
	    if (type(q) == discnode) {
	      FORLIM = replacecount(q);
	      for (m = 1; m <= FORLIM; m++)
		p = link(p);
	      if (p == tail)
		goto _Lexit;
	    }
	  }
	  q = link(p);
	} while (q != tail);
	link(p) = 0;
	flushnodelist(tail);
	tail = p;
      }
    }
  }
_Lexit: ;
}


/*:1105*/
/*1110:*/
Static void unpackage(void)
{
  pointer p;
  char c;

  c = curchr;
  scaneightbitint();
  p = box(curval);
  if (p == 0)
    goto _Lexit;
  if ((labs(mode) == mmode) |
      ((labs(mode) == vmode) & (type(p) != vlistnode)) |
      ((labs(mode) == hmode) & (type(p) != hlistnode))) {
    printnl(S("! "));
    print(S("Incompatible list can't be unboxed"));
    help3(S("Sorry, Pandora. (You sneaky devil.)"),S("I refuse to unbox an \\hbox in vertical mode or vice versa."),S("And I can't open any boxes in math mode."));
    error();
    goto _Lexit;
  }
  if (c == copycode)
    link(tail) = copynodelist(listptr(p));
  else {
    link(tail) = listptr(p);
    box(curval) = 0;
    freenode(p, boxnodesize);
  }
  while (link(tail) != 0)
    tail = link(tail);
_Lexit: ;
}


/*:1110*/
/*1113:*/
Static void appenditaliccorrection(void)
{
  pointer p;
  internalfontnumber f;

  if (tail != head) {
    if (ischarnode(tail))
      p = tail;
    else if (type(tail) == ligaturenode) {
      p = ligchar(tail);
    } else
      goto _Lexit;
    f = font(p);
    tailappend(newkern(charitalic(f, charinfo(f, character(p)))));
    subtype(tail) = explicit;
  }
_Lexit: ;
}


/*:1113*/
/*1117:*/
Static void appenddiscretionary(void)
{
  long c;

  tailappend(newdisc());
  if (curchr == 1) {
    c = hyphenchar[curfont ];
    if (c >= 0) {
      if (c < 256)
	prebreak(tail) = newcharacter(curfont, c);
    }
    return;
  }
  saveptr++;
  saved(-1) = 0;
  newsavelevel(discgroup);
  scanleftbrace();
  pushnest();
  mode = -hmode;
  spacefactor = 1000;
}


/*:1117*/
/*1119:*/
Static void builddiscretionary(void)
{
  pointer p, q;
  long n;

  unsave();   /*1121:*/
  q = head;
  p = link(q);
  n = 0;
  while (p != 0) {
    if (!ischarnode(p)) {
      if (type(p) > rulenode) {
	if (type(p) != kernnode) {
	  if (type(p) != ligaturenode) {
	    printnl(S("! "));
	    print(S("Improper discretionary list"));
	    help1(S("Discretionary lists must contain only boxes and kerns."));
	    error();
	    begindiagnostic();
	    printnl(S("The following discretionary sublist has been deleted:"));
	    showbox(p);
	    enddiagnostic(true);
	    flushnodelist(p);
	    link(q) = 0;
	    goto _Ldone;
	  }
	}
      }
    }
    q = p;
    p = link(q);
    n++;
  }
_Ldone:   /*:1121*/
  p = link(head);
  popnest();
  switch (saved(-1)) {

  case 0:
    prebreak(tail) = p;
    break;

  case 1:
    postbreak(tail) = p;
    break;

  case 2:   /*1120:*/
    if (n > 0 && labs(mode) == mmode) {
      printnl(S("! "));
      print(S("Illegal math "));
      printesc(S("discretionary"));
      help2(S("Sorry: The third part of a discretionary break must be"),S("empty, in math formulas. I had to delete your third part."));
      flushnodelist(p);
      n = 0;
      error();
    } else
      link(tail) = p;
    if (n <= maxquarterword)
      replacecount(tail) = n;
    else {
      printnl(S("! "));
      print(S("Discretionary list is too long"));
      help2(S("Wow---I never thought anybody would tweak me here."),S("You can't seriously need such a huge discretionary list?"));
      error();
    }
    if (n > 0)
      tail = q;
    saveptr--;
    goto _Lexit;
    break;
    /*:1120*/
  }
  (saved(-1))++;
  newsavelevel(discgroup);
  scanleftbrace();
  pushnest();
  mode = -hmode;
  spacefactor = 1000;
_Lexit: ;
}


/*:1119*/
/*1123:*/
Static void makeaccent(void)
{
  double s, t;
  pointer p, q, r;
  internalfontnumber f;
  scaled a, h, x, w, delta;
  fourquarters i;

  scancharnum();
  f = curfont;
  p = newcharacter(f, curval);
  if (p == 0)
    return;
  x = xheight(f);
  s = slant(f) / 65536.0;
  a = charwidth(f, charinfo(f, character(p)));
  doassignments();   /*1124:*/
  q = 0;
  f = curfont;
  if (curcmd == letter || curcmd == otherchar || curcmd == chargiven)
    q = newcharacter(f, curchr);
  else if (curcmd == charnum) {
    scancharnum();
    q = newcharacter(f, curval);
  } else
    backinput();
  if (q != 0) {   /*1125:*/
    t = slant(f) / 65536.0;
    i = charinfo(f, character(q));
    w = charwidth(f, i);
    h = charheight(f, heightdepth(i));
    if (h != x) {
      p = hpack(p, 0, additional);
      shiftamount(p) = x - h;
    }
    delta = (long)floor((w - a) / 2.0 + h * t - x * s + 0.5);
    r = newkern(delta);
    subtype(r) = acckern;
    link(tail) = r;
    link(r) = p;
    tail = newkern(-a - delta);
    subtype(tail) = acckern;
    link(p) = tail;
    p = q;
  }
  /*:1125*/
  link(tail) = p;
  tail = p;
  spacefactor = 1000;

  /*:1124*/
}


/*:1123*/
/*1127:*/
Static void alignerror(void)
{
  if (labs(alignstate) > 2) {   /*1128:*/
    printnl(S("! "));
    print(S("Misplaced "));
    printcmdchr(curcmd, curchr);
    if (curtok == tabtoken + '&') {
      help6(S("I can't figure out why you would want to use a tab mark"),S("here. If you just want an ampersand, the remedy is"),S("simple: Just type `I\\&' now. But if some right brace"),S("up above has ended a previous alignment prematurely,"),S("you're probably due for more error messages, and you"),S("might try typing `S' now just to see what is salvageable."));
    } else {
      help5(S("I can't figure out why you would want to use a tab mark"),S("or \\cr or \\span just now. If something like a right brace"),S("up above has ended a previous alignment prematurely,"),S("you're probably due for more error messages, and you"),S("might try typing `S' now just to see what is salvageable."));
    }
    error();
    return;
  }
  /*:1128*/
  backinput();
  if (alignstate < 0) {
    printnl(S("! "));
    print(S("Missing { inserted"));
    alignstate++;
    curtok = leftbracetoken + '{';
  } else {
    printnl(S("! "));
    print(S("Missing } inserted"));
    alignstate--;
    curtok = rightbracetoken + '}';
  }
  help3(S("I've put in what seems to be necessary to fix"),S("the current column of the current alignment."),S("Try to go on, since this might almost work."));
  inserror();
}


/*:1127*/
/*1129:*/
Static void noalignerror(void)
{
  printnl(S("! "));
  print(S("Misplaced "));
  printesc(S("noalign"));
  help2(S("I expect to see \\noalign only after the \\cr of"),S("an alignment. Proceed, and I'll ignore this case."));
  error();
}


Static void omiterror(void)
{
  printnl(S("! "));
  print(S("Misplaced "));
  printesc(S("omit"));
  help2(S("I expect to see \\omit only after tab marks or the \\cr of"),S("an alignment. Proceed, and I'll ignore this case."));
  error();
}


/*:1129*/
/*1131:*/
Static void doendv(void)
{
  if (curgroup != aligngroup) {
    offsave();
    return;
  }
  endgraf();
  if (fincol())
    finrow();
}


/*:1131*/
/*1135:*/
Static void cserror(void)
{
  printnl(S("! "));
  print(S("Extra "));
  printesc(S("endcsname"));
  help1(S("I'm ignoring this, since I wasn't doing a \\csname."));
  error();
}  /*:1135*/


/*1136:*/
Static void pushmath(groupcode c)
{
  pushnest();
  mode = -mmode;
  incompleatnoad = 0;
  newsavelevel(c);
}


/*:1136*/
/*1138:*/
Static void initmath(void)
{
  scaled w, l, s, v, d;
  pointer p, q;
  internalfontnumber f;
  long n;

  gettoken();
  if (curcmd == mathshift && mode > 0) {   /*1145:*/
    if (head == tail) {
      popnest();
      w = -maxdimen;
    } else {
      linebreak(displaywidowpenalty);   /*1146:*/
      v = shiftamount(justbox) + quad(curfont) * 2;
      w = -maxdimen;
      p = listptr(justbox);
      while (p != 0) {  /*1147:*/
_Lreswitch:
	if (ischarnode(p)) {
	  f = font(p);
	  d = charwidth(f, charinfo(f, character(p)));
	  goto _Lfound;
	}
	switch (type(p)) {   /*:1147*/

	case hlistnode:
	case vlistnode:
	case rulenode:
	  d = width(p);
	  goto _Lfound;
	  break;

	case ligaturenode:   /*652:*/
	  mem[ligtrick - memmin] = mem[ligchar(p) - memmin];
	  link(ligtrick) = link(p);
	  p = ligtrick;
	  goto _Lreswitch;
	  break;
	  /*:652*/

	case kernnode:
	case mathnode:
	  d = width(p);
	  break;

	case gluenode:   /*1148:*/
	  q = glueptr(p);
	  d = width(q);
	  if (gluesign(justbox) == stretching) {
	    if ((glueorder(justbox) == stretchorder(q)) &
		(stretch(q) != 0))
	      v = maxdimen;
	  } else if (gluesign(justbox) == shrinking) {
	    if ((glueorder(justbox) == shrinkorder(q)) &
		(shrink(q) != 0))
	      v = maxdimen;
	  }
	  if (subtype(p) >= aleaders)
	    goto _Lfound;
	  break;
	  /*:1148*/

	case whatsitnode:   /*1361:*/
	  d = 0;   /*:1361*/
	  break;

	default:
	  d = 0;
	  break;
	}
	if (v < maxdimen)
	  v += d;
	goto _Lnotfound;
_Lfound:
	if (v >= maxdimen) {
	  w = maxdimen;
	  goto _Ldone;
	}
	v += d;
	w = v;
_Lnotfound:
	p = link(p);
      }
_Ldone: ;   /*:1146*/
    }  /*1149:*/
    if (parshapeptr == 0) {
      if (hangindent != 0 &&
	  ( (hangafter >= 0 && prevgraf + 2 > hangafter) ||
	   prevgraf + 1 < -hangafter) ) {
	l = hsize - labs(hangindent);
	if (hangindent > 0)
	  s = hangindent;
	else
	  s = 0;
      } else {
	l = hsize;
	s = 0;
      }
    } else {   /*:1149*/
      n = info(parshapeptr);
      if (prevgraf + 2 >= n)
	p = parshapeptr + n * 2;
      else
	p = parshapeptr + (prevgraf + 2) * 2;
      s = mem[p - memmin - 1].sc;
      l = mem[p - memmin].sc;
    }
    pushmath(mathshiftgroup);
    mode = mmode;
    eqworddefine(intbase + curfamcode, -1);
    eqworddefine(dimenbase + predisplaysizecode, w);
    eqworddefine(dimenbase + displaywidthcode, l);
    eqworddefine(dimenbase + displayindentcode, s);
    if (everydisplay != 0)
      begintokenlist(everydisplay, everydisplaytext);
    if (nestptr == 1)
      buildpage();
    return;
  }
  /*:1145*/
  backinput();   /*1139:*/
  pushmath(mathshiftgroup);
  eqworddefine(intbase + curfamcode, -1);
  if (everymath != 0)   /*:1139*/
    begintokenlist(everymath, everymathtext);
}


/*:1138*/
/*1142:*/
Static void starteqno(void)
{
  saved(0) = curchr;
  saveptr++;   /*1139:*/
  pushmath(mathshiftgroup);
  eqworddefine(intbase + curfamcode, -1);
  if (everymath != 0)   /*:1139*/
    begintokenlist(everymath, everymathtext);
}


/*:1142*/
/*1151:*/
Static void scanmath(halfword p)
{
  long c;

_Lrestart:   /*404:*/
  do {
    getxtoken();   /*:404*/
  } while (curcmd == spacer || curcmd == relax);
_Lreswitch:
  switch (curcmd) {

  case letter:
  case otherchar:
  case chargiven:
    c = mathcode(curchr);
    if (c == 32768L) {   /*1152:*/
      curcs = curchr + activebase;
      curcmd = eqtype(curcs);
      curchr = equiv(curcs);
      xtoken();
      backinput();   /*:1152*/
      goto _Lrestart;
    }
    break;

  case charnum:
    scancharnum();
    curchr = curval;
    curcmd = chargiven;
    goto _Lreswitch;
    break;

  case mathcharnum:
    scanfifteenbitint();
    c = curval;
    break;

  case mathgiven:
    c = curchr;
    break;

  case delimnum:   /*1153:*/
    scantwentysevenbitint();
    c = curval / 4096;
    break;

  default:
    backinput();
    scanleftbrace();
    saved(0) = p;
    saveptr++;
    pushmath(mathgroup);
    goto _Lexit;   /*:1153*/
    break;
  }
  mathtype(p) = mathchar;
  character(p) = c & 255;
  if (c >= varcode && faminrange) {
    fam(p) = curfam;
  } else
    fam(p) = (c / 256) & 15;
_Lexit: ;
}


/*:1151*/
/*1155:*/
Static void setmathchar(long c)
{
  pointer p;

  if (c >= 32768L) {   /*1152:*/
    curcs = curchr + activebase;
    curcmd = eqtype(curcs);
    curchr = equiv(curcs);
    xtoken();
    backinput();
    return;
  }  /*:1152*/
  p = newnoad();
  mathtype(nucleus(p)) = mathchar;
  character(nucleus(p)) = c & 255;
  fam(nucleus(p)) = (c / 256) & 15;
  if (c >= varcode) {
    if (faminrange) {
      fam(nucleus(p)) = curfam;
    }
    type(p) = ordnoad;
  } else
    type(p) = ordnoad + c / 4096;
  link(tail) = p;
  tail = p;
}


/*:1155*/
/*1159:*/
Static void mathlimitswitch(void)
{
  if (head != tail) {
    if (type(tail) == opnoad) {
      subtype(tail) = curchr;
      goto _Lexit;
    }
  }
  printnl(S("! "));
  print(S("Limit controls must follow a math operator"));
  help1(S("I'm ignoring this misplaced \\limits or \\nolimits command."));
  error();
_Lexit: ;
}


/*:1159*/
/*1160:*/
Static void scandelimiter(halfword p, boolean r)
{
  if (r)
    scantwentysevenbitint();
  else {   /*404:*/
    do {
      getxtoken();   /*:404*/
    } while (curcmd == spacer || curcmd == relax);
    switch (curcmd) {

    case letter:
    case otherchar:
      curval = delcode(curchr);
      break;

    case delimnum:
      scantwentysevenbitint();
      break;

    default:
      curval = -1;
      break;
    }
  }
  if (curval < 0) {   /*1161:*/
    printnl(S("! "));
    print(S("Missing delimiter (. inserted)"));
    help6(S("I was expecting to see something like `(' or `\\{' or"),S("`\\}' here. If you typed, e.g., `{' instead of `\\{', you"),S("should probably delete the `{' by typing `1' now, so that"),S("braces don't get unbalanced. Otherwise just proceed."),S("Acceptable delimiters are characters whose \\delcode is"),S("nonnegative, or you can use `\\delimiter <delimiter code>'."));
    backerror();
    curval = 0;
  }
  /*:1161*/
  smallfam(p) = (curval / 1048576L) & 15;
  smallchar(p) = (curval / 4096) & 255;
  largefam(p) = (curval / 256) & 15;
  largechar(p) = curval & 255;
}


/*:1160*/
/*1163:*/
Static void mathradical(void)
{
  tailappend(getnode(radicalnoadsize));
  type(tail) = radicalnoad;
  subtype(tail) = normal;
  mem[nucleus(tail) - memmin].hh = emptyfield;
  mem[subscr(tail) - memmin].hh = emptyfield;
  mem[supscr(tail) - memmin].hh = emptyfield;
  scandelimiter(leftdelimiter(tail), true);
  scanmath(nucleus(tail));
}


/*:1163*/
/*1165:*/
Static void mathac(void)
{
  if (curcmd == accent) {   /*1166:*/
    printnl(S("! "));
    print(S("Please use "));
    printesc(S("mathaccent"));
    print(S(" for accents in math mode"));
    help2(S("I'm changing \\accent to \\mathaccent here; wish me luck."),S("(Accents are not the same in formulas as they are in text.)"));
    error();
  }
  /*:1166*/
  tailappend(getnode(accentnoadsize));
  type(tail) = accentnoad;
  subtype(tail) = normal;
  mem[nucleus(tail) - memmin].hh = emptyfield;
  mem[subscr(tail) - memmin].hh = emptyfield;
  mem[supscr(tail) - memmin].hh = emptyfield;
  mathtype(accentchr(tail)) = mathchar;
  scanfifteenbitint();
  character(accentchr(tail)) = curval & 255;
  if (curval >= varcode && faminrange) {
    fam(accentchr(tail)) = curfam;
  } else
    fam(accentchr(tail)) = (curval / 256) & 15;
  scanmath(nucleus(tail));
}


/*:1165*/
/*1172:*/
Static void appendchoices(void)
{
  tailappend(newchoice());
  saveptr++;
  saved(-1) = 0;
  pushmath(mathchoicegroup);
  scanleftbrace();
}


/*:1172*/
/*1174:*/
/*1184:*/
Static halfword finmlist(halfword p)
{
  pointer q;

  if (incompleatnoad != 0) {   /*1185:*/
    mathtype(denominator(incompleatnoad)) = submlist;
    info(denominator(incompleatnoad)) = link(head);
    if (p == 0)
      q = incompleatnoad;
    else {
      q = info(numerator(incompleatnoad));
      if (type(q) != leftnoad)
	confusion(S("right"));
      info(numerator(incompleatnoad)) = link(q);
      link(q) = incompleatnoad;
      link(incompleatnoad) = p;
    }
  }  /*:1185*/
  else {
    link(tail) = p;
    q = link(head);
  }
  popnest();
  return q;
}


/*:1184*/
Static void buildchoices(void)
{
  pointer p;

  unsave();
  p = finmlist(0);
  switch (saved(-1)) {

  case 0:
    displaymlist(tail) = p;
    break;

  case 1:
    textmlist(tail) = p;
    break;

  case 2:
    scriptmlist(tail) = p;
    break;

  case 3:
    scriptscriptmlist(tail) = p;
    saveptr--;
    goto _Lexit;
    break;
  }
  (saved(-1))++;
  pushmath(mathchoicegroup);
  scanleftbrace();
_Lexit: ;
}


/*:1174*/
/*1176:*/
Static void subsup(void)
{
  smallnumber t;
  pointer p;

  t = empty;
  p = 0;
  if (tail != head) {
    if (scriptsallowed(tail)) {
      p = supscr(tail) + curcmd - supmark;
      t = mathtype(p);
    }
  }
  if (p == 0 || t != empty) {   /*1177:*/
    tailappend(newnoad());
    p = supscr(tail) + curcmd - supmark;
    if (t != empty) {
      if (curcmd == supmark) {
	printnl(S("! "));
	print(S("Double superscript"));
	help1(S("I treat `x^1^2' essentially like `x^1{}^2'."));
      } else {
	printnl(S("! "));
	print(S("Double subscript"));
	help1(S("I treat `x_1_2' essentially like `x_1{}_2'."));
      }
      error();
    }
  }
  /*:1177*/
  scanmath(p);
}


/*:1176*/
/*1181:*/
Static void mathfraction(void)
{
  smallnumber c;

  c = curchr;
  if (incompleatnoad != 0) {   /*1183:*/
    if (c >= delimitedcode) {
      scandelimiter(garbage, false);
      scandelimiter(garbage, false);
    }
    if (c % delimitedcode == abovecode) {
      scannormaldimen();
    }
    printnl(S("! "));
    print(S("Ambiguous; you need another { and }"));
    help3(S("I'm ignoring this fraction specification, since I don't"),S("know whether a construction like `x \\over y \\over z'"),S("means `{x \\over y} \\over z' or `x \\over {y \\over z}'."));
    error();
    return;
  }  /*:1183*/
  incompleatnoad = getnode(fractionnoadsize);
  type(incompleatnoad) = fractionnoad;
  subtype(incompleatnoad) = normal;
  mathtype(numerator(incompleatnoad)) = submlist;
  info(numerator(incompleatnoad)) = link(head);
  mem[denominator(incompleatnoad) - memmin].hh = emptyfield;
  mem[leftdelimiter(incompleatnoad) - memmin].qqqq = nulldelimiter;
  mem[rightdelimiter(incompleatnoad) - memmin].qqqq = nulldelimiter;
  link(head) = 0;
  tail = head;   /*1182:*/
  if (c >= delimitedcode) {
    scandelimiter(leftdelimiter(incompleatnoad), false);
    scandelimiter(rightdelimiter(incompleatnoad), false);
  }
  switch (c % delimitedcode) {   /*:1182*/

  case abovecode:
    scannormaldimen();
    thickness(incompleatnoad) = curval;
    break;

  case overcode:
    thickness(incompleatnoad) = defaultcode;
    break;

  case atopcode:
    thickness(incompleatnoad) = 0;
    break;
  }
}  /*:1181*/


/*1191:*/
Static void mathleftright(void)
{
  smallnumber t;
  pointer p;

  t = curchr;
  if (t == rightnoad && curgroup != mathleftgroup) {   /*1192:*/
    if (curgroup != mathshiftgroup) {
      offsave();
      return;
    }
    scandelimiter(garbage, false);
    printnl(S("! "));
    print(S("Extra "));
    printesc(S("right"));
    help1(S("I'm ignoring a \\right that had no matching \\left."));
    error();
    return;
  }
  /*:1192*/
  p = newnoad();
  type(p) = t;
  scandelimiter(delimiter(p), false);
  if (t == leftnoad) {
    pushmath(mathleftgroup);
    link(head) = p;
    tail = p;
    return;
  }
  p = finmlist(p);
  unsave();
  tailappend(newnoad());
  type(tail) = innernoad;
  mathtype(nucleus(tail)) = submlist;
  info(nucleus(tail)) = p;
}


/*:1191*/
/*1194:*/
Static void aftermath(void)
{
  boolean l, danger;
  long m;
  pointer p, a;
  /*1198:*/
  pointer b, r, t;   /*:1198*/
  scaled w, z, e, q, d, s;
  smallnumber g1, g2;

  danger = false;   /*1195:*/
  if ((fontparams[famfnt(textsize + 2) ] < totalmathsyparams) |
      (fontparams[famfnt(scriptsize + 2) ] < totalmathsyparams) |
      (fontparams[famfnt(scriptscriptsize + 2) ] <
       totalmathsyparams)) {
    printnl(S("! "));
    print(S("Math formula deleted: Insufficient symbol fonts"));
    help3(S("Sorry, but I can't typeset math unless \\textfont 2"),S("and \\scriptfont 2 and \\scriptscriptfont 2 have all"),S("the \\fontdimen values needed in math symbol fonts."));
    error();
    flushmath();
    danger = true;
  } else if ((fontparams[famfnt(textsize + 3) ] <
	      totalmathexparams) |
	     (fontparams[famfnt(scriptsize + 3) ] <
	      totalmathexparams) |
	     (fontparams[famfnt(scriptscriptsize + 3) ] <
	      totalmathexparams)) {
    printnl(S("! "));
    print(S("Math formula deleted: Insufficient extension fonts"));
    help3(S("Sorry, but I can't typeset math unless \\textfont 3"),S("and \\scriptfont 3 and \\scriptscriptfont 3 have all"),S("the \\fontdimen values needed in math extension fonts."));
    error();
    flushmath();
    danger = true;
  }
  m = mode;
  l = false;
  p = finmlist(0);
  if (mode == -m) {   /*1197:*/
    getxtoken();
    if (curcmd != mathshift) {   /*:1197*/
      printnl(S("! "));
      print(S("Display math should end with $$"));
      help2(S("The `$' that I just saw supposedly matches a previous `$$'."),S("So I shall assume that you typed `$$' both times."));
      backerror();
    }
    curmlist = p;
    curstyle = textstyle;
    mlistpenalties = false;
    mlisttohlist();
    a = hpack(link(temphead), 0, additional);
    unsave();
    saveptr--;
    if (saved(0) == 1)
      l = true;
    danger = false;   /*1195:*/
    if ((fontparams[famfnt(textsize + 2) ] < totalmathsyparams) |
	(fontparams[famfnt(scriptsize + 2) ] < totalmathsyparams) |
	(fontparams[famfnt(scriptscriptsize + 2) ] <
	 totalmathsyparams)) {
      printnl(S("! "));
      print(S("Math formula deleted: Insufficient symbol fonts"));
      help3(S("Sorry, but I can't typeset math unless \\textfont 2"),S("and \\scriptfont 2 and \\scriptscriptfont 2 have all"),S("the \\fontdimen values needed in math symbol fonts."));
      error();
      flushmath();
      danger = true;
    } else if ((fontparams[famfnt(textsize + 3) ] <
		totalmathexparams) |
	       (fontparams[famfnt(scriptsize + 3) ] <
		totalmathexparams) |
	       (fontparams[famfnt(scriptscriptsize + 3) ] <
		totalmathexparams)) {
      printnl(S("! "));
      print(S("Math formula deleted: Insufficient extension fonts"));
      help3(S("Sorry, but I can't typeset math unless \\textfont 3"),S("and \\scriptfont 3 and \\scriptscriptfont 3 have all"),S("the \\fontdimen values needed in math extension fonts."));
      error();
      flushmath();
      danger = true;
    }
    m = mode;
    p = finmlist(0);
  } else
    a = 0;
  if (m < 0) {   /*1196:*/
    tailappend(newmath(mathsurround, before));
    curmlist = p;
    curstyle = textstyle;
    mlistpenalties = (mode > 0);
    mlisttohlist();
    link(tail) = link(temphead);
    while (link(tail) != 0)
      tail = link(tail);
    tailappend(newmath(mathsurround, after));
    spacefactor = 1000;
    unsave();
    return;
  }
  /*:1196*/
  if (a == 0) {   /*1197:*/
    getxtoken();
    if (curcmd != mathshift) {
      printnl(S("! "));
      print(S("Display math should end with $$"));
      help2(S("The `$' that I just saw supposedly matches a previous `$$'."),S("So I shall assume that you typed `$$' both times."));
      backerror();
    }
  }
  /*:1197*/
  /*1199:*/
  curmlist = p;
  curstyle = displaystyle;
  mlistpenalties = false;
  mlisttohlist();
  p = link(temphead);
  adjusttail = adjusthead;
  b = hpack(p, 0, additional);
  p = listptr(b);
  t = adjusttail;
  adjusttail = 0;
  w = width(b);
  z = displaywidth;
  s = displayindent;
  if (a == 0 || danger) {
    e = 0;
    q = 0;
  } else {
    e = width(a);
    q = e + mathquad(textsize);
  }
  if (w + q > z) {   /*1201:*/
    if (e != 0 && (w - totalshrink[0] + q <= z ||
		   totalshrink[fil - normal] != 0 ||
		   totalshrink[fill - normal] != 0 ||
		   totalshrink[filll - normal] != 0)) {
      freenode(b, boxnodesize);
      b = hpack(p, z - q, exactly);
    } else {
      e = 0;
      if (w > z) {
	freenode(b, boxnodesize);
	b = hpack(p, z, exactly);
      }
    }
    w = width(b);
  }
  /*:1201*/
  /*1202:*/
  d = half(z - w);
  if (e > 0 && d < e * 2) {   /*:1202*/
    d = half(z - w - e);
    if (p != 0) {
      if (!ischarnode(p)) {
	if (type(p) == gluenode)
	  d = 0;
      }
    }
  }
  /*1203:*/
  tailappend(newpenalty(predisplaypenalty));
  if (d + s <= predisplaysize || l) {
    g1 = abovedisplayskipcode;
    g2 = belowdisplayskipcode;
  } else {
    g1 = abovedisplayshortskipcode;
    g2 = belowdisplayshortskipcode;
  }
  if (l && e == 0) {   /*1204:*/
    shiftamount(a) = s;
    appendtovlist(a);
    tailappend(newpenalty(infpenalty));
  } else {
    tailappend(newparamglue(g1));   /*:1203*/
  }
  if (e != 0) {
    r = newkern(z - w - e - d);
    if (l) {
      link(a) = r;
      link(r) = b;
      b = a;
      d = 0;
    } else {
      link(b) = r;
      link(r) = a;
    }
    b = hpack(b, 0, additional);
  }
  shiftamount(b) = s + d;   /*:1204*/
  appendtovlist(b);   /*1205:*/
  if (a != 0 && e == 0 && !l) {
    tailappend(newpenalty(infpenalty));
    shiftamount(a) = s + z - width(a);
    appendtovlist(a);
    g2 = 0;
  }
  if (t != adjusthead) {
    link(tail) = link(adjusthead);
    tail = t;
  }
  tailappend(newpenalty(postdisplaypenalty));
  if (g2 > 0) {   /*:1199*/
    tailappend(newparamglue(g2));   /*:1205*/
  }
  resumeafterdisplay();

  /*:1195*/
  /*:1195*/
}


/*:1194*/
/*1200:*/
Static void resumeafterdisplay(void)
{
  if (curgroup != mathshiftgroup)
    confusion(S("display"));
  unsave();
  prevgraf += 3;
  pushnest();
  mode = hmode;
  spacefactor = 1000;
  setcurlang();
  clang = curlang;
  prevgraf = (normmin(lefthyphenmin) * 64 + normmin(righthyphenmin)) * 65536L +
	     curlang;
      /*443:*/
  getxtoken();
  if (curcmd != spacer)   /*:443*/
    backinput();
  if (nestptr == 1)
    buildpage();
}


/*:1200*/
/*1211:*/
/*1215:*/
Static void getrtoken(void)
{
_Lrestart:
  do {
    gettoken();
  } while (curtok == spacetoken);
  if (curcs != 0 && curcs <= frozencontrolsequence)
    return;
  printnl(S("! "));
  print(S("Missing control sequence inserted"));
  help5(S("Please don't say `\\def cs{...}', say `\\def\\cs{...}'."),S("I've inserted an inaccessible control sequence so that your"),S("definition will be completed without mixing me up too badly."),S("You can recover graciously from this error, if you're"),S("careful; see exercise 27.2 in The TeXbook."));
  if (curcs == 0)
    backinput();
  curtok = cstokenflag + frozenprotection;
  inserror();
  goto _Lrestart;
}


/*:1215*/
/*1229:*/
Static void trapzeroglue(void)
{
  if (!((width(curval) == 0) & (stretch(curval) == 0) &
	(shrink(curval) == 0)))
    return;
  addglueref(zeroglue);
  deleteglueref(curval);
  curval = zeroglue;
}


/*:1229*/
/*1236:*/
Static void doregistercommand(smallnumber a)
{
  pointer l=0 /* XXXX */, q, r, s;
  char p;

  q = curcmd;   /*1237:*/
  if (q != register_) {
    getxtoken();
    if (curcmd >= assignint && curcmd <= assignmuglue) {
      l = curchr;
      p = curcmd - assignint;
      goto _Lfound;
    }
    if (curcmd != register_) {
      printnl(S("! "));
      print(S("You can't use `"));
      printcmdchr(curcmd, curchr);
      print(S("' after "));
      printcmdchr(q, 0);
      help1(S("I'm forgetting what you said and not changing anything."));
      error();
      goto _Lexit;
    }
  }
  p = curchr;
  scaneightbitint();
  switch (p) {

  case intval:
    l = curval + countbase;
    break;

  case dimenval:
    l = curval + scaledbase;
    break;

  case glueval:
    l = curval + skipbase;
    break;

  case muval:
    l = curval + muskipbase;
    break;
  }
_Lfound:   /*:1237*/
  if (q == register_)
    scanoptionalequals();
  else
    scankeyword(S("by"));
  aritherror = false;
  if (q < multiply) {   /*1238:*/
    if (p < glueval) {
      if (p == intval)
	scanint();
      else {
	scannormaldimen();
      }
      if (q == advance)
	curval += eqtb[l - activebase].int_;
    } else {   /*:1238*/
      scanglue(p);
      if (q == advance) {   /*1239:*/
	q = newspec(curval);
	r = equiv(l);
	deleteglueref(curval);
	width(q) += width(r);
	if (stretch(q) == 0)
	  stretchorder(q) = normal;
	if (stretchorder(q) == stretchorder(r))
	  stretch(q) += stretch(r);
	else if ((stretchorder(q) < stretchorder(r)) &
		 (stretch(r) != 0)) {
	  stretch(q) = stretch(r);
	  stretchorder(q) = stretchorder(r);
	}
	if (shrink(q) == 0)
	  shrinkorder(q) = normal;
	if (shrinkorder(q) == shrinkorder(r))
	  shrink(q) += shrink(r);
	else if ((shrinkorder(q) < shrinkorder(r)) & (shrink(r) != 0)) {
	  shrink(q) = shrink(r);
	  shrinkorder(q) = shrinkorder(r);
	}
	curval = q;
      }
      /*:1239*/
    }
  } else {   /*1240:*/
    scanint();
    if (p < glueval) {
      if (q == multiply) {
	if (p == intval)
	  curval = multandadd(eqtb[l - activebase].int_, curval, 0,
			      2147483647L);
	else
	  curval = multandadd(eqtb[l - activebase].int_, curval, 0,
			      1073741823L);
      } else
	curval = xovern(eqtb[l - activebase].int_, curval);
    } else {
      s = equiv(l);
      r = newspec(s);
      if (q == multiply) {
	width(r) = multandadd(width(s), curval, 0, 1073741823L);
	stretch(r) = multandadd(stretch(s), curval, 0, 1073741823L);
	shrink(r) = multandadd(shrink(s), curval, 0, 1073741823L);
      } else {
	width(r) = xovern(width(s), curval);
	stretch(r) = xovern(stretch(s), curval);
	shrink(r) = xovern(shrink(s), curval);
      }
      curval = r;
    }
  }  /*:1240*/
  if (aritherror) {
    printnl(S("! "));
    print(S("Arithmetic overflow"));
    help2(S("I can't carry out that multiplication or division,"),S("since the result is out of range."));
    error();
    goto _Lexit;
  }
  if (p < glueval) {
    worddefine(l, curval);
  } else {
    trapzeroglue();
    define(l, glueref, curval);
  }
_Lexit: ;
}


/*:1236*/
/*1243:*/
Static void alteraux(void)
{
  halfword c;

  if (curchr != labs(mode)) {
    reportillegalcase();
    return;
  }
  c = curchr;
  scanoptionalequals();
  if (c == vmode) {
    scannormaldimen();
    prevdepth = curval;
    return;
  }
  scanint();
  if (curval > 0 && curval <= 32767) {
    spacefactor = curval;
    return;
  }
  printnl(S("! "));
  print(S("Bad space factor"));
  help1(S("I allow only values in the range 1..32767 here."));
  interror(curval);
}


/*:1243*/
/*1244:*/
Static void alterprevgraf(void)
{
  int p;

  nest[nestptr] = curlist;
  p = nestptr;
  while (abs(nest[p].modefield) != vmode)
    p--;
  scanoptionalequals();
  scanint();
  if (curval >= 0) {
    nest[p].pgfield = curval;
    curlist = nest[nestptr];
    return;
  }
  printnl(S("! "));
  print(S("Bad "));
  printesc(S("prevgraf"));
  help1(S("I allow only nonnegative values here."));
  interror(curval);
}


/*:1244*/
/*1245:*/
Static void alterpagesofar(void)
{
  int c;

  c = curchr;
  scanoptionalequals();
  scannormaldimen();
  pagesofar[c] = curval;
}  /*:1245*/


/*1246:*/
Static void alterinteger(void)
{
  char c;

  c = curchr;
  scanoptionalequals();
  scanint();
  if (c == 0)
    deadcycles = curval;
  else
    insertpenalties = curval;
}  /*:1246*/


/*1247:*/
Static void alterboxdimen(void)
{
  smallnumber c;
  eightbits b;

  c = curchr;
  scaneightbitint();
  b = curval;
  scanoptionalequals();
  scannormaldimen();
  if (box(b) != 0)
    mem[box(b) + c - memmin].sc = curval;
}


/*:1247*/
/*1257:*/
Static void newfont(smallnumber a)
{
  pointer u;
  scaled s;
  internalfontnumber f;
  strnumber t;
  char oldsetting;
/* XXXX  strnumber flushablestring; */

  if (jobname == 0)
    openlogfile();
  getrtoken();
  u = curcs;
  if (u >= hashbase)
    t = text(u);
  else if (u >= singlebase) {
    if (u == nullcs)
      t = S("FONT");
    else
      t = u - singlebase;
  } else {
    oldsetting = selector;
    selector = newstring;
    print(S("FONT"));
    print(u - activebase);
    selector = oldsetting;
    str_room(1);
    t = makestring();
  }
  define(u, setfont, nullfont);
  scanoptionalequals();
  scanfilename();   /*1258:*/
  nameinprogress = true;
  if (scankeyword(S("at"))) {   /*1259:*/
    scannormaldimen();
    s = curval;
    if (s <= 0 || s >= 134217728L) {
      printnl(S("! "));
      print(S("Improper `at' size ("));
      printscaled(s);
      print(S("pt), replaced by 10pt"));
      help2(S("I can only handle fonts at positive sizes that are"),S("less than 2048pt, so I've changed what you said to 10pt."));
      error();
      s = unity * 10;
    }
  }  /*:1259*/
  else if (scankeyword(S("scaled"))) {
    scanint();
    s = -curval;
    if (curval <= 0 || curval > 32768L) {
      printnl(S("! "));
      print(S("Illegal magnification has been changed to 1000"));
      help1(S("The magnification ratio must be between 1 and 32768."));
      interror(curval);
      s = -1000;
    }
  } else
    s = -1000;
  nameinprogress = false;   /*:1258*/
  /*1260:*/
#if 0
  flushablestring = strptr - 1;
#endif
  for (f = 1; f <= fontptr; f++) {
    if (streqstr(fontname[f ], curname) &
	streqstr(fontarea[f ], curarea))
    {   /*:1260*/
#if 0
      if (curname == flushablestring) {
	flushstring();
	curname = fontname[f ];
      }
#endif
      if (s > 0) {
	if (s == fontsize[f ])
	  goto _Lcommonending;
      } else if (fontsize[f ] ==
		 xnoverd(fontdsize[f ], -s, 1000))
	goto _Lcommonending;
    }
  }
  f = readfontinfo(u, curname, curarea, s);
_Lcommonending:
  equiv(u) = f;
  eqtb[fontidbase + f - activebase] = eqtb[u - activebase];
  set_fontidtext(f,t);
}


/*:1257*/
/*1265:*/
Static void newinteraction(void)
{
  println();
  interaction = curchr;   /*75:*/
  if (interaction == batchmode)
    selector = noprint;
  else {
    selector = termonly;
    /*
:75*/
  }
  if (logopened)
    selector += 2;
}  /*:1265*/


Static void prefixedcommand(void)
{
  smallnumber a;
  internalfontnumber f;
  halfword j;
  fontindex k;
  pointer p, q;
  long n;
  boolean e;

  a = 0;
  while (curcmd == prefix) {
    if (!((a / curchr) & 1))
      a += curchr;
    /*404:*/
    do {
      getxtoken();
      /*:404*/
    } while (curcmd == spacer || curcmd == relax);
    if (curcmd > maxnonprefixedcommand)   /*1212:*/
      continue;
    /*:1212*/
    printnl(S("! "));
    print(S("You can't use a prefix with `"));
    printcmdchr(curcmd, curchr);
    printchar('\'');
    help1(S("I'll pretend you didn't say \\long or \\outer or \\global."));
    backerror();
    goto _Lexit;
  }  /*1213:*/
  if (curcmd != def && (a & 3) != 0) {   /*:1213*/
    printnl(S("! "));
    print(S("You can't use `"));
    printesc(S("long"));
    print(S("' or `"));
    printesc(S("outer"));
    print(S("' with `"));
    printcmdchr(curcmd, curchr);
    printchar('\'');
    help1(S("I'll pretend you didn't say \\long or \\outer here."));
    error();
  }
  /*1214:*/
  if (globaldefs != 0) {
    if (globaldefs < 0) {
      if (global) {
	a -= 4;
      }
    } else {   /*:1214*/
      if (~global) {
	a += 4;
      }
    }
  }
  switch (curcmd) {   /*1217:*/

  case setfont:   /*:1217*/
    define(curfontloc, data, curchr);
    break;

  /*1218:*/
  case def:   /*:1218*/
    if ((curchr & 1) && ~global && globaldefs >= 0) {
      a += 4;
    }
    e = (curchr >= 2);
    getrtoken();
    p = curcs;
    q = scantoks(true, e);
    define(p, call + (a & 3), defref);
    break;
    /*1221:*/

  case let:
    n = curchr;
    getrtoken();
    p = curcs;
    if (n == normal) {
      do {
	gettoken();
      } while (curcmd == spacer);
      if (curtok == othertoken + '=') {
	gettoken();
	if (curcmd == spacer)
	  gettoken();
      }
    } else {
      gettoken();
      q = curtok;
      gettoken();
      backinput();
      curtok = q;
      backinput();
    }
    if (curcmd >= call) {
      addtokenref(curchr);
    }
    define(p, curcmd, curchr);
    break;

  /*:1221*/
  /*1224:*/
  case shorthanddef:
    n = curchr;
    getrtoken();
    p = curcs;
    define(p, relax, 256);
    scanoptionalequals();
    switch (n) {

    case chardefcode:
      scancharnum();
      define(p, chargiven, curval);
      break;

    case mathchardefcode:
      scanfifteenbitint();
      define(p, mathgiven, curval);
      break;

    default:
      scaneightbitint();
      switch (n) {

      case countdefcode:
	define(p, assignint, countbase + curval);
	break;

      case dimendefcode:
	define(p, assigndimen, scaledbase + curval);
	break;

      case skipdefcode:
	define(p, assignglue, skipbase + curval);
	break;

      case muskipdefcode:
	define(p, assignmuglue, muskipbase + curval);
	break;

      case toksdefcode:
	define(p, assigntoks, toksbase + curval);
	break;
      }
      break;
    }
    break;
    /*:1224*/

  /*1225:*/
  case readtocs:   /*:1225*/
    scanint();
    n = curval;
    if (!scankeyword(S("to"))) {
      printnl(S("! "));
      print(S("Missing `to' inserted"));
      help2(S("You should have said `\\read<number> to \\cs'."),S("I'm going to look for the \\cs now."));
      error();
    }
    getrtoken();
    p = curcs;
    readtoks(n, p);
    define(p, call, curval);
    break;
    /*1226:*/

  case toksregister:
  case assigntoks:   /*:1226*/
    q = curcs;
    if (curcmd == toksregister) {
      scaneightbitint();
      p = toksbase + curval;
    } else
      p = curchr;
    scanoptionalequals();   /*404:*/
    do {
      getxtoken();   /*:404*/
    } while (curcmd == spacer || curcmd == relax);
    if (curcmd != leftbrace) {   /*1227:*/
      if (curcmd == toksregister) {
	scaneightbitint();
	curcmd = assigntoks;
	curchr = toksbase + curval;
      }
      if (curcmd == assigntoks) {
	q = equiv(curchr);
	if (q == 0) {
	  define(p, undefinedcs, 0);
	} else {
	  addtokenref(q);
	  define(p, call, q);
	}
	goto _Ldone;
      }
    }
    /*:1227*/
    backinput();
    curcs = q;
    q = scantoks(false, false);
    if (link(defref) == 0) {
      define(p, undefinedcs, 0);
      freeavail(defref);
    } else {
      if (p == outputroutineloc) {
	link(q) = getavail();
	q = link(q);
	info(q) = rightbracetoken + '}';
	q = getavail();
	info(q) = leftbracetoken + '{';
	link(q) = link(defref);
	link(defref) = q;
      }
      define(p, call, defref);
    }
    break;
    /*1228:*/

  case assignint:
    p = curchr;
    scanoptionalequals();
    scanint();
    worddefine(p, curval);
    break;

  case assigndimen:
    p = curchr;
    scanoptionalequals();
    scannormaldimen();
    worddefine(p, curval);
    break;

  case assignglue:
  case assignmuglue:   /*:1228*/
    p = curchr;
    n = curcmd;
    scanoptionalequals();
    if (n == assignmuglue)
      scanglue(muval);
    else
      scanglue(glueval);
    trapzeroglue();
    define(p, glueref, curval);
    break;
    /*1232:*/

  case defcode:   /*:1232*/
    /*1233:*/
    if (curchr == catcodebase)
      n = maxcharcode;
    else if (curchr == mathcodebase)
      n = 32768L;
    else if (curchr == sfcodebase)
      n = 32767;
    else if (curchr == delcodebase)
      n = 16777215L;
    else
      n = 255;   /*:1233*/
    p = curchr;
    scancharnum();
    p += curval;
    scanoptionalequals();
    scanint();
    if ( (curval < 0 && p < delcodebase) || curval > n) {
      printnl(S("! "));
      print(S("Invalid code ("));
      printint(curval);
      if (p < delcodebase)
	print(S("), should be in the range 0.."));
      else
	print(S("), should be at most "));
      printint(n);
      help1(S("I'm going to use 0 instead of that illegal code value."));
      error();
      curval = 0;
    }
    if (p < mathcodebase) {
      define(p, data, curval);
    } else if (p < delcodebase) {
      define(p, data, curval);
    } else {
      worddefine(p, curval);
    }
    break;
    /*1234:*/

  case deffamily:   /*:1234*/
    p = curchr;
    scanfourbitint();
    p += curval;
    scanoptionalequals();
    scanfontident();
    define(p, data, curval);
    break;
    /*1235:*/

  case register_:
  case advance:
  case multiply:
  case divide:   /*:1235*/
    doregistercommand(a);
    break;
    /*1241:*/

  case setbox:   /*:1241*/
    scaneightbitint();
    if (global) {
      n = curval + 256;
    } else
      n = curval;
    scanoptionalequals();
    if (setboxallowed)
      scanbox(boxflag + n);
    else {
      printnl(S("! "));
      print(S("Improper "));
      printesc(S("setbox"));
      help2(S("Sorry, \\setbox is not allowed after \\halign in a display,"),S("or between \\accent and an accented character."));
      error();
    }
    break;
    /*1242:*/

  case setaux:
    alteraux();
    break;

  case setprevgraf:
    alterprevgraf();
    break;

  case setpagedimen:
    alterpagesofar();
    break;

  case setpageint:
    alterinteger();
    break;

  case setboxdimen:   /*:1242*/
    alterboxdimen();
    break;
    /*1248:*/

  case setshape:   /*:1248*/
    scanoptionalequals();
    scanint();
    n = curval;
    if (n <= 0)
      p = 0;
    else {
      p = getnode(n * 2 + 1);
      info(p) = n;
      for (j = 1; j <= n; j++) {
	scannormaldimen();
	mem[p + j * 2 - memmin - 1].sc = curval;
	scannormaldimen();
	mem[p + j * 2 - memmin].sc = curval;
      }
    }
    define(parshapeloc, shaperef, p);
    break;
    /*1252:*/

  case hyphdata:   /*:1252*/
    if (curchr == 1) {
      newpatterns();
      goto _Ldone;
/* p2c: tex1.p: Note: Deleting unreachable code [255] */
    } else {
      newhyphexceptions();
      goto _Ldone;
    }
    break;
    /*1253:*/

  case assignfontdimen:
    findfontdimen(true);
    k = curval;
    scanoptionalequals();
    scannormaldimen();
    fontinfo[k].sc = curval;
    break;

  case assignfontint:
    n = curchr;
    scanfontident();
    f = curval;
    scanoptionalequals();
    scanint();
    if (n == 0)
      hyphenchar[f ] = curval;
    else
      skewchar[f ] = curval;
    break;
    /*:1253*/

  /*1256:*/
  case deffont:
    newfont(a);
    break;

  /*:1256*/
  /*1264:*/
  case setinteraction:
    newinteraction();
    break;

  /*:1264*/
  default:
    confusion(S("prefix"));
    break;
  }
_Ldone:
  /*1269:*/
  if (aftertoken != 0) {   /*:1269*/
    curtok = aftertoken;
    backinput();
    aftertoken = 0;
  }
_Lexit: ;
}


/*:1211*/
/*1270:*/
Static void doassignments(void)
{
  while (true) {   /*404:*/
    do {
      getxtoken();   /*:404*/
    } while (curcmd == spacer || curcmd == relax);
    if (curcmd <= maxnonprefixedcommand)
      goto _Lexit;
    setboxallowed = false;
    prefixedcommand();
    setboxallowed = true;
  }
_Lexit: ;
}


/*:1270*/
/*1275:*/
Static void openorclosein(void)
{
  int c;
  int n;

  c = curchr;
  scanfourbitint();
  n = curval;
  if (readopen[n] != closed) {
    aclose(&readfile[n]);
    readopen[n] = closed;
  }
  if (c == 0)
    return;
  scanoptionalequals();
  scanfilename();
  if (curext == S(""))
    curext = S(".tex");
#if 0
  packfilename(curname,curarea,curext);
#else
  packfilename(curname,S("TeXinputs:"),curext);
#endif
  if (aopenin(&readfile[n]))
    readopen[n] = justopen;
}


/*:1275*/
/*1279:*/
Static void issuemessage(void)
{
  char oldsetting;
  char c;
  strnumber s;

  c = curchr;
  link(garbage) = scantoks(false, true);
  oldsetting = selector;
  selector = newstring;
  tokenshow(defref);
  selector = oldsetting;
  flushlist(defref);
  str_room(1);
  s = makestring();
  if (c == 0) {   /*1280:*/
    if (termoffset + flength(s) > maxprintline - 2) {
      println();
    } else if (termoffset > 0 || fileoffset > 0)
      printchar(' ');
    slowprint(s);
    fflush(termout);
  } else  /*1283:*/
  {   /*:1283*/
    printnl(S("! "));
    print(S(""));
    slowprint(s);
    if (errhelp != 0)
      useerrhelp = true;
    else if (longhelpseen) {
      help1(S("(That was another \\errmessage.)"));
    } else {
      if (interaction < errorstopmode)
	longhelpseen = true;
      help4(S("This error message was generated by an \\errmessage"),S("command, so I can't give any explicit help."),S("Pretend that you're Hercule Poirot: Examine all clues,"),S("and deduce the truth by order and method."));
    }
    error();
    useerrhelp = false;
  }
  /*:1280*/
  flushstring();
}


/*:1279*/
/*1288:*/
Static void shiftcase(void)
{
  pointer b, p;
  halfword t;
  eightbits c;

  b = curchr;
  p = scantoks(false, false);
  p = link(defref);
  while (p != 0) {  /*1289:*/
    t = info(p);
    if (t < cstokenflag + singlebase) {   /*:1289*/
      c = t & (dwa_do_8-1);
      if (equiv(b + c) != 0)
	info(p) = t - c + equiv(b + c);
    }
    p = link(p);
  }
  backlist(link(defref));
  freeavail(defref);
}


/*:1288*/
/*1293:*/
Static void showwhatever(void)
{
  pointer p;

  switch (curchr) {

  case showlists:
    begindiagnostic();
    showactivities();
    break;

  case showboxcode:   /*1296:*/
    scaneightbitint();
    begindiagnostic();
    printnl(S("> \\box"));
    printint(curval);
    printchar('=');
    if (box(curval) == 0)
      print(S("void"));
    else
      showbox(box(curval));
    break;
    /*:1296*/

  case showcode:   /*1294:*/
    gettoken();
    printnl(S("> "));
    if (curcs != 0) {
      sprintcs(curcs);
      printchar('=');
    }
    printmeaning();
    goto _Lcommonending;
    break;
    /*:1294*/
    /*1297:*/

  default:
    p = thetoks();
    printnl(S("> "));
    tokenshow(temphead);
    flushlist(link(temphead));
    goto _Lcommonending;   /*:1297*/
    break;
  }/*1298:*/
  enddiagnostic(true);
  printnl(S("! "));
  print(S("OK"));
  if (selector == termandlog) {
    if (tracingonline <= 0) {   /*:1298*/
      selector = termonly;
      print(S(" (see the transcript file)"));
      selector = termandlog;
    }
  }
_Lcommonending:
  if (interaction < errorstopmode) {
    helpptr = 0;
    errorcount--;
  } else if (tracingonline > 0) {
    help3(S("This isn't an error message; I'm just \\showing something."),S("Type `I\\show...' to show more (e.g., \\show\\cs,"),S("\\showthe\\count10, \\showbox255, \\showlists)."));
  } else {
    help5(S("This isn't an error message; I'm just \\showing something."),S("Type `I\\show...' to show more (e.g., \\show\\cs,"),S("\\showthe\\count10, \\showbox255, \\showlists)."),S("And type `I\\tracingonline=1\\show...' to show boxes and"),S("lists on your terminal as well as in the transcript file."));
  }
  error();
}


/*:1293*/
/*1302:*/
Static void storefmtfile(void)
{  /*1304:*/
  long j, k, l, x;
  pointer p, q;
  memoryword pppfmtfile;
  if (saveptr != 0) {
    printnl(S("! "));
    print(S("You can't dump inside a group"));
    help1(S("`{...\\dump}' is a no-no."));
    if (interaction == errorstopmode)
      interaction = scrollmode;
    if (logopened)   /*_DEBUG*/
      error();
    if (interaction > batchmode)
      debughelp();
    /*_ENDDEBUG*/
    history = fatalerrorstop;
    jumpout();
  }
  /*:1304*/
  /*1328:*/
  selector = newstring;
  print(S(" (preloaded format="));
  print(jobname);
  printchar(' ');
/* p2c: tex1.p: Note: Using % for possibly-negative arguments [317] */
  printint(year % 100);
  printchar('.');
  printint(month);
  printchar('.');
  printint(day);
  printchar(')');
  if (interaction == batchmode)
    selector = logonly;
  else
    selector = termandlog;
  str_room(1);
  formatident = makestring();
  packjobname(formatextension);
  while (!wopenout(&fmtfile))
    promptfilename(S("format file name"), formatextension);
  printnl(S("Beginning to dump on file "));
  slowprint(wmakenamestring(&fmtfile));
  flushstring();
  printnl(S(""));   /*:1328*/
  slowprint(formatident);   /*1307:*/
  pppfmtfile.int_ = 371982687L;
  pput(pppfmtfile);
  pppfmtfile.int_ = membot;
  pput(pppfmtfile);
  pppfmtfile.int_ = memtop;
  pput(pppfmtfile);
  pppfmtfile.int_ = eqtbsize;
  pput(pppfmtfile);
  pppfmtfile.int_ = hashprime;
  pput(pppfmtfile);
  pppfmtfile.int_ = hyphsize;
  pput(pppfmtfile);   /*:1307*/
  str_dump(fmtfile);
   /*1311:*/
  sortavail();
  varused = 0;
  pppfmtfile.int_ = lomemmax;
  pput(pppfmtfile);
  pppfmtfile.int_ = rover;
  pput(pppfmtfile);
  p = membot;
  q = rover;
  x = 0;
  do {
    for (k = p; k <= q + 1; k++) {
      pppfmtfile = mem[k - memmin];
      pput(pppfmtfile);
    }
    x += q - p + 2;
    varused += q - p;
    p = q + nodesize(q);
    q = rlink(q);
  } while (q != rover);
  varused += lomemmax - p;
  dynused = memend - himemmin + 1;
  for (k = p; k <= lomemmax ; k++) {
    pppfmtfile = mem[k - memmin];
    pput(pppfmtfile);
  }
  x += lomemmax - p + 1;
  pppfmtfile.int_ = himemmin;
  pput(pppfmtfile);
  pppfmtfile.int_ = avail;
  pput(pppfmtfile);
  for (k = himemmin; k <= memend; k++) {
    pppfmtfile = mem[k - memmin];
    pput(pppfmtfile);
  }
  x += memend - himemmin + 1;
  p = avail;
  while (p != 0) {
    dynused--;
    p = link(p);
  }
  pppfmtfile.int_ = varused;
  pput(pppfmtfile);
  pppfmtfile.int_ = dynused;
  pput(pppfmtfile);
  println();
  printint(x);
  print(S(" memory locations dumped; current usage is "));
  printint(varused);
  printchar('&');   /*:1311*/
  printint(dynused);   /*1313:*/
  /*1315:*/
  k = activebase;
  do {   /*1316:*/
    j = k;
    while (j < intbase - 1) {
      if ((equiv(j) == equiv(j + 1)) & (eqtype(j) ==
	    eqtype(j + 1)) & (eqlevel(j) == eqlevel(j + 1)))
	goto _Lfound1;
      j++;
    }
    l = intbase;
    goto _Ldone1;
_Lfound1:
    j++;
    l = j;
    while (j < intbase - 1) {
      if ((equiv(j) != equiv(j + 1)) | (eqtype(j) !=
	    eqtype(j + 1)) | (eqlevel(j) != eqlevel(j + 1)))
	goto _Ldone1;
      j++;
    }
_Ldone1:
    pppfmtfile.int_ = l - k;
    pput(pppfmtfile);
    while (k < l) {
      pppfmtfile = eqtb[k - activebase];
      pput(pppfmtfile);
      k++;
    }
    k = j + 1;
    pppfmtfile.int_ = k - l;
    pput(pppfmtfile);   /*:1315*/
  } while (k != intbase);
  do {
    j = k;
    while (j < eqtbsize) {
      if (eqtb[j - activebase].int_ == eqtb[j - activebase + 1].int_)
	goto _Lfound2;
      j++;
    }
    l = eqtbsize + 1;
    goto _Ldone2;
_Lfound2:
    j++;
    l = j;
    while (j < eqtbsize) {
      if (eqtb[j - activebase].int_ != eqtb[j - activebase + 1].int_)
	goto _Ldone2;
      j++;
    }
_Ldone2:
    pppfmtfile.int_ = l - k;
    pput(pppfmtfile);
    while (k < l) {
      pppfmtfile = eqtb[k - activebase];
      pput(pppfmtfile);
      k++;
    }
    k = j + 1;
    pppfmtfile.int_ = k - l;
    pput(pppfmtfile);   /*:1316*/
  } while (k <= eqtbsize);
  pppfmtfile.int_ = parloc;
  pput(pppfmtfile);
  pppfmtfile.int_ = writeloc;
  pput(pppfmtfile);   /*1318:*/
  pppfmtfile.int_ = hashused;
  pput(pppfmtfile);
  cscount = frozencontrolsequence - hashused - 1;
  for (p = hashbase; p <= hashused; p++) {
    if (text(p) != 0) {
      pppfmtfile.int_ = p;
      pput(pppfmtfile);
      pppfmtfile.hh = hash[p - hashbase];
      pput(pppfmtfile);
      cscount++;
    }
  }
  for (p = hashused + 1; p < undefinedcontrolsequence; p++) {
    pppfmtfile.hh = hash[p - hashbase];
    pput(pppfmtfile);
  }
  pppfmtfile.int_ = cscount;
  pput(pppfmtfile);
  println();
  printint(cscount);   /*:1318*/
  /*:1313*/
  print(S(" multiletter control sequences"));   
  fonts_dump(fmtfile);
  /*1324:*/
  pppfmtfile.int_ = hyphcount;
  pput(pppfmtfile);
  for (k = 0; k <= hyphsize; k++) {
    if (hyphword[k] != 0) {
      pppfmtfile.int_ = k;
      pput(pppfmtfile);
      pppfmtfile.int_ = hyphword[k];
      pput(pppfmtfile);
      pppfmtfile.int_ = hyphlist[k];
      pput(pppfmtfile);
    }
  }
  println();
  printint(hyphcount);
  print(S(" hyphenation exception"));
  if (hyphcount != 1)
    printchar('s');
  if (trienotready)
    inittrie();
  pppfmtfile.int_ = triemax;
  pput(pppfmtfile);
  for (k = 0; k <= triemax; k++) {
    pppfmtfile.hh = trie[k];
    pput(pppfmtfile);
  }
  pppfmtfile.int_ = trieopptr;
  pput(pppfmtfile);
  for (k = 0; k < trieopptr; k++) {
    pppfmtfile.int_ = hyfdistance[k];
    pput(pppfmtfile);
    pppfmtfile.int_ = hyfnum[k];
    pput(pppfmtfile);
    pppfmtfile.int_ = hyfnext[k];
    pput(pppfmtfile);
  }
  printnl(S("Hyphenation trie of length "));
  printint(triemax);
  print(S(" has "));
  printint(trieopptr);
  print(S(" op"));
  if (trieopptr != 1)
    printchar('s');
  print(S(" out of "));
  printint(trieopsize);
  for (k = 255; k >= 0; k--) {   /*1326:*/
    if (trieused[k] > minquarterword) {   /*:1324*/
      printnl(S("  "));
      printint(trieused[k] - minquarterword);
      print(S(" for language "));
      printint(k);
      pppfmtfile.int_ = k;
      pput(pppfmtfile);
      pppfmtfile.int_ = trieused[k] - minquarterword;
      pput(pppfmtfile);
    }
  }
  pppfmtfile.int_ = interaction;
  pput(pppfmtfile);
  pppfmtfile.int_ = formatident;
  pput(pppfmtfile);
  pppfmtfile.int_ = 69069L;
  pput(pppfmtfile);
  tracingstats = 0;   /*:1326*/
  /*1329:*/
  /*:1329*/
  wclose(&fmtfile);
}

/*:1302*/
/*1348:*/
/*1349:*/
Static void newwhatsit(smallnumber s, smallnumber w)
{
  pointer p;

  p = getnode(w);
  type(p) = whatsitnode;
  subtype(p) = s;
  link(tail) = p;
  tail = p;
}


/*:1349*/
/*1350:*/
Static void newwritewhatsit(smallnumber w)
{
  newwhatsit(curchr, w);
  if (w != writenodesize)
    scanfourbitint();
  else {
    scanint();
    if (curval < 0)
      curval = 17;
    else if (curval > 15)
      curval = 16;
  }
  writestream(tail) = curval;
}


/*:1350*/
Static void doextension(void)
{
  long k;
  pointer p;

  switch (curchr) {

  case opennode:   /*1351:*/
    newwritewhatsit(opennodesize);
    scanoptionalequals();
    scanfilename();
    openname(tail) = curname;
    openarea(tail) = curarea;
    openext(tail) = curext;
    break;
    /*:1351*/

  case writenode:   /*1352:*/
    k = curcs;
    newwritewhatsit(writenodesize);
    curcs = k;
    p = scantoks(false, false);
    writetokens(tail) = defref;
    break;
    /*:1352*/

  case closenode:   /*1353:*/
    newwritewhatsit(writenodesize);
    writetokens(tail) = 0;
    break;
    /*:1353*/

  case specialnode:   /*1354:*/
    newwhatsit(specialnode, writenodesize);
    writestream(tail) = 0;
    p = scantoks(false, true);
    writetokens(tail) = defref;
    break;
    /*:1354*/

  case immediatecode:   /*1375:*/
    getxtoken();
    if (curcmd == extension && curchr <= closenode) {
      p = tail;
      doextension();
      outwhat(tail);
      flushnodelist(tail);
      tail = p;
      link(p) = 0;
    } else
      backinput();
    break;
    /*:1375*/

  case setlanguagecode:   /*1377:*/
    if (labs(mode) != hmode)
      reportillegalcase();
    else {   /*:1377*/
      newwhatsit(languagenode, smallnodesize);
      scanint();
      if (curval <= 0)
	clang = 0;
      else if (curval > 255)
	clang = 0;
      else
	clang = curval;
      whatlang(tail) = clang;
      whatlhm(tail) = normmin(lefthyphenmin);
      whatrhm(tail) = normmin(righthyphenmin);
    }
    break;

  default:
    confusion(S("ext1"));
    break;
  }
}


/*:1348*/
/*1376:*/
Static void fixlanguage(void)
{
  ASCIIcode l;

  if (language <= 0)
    l = 0;
  else if (language > 255)
    l = 0;
  else
    l = language;
  if (l == clang)
    return;
  newwhatsit(languagenode, smallnodesize);
  whatlang(tail) = l;
  clang = l;
  whatlhm(tail) = normmin(lefthyphenmin);
  whatrhm(tail) = normmin(righthyphenmin);
}


/*:1376*/
/*1068:*/
Static void handlerightbrace(void)
{
  pointer p, q;
  scaled d;
  long f;

  switch (curgroup) {

  case simplegroup:
    unsave();
    break;

  case bottomlevel:
    printnl(S("! "));
    print(S("Too many }'s"));
    help2(S("You've closed more groups than you opened."),S("Such booboos are generally harmless, so keep going."));
    error();
    break;

  case semisimplegroup:
  case mathshiftgroup:
  case mathleftgroup:
    extrarightbrace();
    break;

  /*1085:*/
  case hboxgroup:
    package(0);
    break;

  case adjustedhboxgroup:
    adjusttail = adjusthead;
    package(0);
    break;

  case vboxgroup:
    endgraf();
    package(0);
    break;

  case vtopgroup:   /*:1085*/
    endgraf();
    package(vtopcode);
    break;
    /*1100:*/

  case insertgroup:
    endgraf();
    q = splittopskip;
    addglueref(q);
    d = splitmaxdepth;
    f = floatingpenalty;
    unsave();
    saveptr--;
    p = vpack(link(head), 0, additional);
/* p2c: tex1.p: Warning: Too many arguments for foovpack [299] */
    popnest();
    if (saved(0) < 255) {
      tailappend(getnode(insnodesize));
      type(tail) = insnode;
      subtype(tail) = saved(0);
      height(tail) = height(p) + depth(p);
      insptr(tail) = listptr(p);
      splittopptr(tail) = q;
      depth(tail) = d;
      floatcost(tail) = f;
    } else {
      tailappend(getnode(smallnodesize));
      type(tail) = adjustnode;
      subtype(tail) = 0;
      adjustptr(tail) = listptr(p);
      deleteglueref(q);
    }
    freenode(p, boxnodesize);
    if (nestptr == 0)
      buildpage();
    break;

  case outputgroup:   /*1026:*/
    if (loc != 0 || (tokentype != outputtext && tokentype != backedup) )
    {   /*:1027*/
      printnl(S("! "));
      print(S("Unbalanced output routine"));
      help2(S("Your sneaky output routine has problematic {'s and/or }'s."),S("I can't handle that very well; good luck."));
      error();
      do {
	gettoken();
      } while (loc != 0);
    }
    endtokenlist();
    endgraf();
    unsave();
    outputactive = false;
    insertpenalties = 0;   /*1028:*/
    if (box(255) != 0) {   /*:1028*/
      printnl(S("! "));
      print(S("Output routine didn't use all of "));
      printesc(S("box"));
      printint(255);
      help3(S("Your \\output commands should empty \\box255,"),S("e.g., by saying `\\shipout\\box255'."),S("Proceed; I'll discard its present contents."));
      boxerror(255);
    }
    if (tail != head) {
      link(pagetail) = link(head);
      pagetail = tail;
    }
    if (link(pagehead) != 0) {
      if (link(contribhead) == 0)
	contribtail = pagetail;
      link(pagetail) = link(contribhead);
      link(contribhead) = link(pagehead);
      link(pagehead) = 0;
      pagetail = pagehead;
    }
    popnest();
    buildpage();
    break;
    /*:1026*/
    /*:1100*/
    /*1118:*/

  case discgroup:   /*:1118*/
    builddiscretionary();
    break;
    /*1132:*/

  case aligngroup:   /*:1132*/
    backinput();
    curtok = cstokenflag + frozencr;
    printnl(S("! "));
    print(S("Missing "));
    printesc(S("cr"));
    print(S(" inserted"));
    help1(S("I'm guessing that you meant to end an alignment here."));
    inserror();
    break;
    /*1133:*/

  case noaligngroup:   /*:1133*/
    endgraf();
    unsave();
    alignpeek();
    break;
    /*1168:*/

  case vcentergroup:   /*:1168*/
    endgraf();
    unsave();
    saveptr -= 2;
    p = vpack(link(head), saved(1), saved(0));
/* p2c: tex1.p: Warning: Too many arguments for foovpack [299] */
    popnest();
    tailappend(newnoad());
    type(tail) = vcenternoad;
    mathtype(nucleus(tail)) = subbox;
    info(nucleus(tail)) = p;
    break;
    /*1173:*/

  case mathchoicegroup:   /*:1173*/
    buildchoices();
    break;
    /*1186:*/

  case mathgroup:
    unsave();
    saveptr--;
    mathtype(saved(0)) = submlist;
    p = finmlist(0);
    info(saved(0)) = p;
    if (p != 0) {
      if (link(p) == 0) {
	if (type(p) == ordnoad) {
	  if (mathtype(subscr(p)) == empty) {
	    if (mathtype(supscr(p)) == empty) {
	      mem[saved(0) - memmin].hh = mem[nucleus(p) - memmin].hh;
	      freenode(p, noadsize);
	    }
	  }
	} else if (type(p) == accentnoad) {
	  if (saved(0) == nucleus(tail)) {
	    if (type(tail) == ordnoad) {   /*1187:*/
	      q = head;
	      while (link(q) != tail)
		q = link(q);
	      link(q) = p;
	      freenode(tail, noadsize);
	      tail = p;
	    }
	    /*:1187*/
	  }
	}
      }
    }
    break;
    /*:1186*/

  default:
    confusion(S("rightbrace"));
    break;
  }

  /*
1027:*/
}  /*:1068*/


Static void maincontrol(void)
{
  long t;

  if (everyjob != 0)
    begintokenlist(everyjob, everyjobtext);
_Lbigswitch_:
  getxtoken();
_Lreswitch:   /*1031:*/
  if (interrupt != 0) {
    if (OKtointerrupt) {
      backinput();
      checkinterrupt();
      goto _Lbigswitch_;
    }  /*_DEBUG*/
  }
  if (panicking)   /*_ENDDEBUG*/
    checkmem(false);
  if (tracingcommands > 0)   /*:1031*/
    showcurcmdchr();
  switch (labs(mode) + curcmd) {

  case hmode + letter:
  case hmode + otherchar:
  case hmode + chargiven:
    goto _Lmainloop;
    break;

  case hmode + charnum:
    scancharnum();
    curchr = curval;
    goto _Lmainloop;
    break;

  case hmode + noboundary:
    getxtoken();
    if (curcmd == letter || curcmd == otherchar || curcmd == chargiven ||
	curcmd == charnum)
      cancelboundary = true;
    goto _Lreswitch;
    break;

  case hmode + spacer:
    if (spacefactor == 1000)
      goto _Lappendnormalspace_;
    appspace();
    break;

  case hmode + exspace:
  case mmode + exspace:   /*1045:*/
    goto _Lappendnormalspace_;
    break;

  case vmode:
  case hmode:
  case mmode:
  case vmode + spacer:
  case mmode + spacer:
  case mmode + noboundary:
    /* blank case */
    break;

  case vmode + ignorespaces:
  case hmode + ignorespaces:
  case mmode + ignorespaces:  /*406:*/
    do {
      getxtoken();   /*:406*/
    } while (curcmd == spacer);
    goto _Lreswitch;
    break;

  case vmode + stop:   /*1048:*/
    if (itsallover())
      goto _Lexit;
    break;

  case vmode + vmove:
  case hmode + hmove:
  case mmode + hmove:
  case vmode + lastitem:
  case hmode + lastitem:
  case mmode + lastitem:
  case vmode + vadjust:
  case vmode + italcorr:
  case vmode + eqno:
  case hmode + eqno:
  case vmode + macparam:
  case hmode + macparam:
  case mmode + macparam:   /*:1048*/
    reportillegalcase();
    break;
    /*1098:*/
    /*:1098*/
    /*1111:*/
    /*:1111*/
    /*1144:*/
    /*:1144*/
    /*1046:*/

  case vmode + supmark:
  case hmode + supmark:
  case vmode + submark:
  case hmode + submark:
  case vmode + mathcharnum:
  case hmode + mathcharnum:
  case vmode + mathgiven:
  case hmode + mathgiven:
  case vmode + mathcomp:
  case hmode + mathcomp:
  case vmode + delimnum:
  case hmode + delimnum:
  case vmode + leftright:
  case hmode + leftright:
  case vmode + above:
  case hmode + above:
  case vmode + radical:
  case hmode + radical:
  case vmode + mathstyle:
  case hmode + mathstyle:
  case vmode + mathchoice:
  case hmode + mathchoice:
  case vmode + vcenter:
  case hmode + vcenter:
  case vmode + nonscript:
  case hmode + nonscript:
  case vmode + mkern:
  case hmode + mkern:
  case vmode + limitswitch:
  case hmode + limitswitch:
  case vmode + mskip:
  case hmode + mskip:
  case vmode + mathaccent:
  case hmode + mathaccent:
  case mmode + endv:
  case mmode + parend:
  case mmode + stop:
  case mmode + vskip:
  case mmode + unvbox:
  case mmode + valign:
  case mmode + hrule:   /*:1046*/
    insertdollarsign();
    break;

  /*1056:*/
  case vmode + hrule:
  case hmode + vrule:
  case mmode + vrule:   /*:1056*/
    tailappend(scanrulespec());
    if (labs(mode) == vmode)
      prevdepth = ignoredepth;
    else if (labs(mode) == hmode)
      spacefactor = 1000;
    break;
    /*1057:*/

  case vmode + vskip:
  case hmode + hskip:
  case mmode + hskip:
  case mmode + mskip:
    appendglue();
    break;

  case vmode + kern:
  case hmode + kern:
  case mmode + kern:
  case mmode + mkern:   /*:1057*/
    appendkern();
    break;
    /*1063:*/

  case vmode + leftbrace:
  case hmode + leftbrace:
    newsavelevel(simplegroup);
    break;

  case vmode + begingroup:
  case hmode + begingroup:
  case mmode + begingroup:
    newsavelevel(semisimplegroup);
    break;

  case vmode + endgroup:
  case hmode + endgroup:
  case mmode + endgroup:   /*:1063*/
    if (curgroup == semisimplegroup)
      unsave();
    else
      offsave();
    break;
    /*1067:*/

  case vmode + rightbrace:
  case hmode + rightbrace:
  case mmode + rightbrace:
    handlerightbrace();
    break;

  /*:1067*/
  /*1073:*/
  case vmode + hmove:
  case hmode + vmove:
  case mmode + vmove:
    t = curchr;
    scannormaldimen();
    if (t == 0)
      scanbox(curval);
    else
      scanbox(-curval);
    break;

  case vmode + leadership:
  case hmode + leadership:
  case mmode + leadership:
    scanbox(leaderflag - aleaders + curchr);
    break;

  case vmode + makebox:
  case hmode + makebox:
  case mmode + makebox:
    beginbox(0);
    break;

  /*:1073*/
  /*1090:*/
  case vmode + startpar:
    newgraf(curchr > 0);
    break;

  case vmode + letter:
  case vmode + otherchar:
  case vmode + charnum:
  case vmode + chargiven:
  case vmode + mathshift:
  case vmode + unhbox:
  case vmode + vrule:
  case vmode + accent:
  case vmode + discretionary:
  case vmode + hskip:
  case vmode + valign:
  case vmode + exspace:
  case vmode + noboundary:   /*:1090*/
    backinput();
    newgraf(true);
    break;
    /*1092:*/

  case hmode + startpar:
  case mmode + startpar:   /*:1092*/
    indentinhmode();
    break;
    /*1094:*/

  case vmode + parend:
    normalparagraph();
    if (mode > 0)
      buildpage();
    break;

  case hmode + parend:
    if (alignstate < 0)
      offsave();
    endgraf();
    if (mode == vmode)
      buildpage();
    break;

  case hmode + stop:
  case hmode + vskip:
  case hmode + hrule:
  case hmode + unvbox:
  case hmode + halign:   /*:1094*/
    headforvmode();
    break;
    /*1097:*/

  case vmode + insert_:
  case hmode + insert_:
  case mmode + insert_:
  case hmode + vadjust:
  case mmode + vadjust:
    begininsertoradjust();
    break;

  case vmode + mark_:
  case hmode + mark_:
  case mmode + mark_:   /*:1097*/
    makemark();
    break;

  /*1102:*/
  case vmode + breakpenalty:
  case hmode + breakpenalty:
  case mmode + breakpenalty:
    appendpenalty();
    break;

  /*:1102*/
  /*1104:*/
  case vmode + removeitem:
  case hmode + removeitem:
  case mmode + removeitem:   /*:1104*/
    deletelast();
    break;

  /*1109:*/
  case vmode + unvbox:
  case hmode + unhbox:
  case mmode + unhbox:
    unpackage();
    break;

  /*:1109*/
  /*1112:*/
  case hmode + italcorr:
    appenditaliccorrection();
    break;

  case mmode + italcorr:   /*:1112*/
    tailappend(newkern(0));
    break;
    /*1116:*/

  case hmode + discretionary:
  case mmode + discretionary:   /*:1116*/
    appenddiscretionary();
    break;

  /*1122:*/
  case hmode + accent:
    makeaccent();
    break;

  /*:1122*/
  /*1126:*/
  case vmode + carret:
  case hmode + carret:
  case mmode + carret:
  case vmode + tabmark:
  case hmode + tabmark:
  case mmode + tabmark:
    alignerror();
    break;

  case vmode + noalign:
  case hmode + noalign:
  case mmode + noalign:
    noalignerror();
    break;

  case vmode + omit:
  case hmode + omit:
  case mmode + omit:   /*:1126*/
    omiterror();
    break;
    /*1130:*/

  case vmode + halign:
  case hmode + valign:
    initalign();
    break;

  case mmode + halign:
    if (privileged()) {
      if (curgroup == mathshiftgroup)
	initalign();
      else
	offsave();
    }
    break;

  case vmode + endv:
  case hmode + endv:   /*:1130*/
    doendv();
    break;
    /*1134:*/

  case vmode + endcsname:
  case hmode + endcsname:
  case mmode + endcsname:   /*:1134*/
    cserror();
    break;
    /*1137:*/

  case hmode + mathshift:   /*:1137*/
    initmath();
    break;
    /*1140:*/

  case mmode + eqno:   /*:1140*/
    if (privileged()) {
      if (curgroup == mathshiftgroup)
	starteqno();
      else
	offsave();
    }
    break;
    /*1150:*/

  case mmode + leftbrace:   /*:1150*/
    tailappend(newnoad());
    backinput();
    scanmath(nucleus(tail));
    break;
    /*1154:*/

  case mmode + letter:
  case mmode + otherchar:
  case mmode + chargiven:
    setmathchar(mathcode(curchr));
    break;

  case mmode + charnum:
    scancharnum();
    curchr = curval;
    setmathchar(mathcode(curchr));
    break;

  case mmode + mathcharnum:
    scanfifteenbitint();
    setmathchar(curval);
    break;

  case mmode + mathgiven:
    setmathchar(curchr);
    break;

  case mmode + delimnum:   /*:1154*/
    scantwentysevenbitint();
    setmathchar(curval / 4096);
    break;
    /*1158:*/

  case mmode + mathcomp:
    tailappend(newnoad());
    type(tail) = curchr;
    scanmath(nucleus(tail));
    break;

  case mmode + limitswitch:   /*:1158*/
    mathlimitswitch();
    break;
    /*1162:*/

  case mmode + radical:   /*:1162*/
    mathradical();
    break;
    /*1164:*/

  case mmode + accent:
  case mmode + mathaccent:   /*:1164*/
    mathac();
    break;
    /*1167:*/

  case mmode + vcenter:
    scanspec(vcentergroup, false);
    normalparagraph();
    pushnest();
    mode = -vmode;
    prevdepth = ignoredepth;
    if (everyvbox != 0)
      begintokenlist(everyvbox, everyvboxtext);
    break;
    /*:1167*/

  /*1171:*/
  case mmode + mathstyle:
    tailappend(newstyle(curchr));
    break;

  case mmode + nonscript:
    tailappend(newglue(zeroglue));
    subtype(tail) = condmathglue;
    break;

  case mmode + mathchoice:
    appendchoices();
    break;

  /*:1171*/
  /*1175:*/
  case mmode + submark:
  case mmode + supmark:
    subsup();
    break;

  /*:1175*/
  /*1180:*/
  case mmode + above:   /*:1180*/
    mathfraction();
    break;
    /*1190:*/

  case mmode + leftright:
    mathleftright();
    break;

  /*:1190*/
  /*1193:*/
  case mmode + mathshift:
    if (curgroup == mathshiftgroup)
      aftermath();
    else
      offsave();
    break;

  /*:1193*/
  /*1210:*/
  case vmode + toksregister:
  case hmode + toksregister:
  case mmode + toksregister:
  case vmode + assigntoks:
  case hmode + assigntoks:
  case mmode + assigntoks:
  case vmode + assignint:
  case hmode + assignint:
  case mmode + assignint:
  case vmode + assigndimen:
  case hmode + assigndimen:
  case mmode + assigndimen:
  case vmode + assignglue:
  case hmode + assignglue:
  case mmode + assignglue:
  case vmode + assignmuglue:
  case hmode + assignmuglue:
  case mmode + assignmuglue:
  case vmode + assignfontdimen:
  case hmode + assignfontdimen:
  case mmode + assignfontdimen:
  case vmode + assignfontint:
  case hmode + assignfontint:
  case mmode + assignfontint:
  case vmode + setaux:
  case hmode + setaux:
  case mmode + setaux:
  case vmode + setprevgraf:
  case hmode + setprevgraf:
  case mmode + setprevgraf:
  case vmode + setpagedimen:
  case hmode + setpagedimen:
  case mmode + setpagedimen:
  case vmode + setpageint:
  case hmode + setpageint:
  case mmode + setpageint:
  case vmode + setboxdimen:
  case hmode + setboxdimen:
  case mmode + setboxdimen:
  case vmode + setshape:
  case hmode + setshape:
  case mmode + setshape:
  case vmode + defcode:
  case hmode + defcode:
  case mmode + defcode:
  case vmode + deffamily:
  case hmode + deffamily:
  case mmode + deffamily:
  case vmode + setfont:
  case hmode + setfont:
  case mmode + setfont:
  case vmode + deffont:
  case hmode + deffont:
  case mmode + deffont:
  case vmode + register_:
  case hmode + register_:
  case mmode + register_:
  case vmode + advance:
  case hmode + advance:
  case mmode + advance:
  case vmode + multiply:
  case hmode + multiply:
  case mmode + multiply:
  case vmode + divide:
  case hmode + divide:
  case mmode + divide:
  case vmode + prefix:
  case hmode + prefix:
  case mmode + prefix:
  case vmode + let:
  case hmode + let:
  case mmode + let:
  case vmode + shorthanddef:
  case hmode + shorthanddef:
  case mmode + shorthanddef:
  case vmode + readtocs:
  case hmode + readtocs:
  case mmode + readtocs:
  case vmode + def:
  case hmode + def:
  case mmode + def:
  case vmode + setbox:
  case hmode + setbox:
  case mmode + setbox:
  case vmode + hyphdata:
  case hmode + hyphdata:
  case mmode + hyphdata:
  case vmode + setinteraction:
  case hmode + setinteraction:
  case mmode + setinteraction:   /*:1210*/
    prefixedcommand();
    break;
    /*1268:*/

  case vmode + afterassignment:
  case hmode + afterassignment:
  case mmode + afterassignment:   /*:1268*/
    gettoken();
    aftertoken = curtok;
    break;
    /*1271:*/

  case vmode + aftergroup:
  case hmode + aftergroup:
  case mmode + aftergroup:   /*:1271*/
    gettoken();
    saveforafter(curtok);
    break;
    /*1274:*/

  case vmode + instream:
  case hmode + instream:
  case mmode + instream:   /*:1274*/
    openorclosein();
    break;

  /*1276:*/
  case vmode + message:
  case hmode + message:
  case mmode + message:
    issuemessage();
    break;

  /*:1276*/
  /*1285:*/
  case vmode + caseshift:
  case hmode + caseshift:
  case mmode + caseshift:
    shiftcase();
    break;

  /*:1285*/
  /*1290:*/
  case vmode + xray:
  case hmode + xray:
  case mmode + xray:
    showwhatever();
    break;

  /*:1290*/
  /*1347:*/
  case vmode + extension:
  case hmode + extension:
  case mmode + extension:   /*:1347*/
    doextension();
    break;
    /*:1045*/
  }
  goto _Lbigswitch_;
_Lmainloop:
  /*1034:*/
  adjustspacefactor();
  mainf = curfont;
  bchar = fontbchar[mainf ];
  falsebchar = fontfalsebchar[mainf ];
  if (mode > 0) {
    if (language != clang)
      fixlanguage();
  }
  fastgetavail(ligstack);
  font(ligstack) = mainf;
  curl = curchr;
  character(ligstack) = curl;
  curq = tail;
  if (cancelboundary) {
    cancelboundary = false;
    maink = nonaddress;
  } else
    maink = bcharlabel[mainf ];
  if (maink == nonaddress)
    goto _Lmainloopmove2;
  curr = curl;
  curl = nonchar;
  goto _Lmainligloop1;
_Lmainloopwrapup:   /*1035:*/
  wrapup(rthit);   /*:1035*/
_Lmainloopmove:   /*1036:*/
  if (ligstack == 0)
    goto _Lreswitch;
  curq = tail;
  curl = character(ligstack);
_Lmainloopmove1:
  if (!ischarnode(ligstack))
    goto _Lmainloopmovelig;
_Lmainloopmove2:
  if (curchr < fontbc[mainf ] || curchr > fontec[mainf ]) {
    charwarning(mainf, curchr);
    freeavail(ligstack);
    goto _Lbigswitch_;
  }
  maini = charinfo(mainf, curl);
  if (!charexists(maini)) {
    charwarning(mainf, curchr);
    freeavail(ligstack);
    goto _Lbigswitch_;
  }
  tailappend(ligstack);   /*:1036*/
_Lmainlooplookahead:   /*1038:*/
  getnext();
  if (curcmd == letter)
    goto _Lmainlooplookahead1;
  if (curcmd == otherchar)
    goto _Lmainlooplookahead1;
  if (curcmd == chargiven)
    goto _Lmainlooplookahead1;
  xtoken();
  if (curcmd == letter)
    goto _Lmainlooplookahead1;
  if (curcmd == otherchar)
    goto _Lmainlooplookahead1;
  if (curcmd == chargiven)
    goto _Lmainlooplookahead1;
  if (curcmd == charnum) {
    scancharnum();
    curchr = curval;
    goto _Lmainlooplookahead1;
  }
  if (curcmd == noboundary)
    bchar = nonchar;
  curr = bchar;
  ligstack = 0;
  goto _Lmainligloop;
_Lmainlooplookahead1:
  adjustspacefactor();
  fastgetavail(ligstack);
  font(ligstack) = mainf;
  curr = curchr;
  character(ligstack) = curr;
  if (curr == falsebchar)
    curr = nonchar;   /*:1038*/
_Lmainligloop:   /*1039:*/
  if (chartag(maini) != ligtag) {
    goto _Lmainloopwrapup;
  }
  maink = ligkernstart(mainf,maini);
  mainj = fontinfo[maink].qqqq;
  if (skipbyte(mainj) <= stopflag)
    goto _Lmainligloop2;
  maink = ligkernrestart(mainf,mainj);
_Lmainligloop1:
  mainj = fontinfo[maink].qqqq;
_Lmainligloop2:
  if (nextchar(mainj) == curr) {
    if (skipbyte(mainj) <= stopflag) {   /*1040:*/
      if (opbyte(mainj) >= kernflag) {
	wrapup(rthit);
	tailappend(newkern(charkern(mainf, mainj)));
	goto _Lmainloopmove;
      }
      if (curl == nonchar)
	lfthit = true;
      else if (ligstack == 0)
	rthit = true;
      checkinterrupt();
      switch (opbyte(mainj)) {

      case minquarterword + 1:
      case minquarterword + 5:
	curl = rembyte(mainj);
	maini = charinfo(mainf, curl);
	ligaturepresent = true;
	break;

      case minquarterword + 2:
      case minquarterword + 6:
	curr = rembyte(mainj);
	if (ligstack == 0) {
	  ligstack = newligitem(curr);
	  bchar = nonchar;
	} else if (ischarnode(ligstack)) {
	  mainp = ligstack;
	  ligstack = newligitem(curr);
	  ligptr(ligstack) = mainp;
	} else
	  character(ligstack) = curr;
	break;

      case minquarterword + 3:
	curr = rembyte(mainj);
	mainp = ligstack;
	ligstack = newligitem(curr);
	link(ligstack) = mainp;
	break;

      case minquarterword + 7:
      case minquarterword + 11:
	wrapup(false);
	curq = tail;
	curl = rembyte(mainj);
	maini = charinfo(mainf, curl);
	ligaturepresent = true;
	break;

      default:
	curl = rembyte(mainj);
	ligaturepresent = true;
	if (ligstack == 0)
	  goto _Lmainloopwrapup;
	else
	  goto _Lmainloopmove1;
	break;
      }
      if (opbyte(mainj) > minquarterword + 4) {
	if (opbyte(mainj) != minquarterword + 7)
	  goto _Lmainloopwrapup;
      }
      if (curl < nonchar)
	goto _Lmainligloop;
      maink = bcharlabel[mainf ];
      goto _Lmainligloop1;
    }
    /*:1040*/
  }
  if (skipbyte(mainj) == minquarterword)
    maink++;
  else {
    if (skipbyte(mainj) >= stopflag)
      goto _Lmainloopwrapup;
    maink += skipbyte(mainj) - minquarterword + 1;
  }
  goto _Lmainligloop1;   /*:1039*/
_Lmainloopmovelig:   /*1037:*/
  mainp = ligptr(ligstack);
  if (mainp > 0) {
    tailappend(mainp);
  }
  tempptr = ligstack;
  ligstack = link(tempptr);
  freenode(tempptr, smallnodesize);
  maini = charinfo(mainf, curl);
  ligaturepresent = true;
  if (ligstack == 0) {
    if (mainp > 0)
      goto _Lmainlooplookahead;
    curr = bchar;
  } else
    curr = character(ligstack);
  goto _Lmainligloop;   /*:1037*/
  /*:1034*/
_Lappendnormalspace_:   /*1041:*/
  if (spaceskip == zeroglue) {  /*1042:*/
    mainp = fontglue[curfont ];
    if (mainp == 0) {   /*:1042*/
      fontindex mmaink;
      mainp = newspec(zeroglue);
      mmaink = parambase[curfont ] + spacecode;
#if 1
	maink = mmaink;
#endif
      width(mainp) = fontinfo[mmaink].sc;
      stretch(mainp) = fontinfo[mmaink + 1].sc;
      shrink(mainp) = fontinfo[mmaink + 2].sc;
      fontglue[curfont ] = mainp;
    }
    tempptr = newglue(mainp);
  } else
    tempptr = newparamglue(spaceskipcode);
  link(tail) = tempptr;
  tail = tempptr;
  goto _Lbigswitch_;   /*:1041*/
_Lexit: ;
}


/*:1030*/
/*1284:*/
Static void giveerrhelp(void)
{
  tokenshow(errhelp);
}


/*:1284*/
/*1303:*/
#if 0
/*524:*/
Static boolean openfmtfile(void)
{
  short j;

  j = loc;
  if (buffer[loc] == '&') {
    loc++;
    j = loc;
    buffer[last] = ' ';
    while (buffer[j] != ' ')
      j++;
    packbufferedname(0, loc, j - 1);
    if (wopenin(&fmtfile))
      goto _Lfound;
    packbufferedname(formatarealength, loc, j - 1);
    if (wopenin(&fmtfile))
      goto _Lfound;
    fprintf(termout, "Sorry, I can't find that format; will try PLAIN.\n");
    fflush(termout);
  }
  packbufferedname(formatdefaultlength - formatextlength, 1, 0);
  if (!wopenin(&fmtfile)) {
    fprintf(termout, "I can't find the PLAIN format file!\n");
    return false;
  }
_Lfound:
  loc = j;
  return true;
}
#else 
Static boolean openfmtfile(void)
{
	return open_fmt(&fmtfile,termout);
}
#endif

/*:524*/
Static boolean loadfmtfile(void)
{  /*1308:*/
  boolean Result;
  long j, k, x;
  pointer p, q;
  /* fourquarters w; */
  memoryword pppfmtfile;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x != 371982687L)
    goto _Lbadfmt_;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x != membot)
    goto _Lbadfmt_;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x != memtop)
    goto _Lbadfmt_;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x != eqtbsize)
    goto _Lbadfmt_;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x != hashprime)
    goto _Lbadfmt_;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x != hyphsize)   /*1310:*/
    goto _Lbadfmt_;  
  if(!str_undump(fmtfile,termout)) goto _Lbadfmt_;
  /*1312:*/
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x < lomemstatmax + 1000 || x >= himemstatmin)
    goto _Lbadfmt_;
  lomemmax = x;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x <= lomemstatmax || x > lomemmax)
    goto _Lbadfmt_;
  rover = x;
  p = membot;
  q = rover;
  do {
    for (k = p; k <= q + 1; k++) {
      pget(pppfmtfile);
      mem[k - memmin] = pppfmtfile;
    }
    p = q + nodesize(q);
    if ((p > lomemmax) | ((q >= rlink(q)) & (rlink(q) != rover)))
      goto _Lbadfmt_;
    q = rlink(q);
  } while (q != rover);
  for (k = p; k <= lomemmax; k++) {
    pget(pppfmtfile);
    mem[k - memmin] = pppfmtfile;
  }
  if (memmin < membot - 2) {
    p = llink(rover);
    q = memmin + 1;
    link(memmin) = 0;
    info(memmin) = 0;
    rlink(p) = q;
    llink(rover) = q;
    rlink(q) = rover;
    llink(q) = p;
    link(q) = emptyflag;
    nodesize(q) = membot - q;
  }
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x <= lomemmax || x > himemstatmin)
    goto _Lbadfmt_;
  himemmin = x;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if ((unsigned long)x > memtop)
    goto _Lbadfmt_;
  avail = x;
  memend = memtop;
  for (k = himemmin; k <= memend ; k++) {
    pget(pppfmtfile);
    mem[k - memmin] = pppfmtfile;
  }
  pget(pppfmtfile);
  varused = pppfmtfile.int_;
  pget(pppfmtfile);
  dynused = pppfmtfile.int_;   /*:1312*/
  /*1314:*/
  /*1317:*/
  k = activebase;
  do {
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if (x < 1 || k + x > eqtbsize + 1)
      goto _Lbadfmt_;
    for (j = k; j < k + x; j++) {
      pget(pppfmtfile);
      eqtb[j - activebase] = pppfmtfile;
    }
    k += x;
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if (x < 0 || k + x > eqtbsize + 1)
      goto _Lbadfmt_;
    for (j = k; j < k + x; j++)
      eqtb[j - activebase] = eqtb[k - activebase - 1];
    k += x;   /*:1317*/
  } while (k <= eqtbsize);
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x < hashbase || x > frozencontrolsequence)
    goto _Lbadfmt_;
  parloc = x;
  partoken = cstokenflag + parloc;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x < hashbase || x > frozencontrolsequence)   /*1319:*/
    goto _Lbadfmt_;
  writeloc = x;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x < hashbase || x > frozencontrolsequence)
    goto _Lbadfmt_;
  hashused = x;
  p = hashbase - 1;
  do {
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if (x <= p || x > hashused)
      goto _Lbadfmt_;
    p = x;
    pget(pppfmtfile);
    hash[p - hashbase] = pppfmtfile.hh;
  } while (p != hashused);
  for (p = hashused + 1; p < undefinedcontrolsequence; p++) {
    pget(pppfmtfile);
    hash[p - hashbase] = pppfmtfile.hh;
  }
  pget(pppfmtfile);
  cscount = pppfmtfile.int_;   /*:1319*/
  /*:1314*/
  if(!fonts_undump(fmtfile,termout))
	goto _Lbadfmt_;
  /*1325:*/
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if ((unsigned long)x > hyphsize)
    goto _Lbadfmt_;
  hyphcount = x;
  for (k = 1; k <= hyphcount; k++) {
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if ((unsigned long)x > hyphsize)
      goto _Lbadfmt_;
    j = x;
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if (!str_valid(x))
      goto _Lbadfmt_;
    hyphword[j] = x;
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if ((unsigned long)x > maxhalfword)
      goto _Lbadfmt_;
    hyphlist[j] = x;
  }
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x < 0)
    goto _Lbadfmt_;
  if (x > triesize) {
    fprintf(termout, "---! Must increase the trie size\n");
    goto _Lbadfmt_;
  }
  j = x;
  triemax = j;
  for (k = 0; k <= j; k++) {
    pget(pppfmtfile);
    trie[k] = pppfmtfile.hh;
  }
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if (x < 0)
    goto _Lbadfmt_;
  if (x > trieopsize) {
    fprintf(termout, "---! Must increase the trie op size\n");
    goto _Lbadfmt_;
  }
  j = x;
  trieopptr = j;
  for (k = 1; k <= j; k++) {
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if ((unsigned long)x > 63)
      goto _Lbadfmt_;
    hyfdistance[k - 1] = x;
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if ((unsigned long)x > 63)
      goto _Lbadfmt_;
    hyfnum[k - 1] = x;
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if ((unsigned long)x > maxquarterword)
      goto _Lbadfmt_;
    hyfnext[k - 1] = x;
  }
  for (k = 0; k <= 255; k++)
    trieused[k] = minquarterword;
  k = 256;
  while (j > 0) {
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if ((unsigned long)x >= k)
      goto _Lbadfmt_;
    k = x;
    pget(pppfmtfile);
    x = pppfmtfile.int_;
    if (x < 1 || x > j)
      goto _Lbadfmt_;
    trieused[k] = x;
    j -= x;
    opstart[k] = j - minquarterword;
  }
  trienotready = false;   /*:1325*/
  /*1327:*/
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if ((unsigned long)x > errorstopmode)
    goto _Lbadfmt_;
  interaction = x;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
#if 0
  if ((unsigned long)x > strptr)
    goto _Lbadfmt_;
#else
    if (!str_valid(x))
      goto _Lbadfmt_;
#endif
  formatident = x;
  pget(pppfmtfile);
  x = pppfmtfile.int_;
  if ((x != 69069L) | feof(fmtfile))
    goto _Lbadfmt_;   /*:1327*/
  Result = true;
  goto _Lexit;
_Lbadfmt_:
  fprintf(termout, "(Fatal format file error; I'm stymied)\n");
  Result = false;
_Lexit:
  return Result;
}

/*:1303*/
/*1330:*/
/*1333:*/
Static void closefilesandterminate(void)
{  /*1378:*/
  long k;
  for (k = 0; k <= 15; k++) {
    if (writeopen[k])   /*:1378*/
      aclose(&writefile[k]);
  }
  /*_STAT*/
  if (tracingstats > 0) {   /*_ENDSTAT*/
    /*1334:*/
    if (logopened) {   /*:1334*/
      fprintf(logfile, " \n");
      fprintf(logfile, "Here is how much of TeX's memory you used:\n");
#if 0
      fprintf(logfile, " %d string",strptr - initstrptr);
      if (strptr != initstrptr + 1) {
	fprintf(logfile, "s");
      }
      fprintf(logfile, " out of %ld\n", (long)(maxstrings - initstrptr));
      fprintf(logfile, " %d string characters out of %ld\n",
	      poolptr - initpoolptr, (long)(poolsize - initpoolptr));
#else
	str_print_stats(logfile);
#endif
      fprintf(logfile, " %ld words of memory out of %ld\n",
	      lomemmax - memmin + memend - himemmin + 2L,
	      memend - memmin + 1L);
      fprintf(logfile, " %ld multiletter control sequences out of %ld\n",
	      cscount, (long)hashsize);
      fprintf(logfile, " %d words of font info for %d font",fmemptr,
		fontptr);
      if (fontptr !=  1) {
	fprintf(logfile, "s");
      }
      fprintf(logfile, ", out of %ld for %ld\n",
	      (long)fontmemsize, (long)(fontmax ));
      fprintf(logfile, " %d hyphenation exception",hyphcount);
      if (hyphcount != 1) {
	fprintf(logfile, "s");
      }
      fprintf(logfile, " out of %ld\n", (long)hyphsize);
      fprintf(logfile,
	" %di,%dn,%ldp,%db,%ds stack positions out of %ldi,%ldn,%ldp,%ldb,%lds\n",
	maxinstack, maxneststack, maxparamstack, maxbufstack + 1,
	maxsavestack + 6, (long)stacksize, (long)nestsize, (long)paramsize,
	(long)bufsize, (long)savesize);
    }
  }
  /*642:*/
  while (curs > -1) {
    if (curs > 0) {
#if 0
      dviout(pop);
#else
	dvi_pop();
#endif
    } else {
#if 0
      dviout(eop);
#else
	dvi_eop();
#endif
      totalpages++;
    }
    curs--;
  }
  if (totalpages == 0)
    printnl(S("No pages of output."));
  else {   /*:642*/
    long total_dvi_bytes;
#if 0
    dvipost();
    dvifour(25400000L);
    dvifour(473628672L);
    preparemag();
    dvifour(mag);
    dvifour(maxv);
    dvifour(maxh);
    dviout(maxpush / 256);
    dviout(maxpush & 255);
    dviout((totalpages / 256) & 255);
    dviout(totalpages & 255);   /*643:*/
    while (fontptr > 0 ) {   /*:643*/
      if (fontused[fontptr ])
	dvifontdef(fontptr);
      fontptr--;
    }
#else
    preparemag();
    dvipost(25400000L,473628672L,mag,maxv,maxh,maxpush,totalpages,fontptr);
#endif
    total_dvi_bytes=dviflush();
    printnl(S("Output written on "));
    slowprint(outputfilename);
    print(S(" ("));
    printint(totalpages);
    print(S(" page"));
    if (totalpages != 1)
      printchar('s');
    print(S(", "));
    printint(total_dvi_bytes);
    print(S(" bytes)."));
#if 0
    bclose(&dvifile);
#endif
  }
  if (!logopened)
    return;
  putc('\n', logfile);
  aclose(&logfile);
  selector -= 2;
  if (selector != termonly)
    return;
  printnl(S("Transcript written on "));
  slowprint(logname);
  printchar('.');
  println();
}


/*:1333*/
/*1335:*/
Static void finalcleanup(void)
{
  smallnumber c;

  c = curchr;
  if (jobname == 0)
    openlogfile();
  while (inputptr > 0) {
    if (state == tokenlist)
      endtokenlist();
    else
      endfilereading();
  }
  while (openparens > 0) {
    print(S(" )"));
    openparens--;
  }
  if (curlevel > levelone) {
    printnl('(');
    printesc(S("end occurred "));
    print(S("inside a group at level "));
    printint(curlevel - levelone);
    printchar(')');
  }
  while (condptr != 0) {
    printnl('(');
    printesc(S("end occurred "));
    print(S("when "));
    printcmdchr(iftest, curif);
    if (ifline != 0) {
      print(S(" on line "));
      printint(ifline);
    }
    print(S(" was incomplete)"));
    ifline = iflinefield(condptr);
    curif = subtype(condptr);
    tempptr = condptr;
    condptr = link(condptr);
    freenode(tempptr, ifnodesize);
  }
  if (history != spotless) {
    if (history == warningissued || interaction < errorstopmode) {
      if (selector == termandlog) {
	selector = termonly;
	printnl(S("(see the transcript file for additional information)"));
	selector = termandlog;
      }
    }
  }
  if (c == 1) {
    for (c = topmarkcode; c <= splitbotmarkcode; c++) {
      if (curmark[c - topmarkcode] != 0)
	deletetokenref(curmark[c - topmarkcode]);
    }
    storefmtfile();
    goto _Lexit;
/* p2c: tex1.p: Note: Deleting unreachable code [255] */
  }
_Lexit: ;
}


/*:1335*/
/*1336:*/
Static void initprim(void)
{
/*
  nonewcontrolsequence = false; */  /*226:*/
  primitive(S("lineskip"), assignglue, gluebase);
  primitive(S("baselineskip"), assignglue, gluebase + baselineskipcode);
  primitive(S("parskip"), assignglue, gluebase + parskipcode);
  primitive(S("abovedisplayskip"), assignglue, gluebase + abovedisplayskipcode);
  primitive(S("belowdisplayskip"), assignglue, gluebase + belowdisplayskipcode);
  primitive(S("abovedisplayshortskip"), assignglue,
	    gluebase + abovedisplayshortskipcode);
  primitive(S("belowdisplayshortskip"), assignglue,
	    gluebase + belowdisplayshortskipcode);
  primitive(S("leftskip"), assignglue, gluebase + leftskipcode);
  primitive(S("rightskip"), assignglue, gluebase + rightskipcode);
  primitive(S("topskip"), assignglue, gluebase + topskipcode);
  primitive(S("splittopskip"), assignglue, gluebase + splittopskipcode);
  primitive(S("tabskip"), assignglue, gluebase + tabskipcode);
  primitive(S("spaceskip"), assignglue, gluebase + spaceskipcode);
  primitive(S("xspaceskip"), assignglue, gluebase + xspaceskipcode);
  primitive(S("parfillskip"), assignglue, gluebase + parfillskipcode);
  primitive(S("thinmuskip"), assignmuglue, gluebase + thinmuskipcode);
  primitive(S("medmuskip"), assignmuglue, gluebase + medmuskipcode);
  primitive(S("thickmuskip"), assignmuglue, gluebase + thickmuskipcode);
  /*:226*/
  /*230:*/
  primitive(S("output"), assigntoks, outputroutineloc);
  primitive(S("everypar"), assigntoks, everyparloc);
  primitive(S("everymath"), assigntoks, everymathloc);
  primitive(S("everydisplay"), assigntoks, everydisplayloc);
  primitive(S("everyhbox"), assigntoks, everyhboxloc);
  primitive(S("everyvbox"), assigntoks, everyvboxloc);
  primitive(S("everyjob"), assigntoks, everyjobloc);
  primitive(S("everycr"), assigntoks, everycrloc);
  primitive(S("errhelp"), assigntoks, errhelploc);   /*:230*/
  /*238:*/
  primitive(S("pretolerance"), assignint, intbase);
  primitive(S("tolerance"), assignint, intbase + tolerancecode);
  primitive(S("linepenalty"), assignint, intbase + linepenaltycode);
  primitive(S("hyphenpenalty"), assignint, intbase + hyphenpenaltycode);
  primitive(S("exhyphenpenalty"), assignint, intbase + exhyphenpenaltycode);
  primitive(S("clubpenalty"), assignint, intbase + clubpenaltycode);
  primitive(S("widowpenalty"), assignint, intbase + widowpenaltycode);
  primitive(S("displaywidowpenalty"), assignint, intbase + displaywidowpenaltycode);
  primitive(S("brokenpenalty"), assignint, intbase + brokenpenaltycode);
  primitive(S("binoppenalty"), assignint, intbase + binoppenaltycode);
  primitive(S("relpenalty"), assignint, intbase + relpenaltycode);
  primitive(S("predisplaypenalty"), assignint, intbase + predisplaypenaltycode);
  primitive(S("postdisplaypenalty"), assignint, intbase + postdisplaypenaltycode);
  primitive(S("interlinepenalty"), assignint, intbase + interlinepenaltycode);
  primitive(S("doublehyphendemerits"), assignint, intbase + doublehyphendemeritscode);
  primitive(S("finalhyphendemerits"), assignint, intbase + finalhyphendemeritscode);
  primitive(S("adjdemerits"), assignint, intbase + adjdemeritscode);
  primitive(S("mag"), assignint, intbase + magcode);
  primitive(S("delimiterfactor"), assignint, intbase + delimiterfactorcode);
  primitive(S("looseness"), assignint, intbase + loosenesscode);
  primitive(S("time"), assignint, intbase + timecode);
  primitive(S("day"), assignint, intbase + daycode);
  primitive(S("month"), assignint, intbase + monthcode);
  primitive(S("year"), assignint, intbase + yearcode);
  primitive(S("showboxbreadth"), assignint, intbase + showboxbreadthcode);
  primitive(S("showboxdepth"), assignint, intbase + showboxdepthcode);
  primitive(S("hbadness"), assignint, intbase + hbadnesscode);
  primitive(S("vbadness"), assignint, intbase + vbadnesscode);
  primitive(S("pausing"), assignint, intbase + pausingcode);
  primitive(S("tracingonline"), assignint, intbase + tracingonlinecode);
  primitive(S("tracingmacros"), assignint, intbase + tracingmacroscode);
  primitive(S("tracingstats"), assignint, intbase + tracingstatscode);
  primitive(S("tracingparagraphs"), assignint, intbase + tracingparagraphscode);
  primitive(S("tracingpages"), assignint, intbase + tracingpagescode);
  primitive(S("tracingoutput"), assignint, intbase + tracingoutputcode);
  primitive(S("tracinglostchars"), assignint, intbase + tracinglostcharscode);
  primitive(S("tracingcommands"), assignint, intbase + tracingcommandscode);
  primitive(S("tracingrestores"), assignint, intbase + tracingrestorescode);
  primitive(S("uchyph"), assignint, intbase + uchyphcode);
  primitive(S("outputpenalty"), assignint, intbase + outputpenaltycode);
  primitive(S("maxdeadcycles"), assignint, intbase + maxdeadcyclescode);
  primitive(S("hangafter"), assignint, intbase + hangaftercode);
  primitive(S("floatingpenalty"), assignint, intbase + floatingpenaltycode);
  primitive(S("globaldefs"), assignint, intbase + globaldefscode);
  primitive(S("fam"), assignint, intbase + curfamcode);
  primitive(S("escapechar"), assignint, intbase + escapecharcode);
  primitive(S("defaulthyphenchar"), assignint, intbase + defaulthyphencharcode);
  primitive(S("defaultskewchar"), assignint, intbase + defaultskewcharcode);
  primitive(S("endlinechar"), assignint, intbase + endlinecharcode);
  primitive(S("newlinechar"), assignint, intbase + newlinecharcode);
  primitive(S("language"), assignint, intbase + languagecode);
  primitive(S("lefthyphenmin"), assignint, intbase + lefthyphenmincode);
  primitive(S("righthyphenmin"), assignint, intbase + righthyphenmincode);
  primitive(S("holdinginserts"), assignint, intbase + holdinginsertscode);
  primitive(S("errorcontextlines"), assignint, intbase + errorcontextlinescode);
  /*:238*/
  /*248:*/
  primitive(S("parindent"), assigndimen, dimenbase);
  primitive(S("mathsurround"), assigndimen, dimenbase + mathsurroundcode);
  primitive(S("lineskiplimit"), assigndimen, dimenbase + lineskiplimitcode);
  primitive(S("hsize"), assigndimen, dimenbase + hsizecode);
  primitive(S("vsize"), assigndimen, dimenbase + vsizecode);
  primitive(S("maxdepth"), assigndimen, dimenbase + maxdepthcode);
  primitive(S("splitmaxdepth"), assigndimen, dimenbase + splitmaxdepthcode);
  primitive(S("boxmaxdepth"), assigndimen, dimenbase + boxmaxdepthcode);
  primitive(S("hfuzz"), assigndimen, dimenbase + hfuzzcode);
  primitive(S("vfuzz"), assigndimen, dimenbase + vfuzzcode);
  primitive(S("delimitershortfall"), assigndimen,
	    dimenbase + delimitershortfallcode);
  primitive(S("nulldelimiterspace"), assigndimen,
	    dimenbase + nulldelimiterspacecode);
  primitive(S("scriptspace"), assigndimen, dimenbase + scriptspacecode);
  primitive(S("predisplaysize"), assigndimen, dimenbase + predisplaysizecode);
  primitive(S("displaywidth"), assigndimen, dimenbase + displaywidthcode);
  primitive(S("displayindent"), assigndimen, dimenbase + displayindentcode);
  primitive(S("overfullrule"), assigndimen, dimenbase + overfullrulecode);
  primitive(S("hangindent"), assigndimen, dimenbase + hangindentcode);
  primitive(S("hoffset"), assigndimen, dimenbase + hoffsetcode);
  primitive(S("voffset"), assigndimen, dimenbase + voffsetcode);
  primitive(S("emergencystretch"), assigndimen, dimenbase + emergencystretchcode);
  /*:248*/
  /*265:*/
  primitive(' ', exspace, 0);
  primitive('/', italcorr, 0);
  primitive(S("accent"), accent, 0);
  primitive(S("advance"), advance, 0);
  primitive(S("afterassignment"), afterassignment, 0);
  primitive(S("aftergroup"), aftergroup, 0);
  primitive(S("begingroup"), begingroup, 0);
  primitive(S("char"), charnum, 0);
  primitive(S("csname"), csname, 0);
  primitive(S("delimiter"), delimnum, 0);
  primitive(S("divide"), divide, 0);
  primitive(S("endcsname"), endcsname, 0);
  primitive(S("endgroup"), endgroup, 0);
  text(frozenendgroup) = S("endgroup");
  eqtb[frozenendgroup - activebase] = eqtb[curval - activebase];
  primitive(S("expandafter"), expandafter, 0);
  primitive(S("font"), deffont, 0);
  primitive(S("fontdimen"), assignfontdimen, 0);
  primitive(S("halign"), halign, 0);
  primitive(S("hrule"), hrule, 0);
  primitive(S("ignorespaces"), ignorespaces, 0);
  primitive(S("insert"), insert_, 0);
  primitive(S("mark"), mark_, 0);
  primitive(S("mathaccent"), mathaccent, 0);
  primitive(S("mathchar"), mathcharnum, 0);
  primitive(S("mathchoice"), mathchoice, 0);
  primitive(S("multiply"), multiply, 0);
  primitive(S("noalign"), noalign, 0);
  primitive(S("noboundary"), noboundary, 0);
  primitive(S("noexpand"), noexpand, 0);
  primitive(S("nonscript"), nonscript, 0);
  primitive(S("omit"), omit, 0);
  primitive(S("parshape"), setshape, 0);
  primitive(S("penalty"), breakpenalty, 0);
  primitive(S("prevgraf"), setprevgraf, 0);
  primitive(S("radical"), radical, 0);
  primitive(S("read"), readtocs, 0);
  primitive(S("relax"), relax, 256);
  text(frozenrelax) = S("relax");
  eqtb[frozenrelax - activebase] = eqtb[curval - activebase];
  primitive(S("setbox"), setbox, 0);
  primitive(S("the"), the, 0);
  primitive(S("toks"), toksregister, 0);
  primitive(S("vadjust"), vadjust, 0);
  primitive(S("valign"), valign, 0);
  primitive(S("vcenter"), vcenter, 0);
  primitive(S("vrule"), vrule, 0);   /*:265*/
  /*334:*/
  primitive(S("par"), parend, 256);
  parloc = curval;
  partoken = cstokenflag + parloc;   /*:334*/
  /*376:*/
  primitive(S("input"), input, 0);
  primitive(S("endinput"), input, 1);   /*:376*/
  /*384:*/
  primitive(S("topmark"), topbotmark, topmarkcode);
  primitive(S("firstmark"), topbotmark, firstmarkcode);
  primitive(S("botmark"), topbotmark, botmarkcode);
  primitive(S("splitfirstmark"), topbotmark, splitfirstmarkcode);
  primitive(S("splitbotmark"), topbotmark, splitbotmarkcode);   /*:384*/
  /*411:*/
  primitive(S("count"), register_, intval);
  primitive(S("dimen"), register_, dimenval);
  primitive(S("skip"), register_, glueval);
  primitive(S("muskip"), register_, muval);   /*:411*/
  /*416:*/
  primitive(S("spacefactor"), setaux, hmode);
  primitive(S("prevdepth"), setaux, vmode);
  primitive(S("deadcycles"), setpageint, 0);
  primitive(S("insertpenalties"), setpageint, 1);
  primitive(S("wd"), setboxdimen, widthoffset);
  primitive(S("ht"), setboxdimen, heightoffset);
  primitive(S("dp"), setboxdimen, depthoffset);
  primitive(S("lastpenalty"), lastitem, intval);
  primitive(S("lastkern"), lastitem, dimenval);
  primitive(S("lastskip"), lastitem, glueval);
  primitive(S("inputlineno"), lastitem, inputlinenocode);
  primitive(S("badness"), lastitem, badnesscode);   /*:416*/
  /*468:*/
  primitive(S("number"), convert, numbercode);
  primitive(S("romannumeral"), convert, romannumeralcode);
  primitive(S("string"), convert, stringcode);
  primitive(S("meaning"), convert, meaningcode);
  primitive(S("fontname"), convert, fontnamecode);
  primitive(S("jobname"), convert, jobnamecode);   /*:468*/
  /*487:*/
  primitive(S("if"), iftest, ifcharcode);
  primitive(S("ifcat"), iftest, ifcatcode);
  primitive(S("ifnum"), iftest, ifintcode);
  primitive(S("ifdim"), iftest, ifdimcode);
  primitive(S("ifodd"), iftest, ifoddcode);
  primitive(S("ifvmode"), iftest, ifvmodecode);
  primitive(S("ifhmode"), iftest, ifhmodecode);
  primitive(S("ifmmode"), iftest, ifmmodecode);
  primitive(S("ifinner"), iftest, ifinnercode);
  primitive(S("ifvoid"), iftest, ifvoidcode);
  primitive(S("ifhbox"), iftest, ifhboxcode);
  primitive(S("ifvbox"), iftest, ifvboxcode);
  primitive(S("ifx"), iftest, ifxcode);
  primitive(S("ifeof"), iftest, ifeofcode);
  primitive(S("iftrue"), iftest, iftruecode);
  primitive(S("iffalse"), iftest, iffalsecode);
  primitive(S("ifcase"), iftest, ifcasecode);   /*:487*/
  /*491:*/
  primitive(S("fi"), fiorelse, ficode);
  text(frozenfi) = S("fi");
  eqtb[frozenfi - activebase] = eqtb[curval - activebase];
  primitive(S("or"), fiorelse, orcode);
  primitive(S("else"), fiorelse, elsecode);   /*:491*/
  /*553:*/
  primitive(S("nullfont"), setfont, nullfont);
  text(frozennullfont) = S("nullfont");
  eqtb[frozennullfont - activebase] = eqtb[curval - activebase];   /*:553*/
  /*780:*/
  primitive(S("span"), tabmark, spancode);
  primitive(S("cr"), carret, crcode);
  text(frozencr) = S("cr");
  eqtb[frozencr - activebase] = eqtb[curval - activebase];
  primitive(S("crcr"), carret, crcrcode);
  text(frozenendtemplate) = S("endtemplate");
  text(frozenendv) = S("endtemplate");
  eqtype(frozenendv) = endv;
  equiv(frozenendv) = nulllist;
  eqlevel(frozenendv) = levelone;
  eqtb[frozenendtemplate - activebase] = eqtb[frozenendv - activebase];
  eqtype(frozenendtemplate) = endtemplate;   /*:780*/
  /*983:*/
  primitive(S("pagegoal"), setpagedimen, 0);
  primitive(S("pagetotal"), setpagedimen, 1);
  primitive(S("pagestretch"), setpagedimen, 2);
  primitive(S("pagefilstretch"), setpagedimen, 3);
  primitive(S("pagefillstretch"), setpagedimen, 4);
  primitive(S("pagefilllstretch"), setpagedimen, 5);
  primitive(S("pageshrink"), setpagedimen, 6);
  primitive(S("pagedepth"), setpagedimen, 7);   /*:983*/
  /*1052:*/
  primitive(S("end"), stop, 0);
  primitive(S("dump"), stop, 1);   /*:1052*/
  /*1058:*/
  primitive(S("hskip"), hskip, skipcode);
  primitive(S("hfil"), hskip, filcode);
  primitive(S("hfill"), hskip, fillcode);
  primitive(S("hss"), hskip, sscode);
  primitive(S("hfilneg"), hskip, filnegcode);
  primitive(S("vskip"), vskip, skipcode);
  primitive(S("vfil"), vskip, filcode);
  primitive(S("vfill"), vskip, fillcode);
  primitive(S("vss"), vskip, sscode);
  primitive(S("vfilneg"), vskip, filnegcode);
  primitive(S("mskip"), mskip, mskipcode);
  primitive(S("kern"), kern, explicit);
  primitive(S("mkern"), mkern, muglue);   /*:1058*/
  /*1071:*/
  primitive(S("moveleft"), hmove, 1);
  primitive(S("moveright"), hmove, 0);
  primitive(S("raise"), vmove, 1);
  primitive(S("lower"), vmove, 0);
  primitive(S("box"), makebox, boxcode);
  primitive(S("copy"), makebox, copycode);
  primitive(S("lastbox"), makebox, lastboxcode);
  primitive(S("vsplit"), makebox, vsplitcode);
  primitive(S("vtop"), makebox, vtopcode);
  primitive(S("vbox"), makebox, vtopcode + vmode);
  primitive(S("hbox"), makebox, vtopcode + hmode);
  primitive(S("shipout"), leadership, aleaders - 1);
  primitive(S("leaders"), leadership, aleaders);
  primitive(S("cleaders"), leadership, cleaders);
  primitive(S("xleaders"), leadership, xleaders);   /*:1071*/
  /*1088:*/
  primitive(S("indent"), startpar, 1);
  primitive(S("noindent"), startpar, 0);   /*:1088*/
  /*1107:*/
  primitive(S("unpenalty"), removeitem, penaltynode);
  primitive(S("unkern"), removeitem, kernnode);
  primitive(S("unskip"), removeitem, gluenode);
  primitive(S("unhbox"), unhbox, boxcode);
  primitive(S("unhcopy"), unhbox, copycode);
  primitive(S("unvbox"), unvbox, boxcode);
  primitive(S("unvcopy"), unvbox, copycode);   /*:1107*/
  /*1114:*/
  primitive('-', discretionary, 1);
  primitive(S("discretionary"), discretionary, 0);   /*:1114*/
  /*1141:*/
  primitive(S("eqno"), eqno, 0);
  primitive(S("leqno"), eqno, 1);   /*:1141*/
  /*1156:*/
  primitive(S("mathord"), mathcomp, ordnoad);
  primitive(S("mathop"), mathcomp, opnoad);
  primitive(S("mathbin"), mathcomp, binnoad);
  primitive(S("mathrel"), mathcomp, relnoad);
  primitive(S("mathopen"), mathcomp, opennoad);
  primitive(S("mathclose"), mathcomp, closenoad);
  primitive(S("mathpunct"), mathcomp, punctnoad);
  primitive(S("mathinner"), mathcomp, innernoad);
  primitive(S("underline"), mathcomp, undernoad);
  primitive(S("overline"), mathcomp, overnoad);
  primitive(S("displaylimits"), limitswitch, normal);
  primitive(S("limits"), limitswitch, limits);
  primitive(S("nolimits"), limitswitch, nolimits);   /*:1156*/
  /*1169:*/
  primitive(S("displaystyle"), mathstyle, displaystyle);
  primitive(S("textstyle"), mathstyle, textstyle);
  primitive(S("scriptstyle"), mathstyle, scriptstyle);
  primitive(S("scriptscriptstyle"), mathstyle, scriptscriptstyle);   /*:1169*/
  /*1178:*/
  primitive(S("above"), above, abovecode);
  primitive(S("over"), above, overcode);
  primitive(S("atop"), above, atopcode);
  primitive(S("abovewithdelims"), above, delimitedcode);
  primitive(S("overwithdelims"), above, delimitedcode + overcode);
  primitive(S("atopwithdelims"), above, delimitedcode + atopcode);   /*:1178*/
  /*1188:*/
  primitive(S("left"), leftright, leftnoad);
  primitive(S("right"), leftright, rightnoad);
  text(frozenright) = S("right");
  eqtb[frozenright - activebase] = eqtb[curval - activebase];   /*:1188*/
  /*1208:*/
  primitive(S("long"), prefix, 1);
  primitive(S("outer"), prefix, 2);
  primitive(S("global"), prefix, 4);
  primitive(S("def"), def, 0);
  primitive(S("gdef"), def, 1);
  primitive(S("edef"), def, 2);
  primitive(S("xdef"), def, 3);
  /*:1208*/
  /*1219:*/
  primitive(S("let"), let, normal);
  primitive(S("futurelet"), let, normal + 1);   /*:1219*/
  /*1222:*/
  primitive(S("chardef"), shorthanddef, chardefcode);
  primitive(S("mathchardef"), shorthanddef, mathchardefcode);
  primitive(S("countdef"), shorthanddef, countdefcode);
  primitive(S("dimendef"), shorthanddef, dimendefcode);
  primitive(S("skipdef"), shorthanddef, skipdefcode);
  primitive(S("muskipdef"), shorthanddef, muskipdefcode);
  primitive(S("toksdef"), shorthanddef, toksdefcode);   /*:1222*/
  /*1230:*/
  primitive(S("catcode"), defcode, catcodebase);
  primitive(S("mathcode"), defcode, mathcodebase);
  primitive(S("lccode"), defcode, lccodebase);
  primitive(S("uccode"), defcode, uccodebase);
  primitive(S("sfcode"), defcode, sfcodebase);
  primitive(S("delcode"), defcode, delcodebase);
  primitive(S("textfont"), deffamily, mathfontbase);
  primitive(S("scriptfont"), deffamily, mathfontbase + scriptsize);
  primitive(S("scriptscriptfont"), deffamily, mathfontbase + scriptscriptsize);
  /*:1230*/
  /*1250:*/
  primitive(S("hyphenation"), hyphdata, 0);
  primitive(S("patterns"), hyphdata, 1);   /*:1250*/
  /*1254:*/
  primitive(S("hyphenchar"), assignfontint, 0);
  primitive(S("skewchar"), assignfontint, 1);   /*:1254*/
  /*1262:*/
  primitive(S("batchmode"), setinteraction, batchmode);
  primitive(S("nonstopmode"), setinteraction, nonstopmode);
  primitive(S("scrollmode"), setinteraction, scrollmode);
  primitive(S("errorstopmode"), setinteraction, errorstopmode);   /*:1262*/
  /*1272:*/
  primitive(S("openin"), instream, 1);
  primitive(S("closein"), instream, 0);   /*:1272*/
  /*1277:*/
  primitive(S("message"), message, 0);
  primitive(S("errmessage"), message, 1);   /*:1277*/
  /*1286:*/
  primitive(S("lowercase"), caseshift, lccodebase);
  primitive(S("uppercase"), caseshift, uccodebase);   /*:1286*/
  /*1291:*/
  primitive(S("show"), xray, showcode);
  primitive(S("showbox"), xray, showboxcode);
  primitive(S("showthe"), xray, showthecode);
  primitive(S("showlists"), xray, showlists);   /*:1291*/
  /*1344:*/
  primitive(S("openout"), extension, opennode);
  primitive(S("write"), extension, writenode);
  writeloc = curval;
  primitive(S("closeout"), extension, closenode);
  primitive(S("special"), extension, specialnode);
  primitive(S("immediate"), extension, immediatecode);
  primitive(S("setlanguage"), extension, setlanguagecode);   /*:1344*/
/*
  nonewcontrolsequence = true;
*/
}


/*:1336*/
/*1338:*/
/*_DEBUG*/
Static void debughelp(void)
{
  long k, l, m, n;

  while (true) {
    printnl(S("debug # (-1 to exit): "));
    fflush(termout);
    fscanf(termin," %ld",&m);
    if (m < 0) {
      goto _Lexit;
      continue;
    }
    if (m == 0) {
      goto _Lbreakpoint_;
_Lbreakpoint_:
      m = 0;   /*'BREAKPOINT'*/
      continue;
    }
    fscanf(termin," %ld",&n);
    switch (m) {   /*1339:*/

    case 1:
      printword(mem[n - memmin]);
      break;

    case 2:
      printint(info(n));
      break;

    case 3:
      printint(link(n));
      break;

    case 4:
      printword(eqtb[n - activebase]);
      break;

    case 5:
      printword(fontinfo[n]);
      break;

    case 6:
      printword(savestack[n]);
      break;

    case 7:
      showbox(n);
      break;

    case 8:
      breadthmax = 10000;
#if 0
      depththreshold = poolsize - poolptr - 10;
#else
	depththreshold = str_adjust_to_room(poolsize) - 10;
#endif
      shownodelist(n);
      break;

    case 9:
      showtokenlist(n, 0, 1000);
      break;

    case 10:
      slowprint(n);
      break;

    case 11:
      checkmem(n > 0);
      break;

    case 12:
      searchmem(n);
      break;

    case 13:
      fscanf(termin, " %ld", &l);
      printcmdchr(n, l);
      break;

    case 14:
      for (k = 0; k <= n; k++)
	print(buffer[k]);
      break;

    case 15:
      fontinshortdisplay = nullfont;
      shortdisplay(n);
      break;

    case 16:   /*:1339*/
      panicking = !panicking;
      break;

    default:
      print('?');
      break;
    }
  }
_Lexit: ;
}

/*_ENDDEBUG*/
/*:1338*/
/*:1330*/
/*1332:*/
int main(int argc, char *argv[])
{

  PASCAL_MAIN(argc, argv);
  if (setjmp(_JLendofTEX))
    goto _LendofTEX;
  if (setjmp(_JLfinalend))
    goto _Lfinalend;
  fmtfile = NULL;
  tfmfile = NULL;
  dvifile = NULL;
  logfile = NULL;
/*  poolfile = NULL; */
  termout = NULL;
  termin = NULL;
  curfile = NULL;
  history = fatalerrorstop;
  topenout();
  if (readyalready == 314159L)   /*14:*/
    goto _LstartofTEX;
  bad = 0;
  if (halferrorline < 30 || halferrorline > errorline - 15)
    bad = 1;
  if (maxprintline < 60)
    bad = 2;
  if ((dvibufsize & 7) != 0)
    bad = 3;
  if (membot + 1100 > memtop)
    bad = 4;
  if (hashprime > hashsize)
    bad = 5;
  if (maxinopen >= 128)
    bad = 6;
  if (memtop < 267)   /*:14*/
    bad = 7;
  /*111:*/
  if (memmin != membot || memmax != memtop)
    bad = 10;
  if (memmin > membot || memmax < memtop)
    bad = 10;
  if (minquarterword > 0 || maxquarterword < 127)
    bad = 11;
  if (maxhalfword < 32767)
    bad = 12;
  if (minquarterword < 0 || maxquarterword > maxhalfword)
    bad = 13;
  if (memmin < 0 || memmax >= maxhalfword || membot - memmin > maxhalfword + 1)
    bad = 14;
  if ( 0 < minquarterword || fontmax > maxquarterword)
    bad = 15;
  if (fontmax > 256)
    bad = 16;
  if (savesize > maxhalfword || maxstrings > maxhalfword)
    bad = 17;
  if (bufsize > maxhalfword)
    bad = 18;
  if (maxquarterword - minquarterword < 255)   /*:111*/
    bad = 19;
  /*290:*/
  if (cstokenflag + undefinedcontrolsequence > maxhalfword)   /*:290*/
    bad = 21;
  /*522:*/
  if (formatdefaultlength > filenamesize)
    bad = 31;
  /*:522*/
  /*1249:*/
  if (maxhalfword * 2 < memtop - memmin)   /*:1249*/
    bad = 41;
  if (bad > 0) {
    fprintf(termout,
	    "Ouch---my internal constants have been clobbered!---case %ld\n",
	    bad);
    goto _Lfinalend;
  }
  initialize();
  if (!getstringsstarted())
    goto _Lfinalend;
  initprim();
#if 0
  initstrptr = strptr;
  initpoolptr = poolptr;
#else 
  str_set_init_ptrs();
#endif
  fixdateandtime();
  readyalready = 314159L;
_LstartofTEX:   /*55:*/
  selector = termonly;
  tally = 0;
  termoffset = 0;
  fileoffset = 0;
  /*:55*/
  /*61:*/
  fprintf(termout,"%s",banner);
  if (formatident == 0)
    fprintf(termout, " (no format preloaded)\n");
  else {
    slowprint(formatident);
    println();
  }
  fflush(termout);   /*:61*/
  /*528:*/
  jobname = 0;
  nameinprogress = false;
  logopened = false;   /*:528*/
  /*533:*/
  outputfilename = 0;   /*:533*/
  /*1337:*/
  /*331:*/
  inputptr = 0;
  maxinstack = 0;
  inopen = 0;
  openparens = 0;
  maxbufstack = 0;
  paramptr = 0;
  maxparamstack = 0;
  first = bufsize;
  do {
    buffer[first] = 0;
    first--;
  } while (first != 0);
  scannerstatus = normal;
  warningindex = 0;
  first = 1;
  state = newline;
  start = 1;
  iindex = 0;
  line = 0;
  name = 0;
  forceeof = false;
  alignstate = 1000000L;
  if (!initterminal())
    goto _Lfinalend;
  limit = last;
  first = last + 1;   /*:331*/
  if ( need_to_load_format /* (formatident == 0) | (buffer[loc] == '&') */ ) {
    if (formatident != 0)
      initialize();
    if (!openfmtfile())
      goto _Lfinalend;
    if (!loadfmtfile()) {
      wclose(&fmtfile);
      goto _Lfinalend;
    }
    wclose(&fmtfile);
    while ((loc < limit) & (buffer[loc] == ' '))
      loc++;
  }
  if (endlinecharinactive) {
    limit--;
  } else
    buffer[limit] = endlinechar;
  fixdateandtime();   /*765:*/
  /*75:*/
  if (interaction == batchmode)
    selector = noprint;
  else {
    selector = termonly;
    /*
:75*/
  }
  if ((loc < limit) & (catcode(buffer[loc]) != escape))   /*:1337*/
    startinput();
  history = spotless;
  maincontrol();
  finalcleanup();
_LendofTEX:
  closefilesandterminate();
_Lfinalend:
  readyalready = 0;
  if (termin != NULL)
    fclose(termin);
  if (termout != NULL)
    fclose(termout);
/*
  if (poolfile != NULL)
    fclose(poolfile);
*/
  if (logfile != NULL)
    fclose(logfile);
  if (dvifile != NULL)
    fclose(dvifile);
  if (tfmfile != NULL)
    fclose(tfmfile);
  if (fmtfile != NULL)
    fclose(fmtfile);
  exit(EXIT_SUCCESS);
}  /*:1332*/



/* End. */
